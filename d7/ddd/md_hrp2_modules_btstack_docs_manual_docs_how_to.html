<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ETrobocon2017 - 片山研究所モデルベース開発推進事業部: how_to</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ETrobocon2017 - 片山研究所モデルベース開発推進事業部
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 構築: Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'検索');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','検索');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">how_to </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>BTstack implements a set of basic Bluetooth protocols. To make use of these to connect to other devices or to provide own services, BTstack has to be properly configured during application startup.</p>
<p>In the following, we provide an overview of the memory management, the run loop, and services that are necessary to setup BTstack. From the point when the run loop is executed, the application runs as a finite state machine, which processes events received from BTstack. BTstack groups events logically and provides them over packet handlers, of which an overview is provided here. Finally, we describe the RFCOMM credit-based flow-control, which may be necessary for resource-constraint devices.</p>
<h2>Memory configuration {#sec:memoryConfigurationHowTo}</h2>
<p>The structs for services, active connections and remote devices can be allocated in two different manners:</p>
<ul>
<li>statically from an individual memory pool, whose maximal number of elements is defined in the config file. To initialize the static pools, you need to call <em>btstack_memory_init</em> function. An example of memory configuration for a single SPP service with a minimal L2CAP MTU is shown in Listing {:memoryConfigurationSPP}.</li>
<li>dynamically using the <em>malloc/free</em> functions, if HAVE_MALLOC is defined in config file.</li>
</ul>
<pre class="fragment">#define HCI_ACL_PAYLOAD_SIZE 52
#define MAX_SPP_CONNECTIONS 1
#define MAX_NO_HCI_CONNECTIONS MAX_SPP_CONNECTIONS
#define MAX_NO_L2CAP_SERVICES  2
#define MAX_NO_L2CAP_CHANNELS  (1+MAX_SPP_CONNECTIONS)
#define MAX_NO_RFCOMM_MULTIPLEXERS MAX_SPP_CONNECTIONS
#define MAX_NO_RFCOMM_SERVICES 1
#define MAX_NO_RFCOMM_CHANNELS MAX_SPP_CONNECTIONS
#define MAX_NO_DB_MEM_DEVICE_NAMES  0
#define MAX_NO_DB_MEM_LINK_KEYS  3
#define MAX_NO_DB_MEM_SERVICES 1
</pre><p>Listing: Title. {#lst:memoryConfigurationSPP}</p>
<p>If both HAVE_MALLOC and maximal size of a pool are defined in the config file, the statical allocation will take precedence. In case that both are omitted, an error will be raised.</p>
<p>The memory is set up by calling <em>btstack_memory_init</em> function:</p>
<pre class="fragment">btstack_memory_init();
</pre><h2>Run loop {#sec:runLoopHowTo}</h2>
<p>BTstack uses a run loop to handle incoming data and to schedule work. The run loop handles events from two different types of sources: data sources and timers. Data sources represent communication interfaces like an UART or an USB driver. Timers are used by BTstack to implement various Bluetooth-related timeouts. They can also be used to handle periodic events.</p>
<p>Data sources and timers are represented by the <em>data_source_t</em> and <em>timer_source_t</em> structs respectively. Each of these structs contain a linked list node and a pointer to a callback function. All active timers and data sources are kept in link lists. While the list of data sources is unsorted, the timers are sorted by expiration timeout for efficient processing.</p>
<p>The complete run loop cycle looks like this: first, the callback function of all registered data sources are called in a round robin way. Then, the callback functions of timers that are ready are executed. Finally, it will be checked if another run loop iteration has been requested by an interrupt handler. If not, the run loop will put the MCU into sleep mode.</p>
<p>Incoming data over the UART, USB, or timer ticks will generate an interrupt and wake up the microcontroller. In order to avoid the situation where a data source becomes ready just before the run loop enters sleep mode, an interrupt-driven data source has to call the <em>embedded_trigger</em> function. The call to <em>embedded_trigger</em> sets an internal flag that is checked in the critical section just before entering sleep mode.</p>
<p>Timers are single shot: a timer will be removed from the timer list before its event handler callback is executed. If you need a periodic timer, you can re-register the same timer source in the callback function, as shown in Listing [PeriodicTimerHandler]. Note that BTstack expects to get called periodically to keep its time, see Section <a href="../../#sec:timeAbstractionPorting">on time abstraction</a> for more on the tick hardware abstraction.</p>
<p>The run loop is set up by calling <em>run_loop_init</em> function for embedded systems:</p>
<pre class="fragment">run_loop_init(RUN_LOOP_EMBEDDED);
</pre><p>The Run loop API is provided <a href="../../appendix/apis/#sec:runLoopAPIAppendix">here</a>. To enable the use of timers, make sure that you defined HAVE_TICK in the config file.</p>
<p>In your code, you’ll have to configure the run loop before you start it as shown in Listing [listing:btstackInit]. The application can register data sources as well as timers, e.g., periodical sampling of sensors, or communication over the UART.</p>
<h2>BTstack initialization {#sec:btstackInitializationHowTo}</h2>
<p>To initialize BTstack you need to <a href="../../#sec:memoryConfigurationHowTo">initialize the memory</a> and <a href="../../#sec:runLoopHowTo">the run loop</a> respectively, then setup HCI and all needed higher level protocols.</p>
<p>The HCI initialization has to adapt BTstack to the used platform and requires four arguments. These are:</p>
<ul>
<li><p class="startli"><em>Bluetooth hardware control</em>: The Bluetooth hardware control API can provide the HCI layer with a custom initialization script, a vendor-specific baud rate change command, and system power notifications. It is also used to control the power mode of the Bluetooth module, i.e., turning it on/off and putting to sleep. In addition, it provides an error handler <em>hw_error</em> that is called when a Hardware Error is reported by the Bluetooth module. The callback allows for persistent logging or signaling of this failure.</p>
<p class="startli">Overall, the struct <em>bt_control_t</em> encapsulates common functionality that is not covered by the Bluetooth specification. As an example, the <em>bt_con-trol_cc256x_in-stance</em> function returns a pointer to a control struct suitable for the CC256x chipset.</p>
</li>
</ul>
<pre class="fragment">bt_control_t * control = bt_control_cc256x_instance();
</pre><ul>
<li><em>HCI Transport implementation</em>: On embedded systems, a Bluetooth module can be connected via USB or an UART port. BTstack implements two UART based protocols: HCI UART Transport Layer (H4) and H4 with eHCILL support, a lightweight low-power variant by Texas Instruments. These are accessed by linking the appropriate file [src/hci_transport_h4_dma.c]() resp. [src/hci_transport_h4_ehcill_dma.c]() and then getting a pointer to HCI Transport implementation. For more information on adapting HCI Transport to different environments, see <a href="../../porting/#sec:hciTransportPorting">here</a>.</li>
</ul>
<pre class="fragment">hci_transport_t * transport = hci_transport_h4_dma_instance();
</pre><ul>
<li><em>HCI Transport configuration</em>: As the configuration of the UART used in the H4 transport interface are not standardized, it has to be provided by the main application to BTstack. In addition to the initial UART baud rate, the main baud rate can be specified. The HCI layer of BTstack will change the init baud rate to the main one after the basic setup of the Bluetooth module. A baud rate change has to be done in a coordinated way at both HCI and hardware level. First, the HCI command to change the baud rate is sent, then it is necessary to wait for the confirmation event from the Bluetooth module. Only now, can the UART baud rate changed. As an example, the CC256x has to be initialized at 115200 and can then be used at higher speeds.</li>
</ul>
<pre class="fragment">hci_uart_config_t* config = hci_uart_config_cc256x_instance();
</pre><ul>
<li><em>Persistent storage</em> - specifies where to persist data like link keys or remote device names. This commonly requires platform specific code to access the MCU’s EEPROM of Flash storage. For the first steps, BTstack provides a (non) persistent store in memory. For more see <a href="../../porting/#sec:persistentStoragePorting">here</a>.</li>
</ul>
<pre class="fragment">remote_device_db_t * remote_db = &amp;remote_device_db_memory;
</pre><p>After these are ready, HCI is initialized like this:</p>
<pre class="fragment">hci_init(transport, config, control, remote_db);
</pre><p>The higher layers only rely on BTstack and are initialized by calling the respective **_init* function. These init functions register themselves with the underlying layer. In addition, the application can register packet handlers to get events and data as explained in the following section.</p>
<h2>Services {#sec:servicesHowTo}</h2>
<p>One important construct of BTstack is <em>service</em>. A service represents a server side component that handles incoming connections. So far, BTstack provides L2CAP and RFCOMM services. An L2CAP service handles incoming connections for an L2CAP channel and is registered with its protocol service multiplexer ID (PSM). Similarly, an RFCOMM service handles incoming RFCOMM connections and is registered with the RFCOMM channel ID. Outgoing connections require no special registration, they are created by the application when needed.</p>
<h2>Where to get data - packet handlers {#sec:packetHandlersHowTo}</h2>
<p>After the hardware and BTstack are set up, the run loop is entered. From now on everything is event driven. The application calls BTstack functions, which in turn may send commands to the Bluetooth module. The resulting events are delivered back to the application. Instead of writing a single callback handler for each possible event (as it is done in some other Bluetooth stacks), BTstack groups events logically and provides them over a single generic interface. Appendix <a href="../../generated/appendix/#sec:eventsAndErrorsAppendix">Events and Errors</a> summarizes the parameters and event codes of L2CAP and RFCOMM events, as well as possible errors and the corresponding error codes.</p>
<p>Here is summarized list of packet handlers that an application might use:</p>
<ul>
<li>HCI packet handler - handles HCI and general BTstack events if L2CAP is not used (rare case).</li>
<li>L2CAP packet handler - handles HCI and general BTstack events.</li>
<li>L2CAP service packet handler - handles incoming L2CAP connections, i.e., channels initiated by the remote.</li>
<li>L2CAP channel packet handler - handles outgoing L2CAP connections, i.e., channels initiated internally.</li>
<li>RFCOMM packet handler - handles RFCOMM incoming/outgoing events and data.</li>
</ul>
<p>These handlers are registered with the functions listed in Table {:registeringFunction}.</p>
<hr/>
<p> Packet Handler Registering Function HCI packet handler <em>hci_register_packet_handler</em> L2CAP packet handler <em>l2cap_register_packet_handler</em> L2CAP service packet handler <em>l2cap_register_service_internal</em> L2CAP channel packet handler <em>l2cap_create_channel_internal</em> RFCOMM packet handler <em>rfcomm_register_packet_handler</em> </p><hr/>
<p>Table: Functions for registering packet handlers. {#tbl:registeringFunction}</p>
<p>HCI and general BTstack events are delivered to the packet handler specified by <em>l2cap_register_packet_handler</em> function, or <em>hci_register_packet_handler</em>, if L2CAP is not used. In L2CAP, BTstack discriminates incoming and outgoing connections, i.e., event and data packets are delivered to different packet handlers. Outgoing connections are used access remote services, incoming connections are used to provide services. For incoming connections, the packet handler specified by <em>l2cap_register_service</em> is used. For outgoing connections, the handler provided by <em>l2cap_create_channel_internal</em> is used. Currently, RFCOMM provides only a single packet handler specified by <em>rfcomm_register_packet_handler</em> for all RFCOMM connections, but this will be fixed in the next API overhaul.</p>
<p>The application can register a single shared packet handler for all protocols and services, or use separate packet handlers for each protocol layer and service. A shared packet handler is often used for stack initialization and connection management.</p>
<p>Separate packet handlers can be used for each L2CAP service and outgoing connection. For example, to connect with a Bluetooth HID keyboard, your application could use three packet handlers: one to handle HCI events during discovery of a keyboard registered by <em>l2cap_register_packet_handler</em>; one that will be registered to an outgoing L2CAP channel to connect to keyboard and to receive keyboard data registered by <em>l2cap_create_channel_internal</em>; after that keyboard can reconnect by itself. For this, you need to register L2CAP services for the HID Control and HID Interrupt PSMs using <em>l2cap_register_service_internal</em>. In this call, you’ll also specify a packet handler to accept and receive keyboard data.</p>
<h2>Bluetooth HCI Packet Logs {#sec:packetlogsHowTo}</h2>
<p>If things don't work as expected, having a look at the data exchanged between BTstack and the Bluetooth chipset often helps.</p>
<p>For this, BTstack provides a configurable packet logging mechanism via hci_dump.h: </p><pre class="fragment">// formats: HCI_DUMP_BLUEZ, HCI_DUMP_PACKETLOGGER, HCI_DUMP_STDOUT
void hci_dump_open(const char *filename, hci_dump_format_t format);
</pre><p>On POSIX systems, you can call <em>hci_dump_open</em> with a path and <em>HCI_DUMP_BLUEZ</em> or <em>HCI_DUMP_PACKETLOGGER</em> in the setup, i.e., before entering the run loop. The resulting file can be analyzed with Wireshark or the Apple's PacketLogger tool.</p>
<p>On embedded systems without a file system, you still can call <em>hci_dump_open(NULL, HCI_DUMP_STDOUT)</em>. It will log all HCI packets to the consolve via printf. If you capture the console output, incl. your own debug messages, you can use the create_packet_log.py tool in the tools folder to convert a text output into a PacketLogger file.</p>
<p>In addition to the HCI packets, you can also enable BTstack's debug information by adding </p><pre class="fragment">#define ENABLE_LOG_INFO 
#define ENABLE_LOG_ERROR
</pre><p>to the btstack-config.h and recompiling your application. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
構築: &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
