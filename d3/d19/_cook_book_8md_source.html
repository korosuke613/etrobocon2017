<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ETrobocon2017: str/googletest/googlemock/docs/CookBook.md ソースファイル</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ETrobocon2017
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 構築: Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'検索');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','検索');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('d3/d19/_cook_book_8md.html','../../');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">str/googletest/googlemock/docs/CookBook.md</div>  </div>
</div><!--header-->
<div class="contents">
<a href="../../d3/d19/_cook_book_8md.html">[詳解]</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;You can find recipes for using Google Mock here. If you haven&#39;t yet,</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;please read the [ForDummies](ForDummies.md) document first to make sure you understand</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;the basics.</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;**Note:** Google Mock lives in the `testing` name space. For</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;readability, it is recommended to write `using ::testing::Foo;` once in</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;your file before using the name `Foo` defined by Google Mock. We omit</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;such `using` statements in this page for brevity, but you should do it</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;in your own code.</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;# Creating Mock Classes #</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;## Mocking Private or Protected Methods ##</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;You must always put a mock method definition (`MOCK_METHOD*`) in a</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;`public:` section of the mock class, regardless of the method being</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;mocked being `public`, `protected`, or `private` in the base class.</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;This allows `ON_CALL` and `EXPECT_CALL` to reference the mock function</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;from outside of the mock class.  (Yes, C++ allows a subclass to change</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;the access level of a virtual function in the base class.)  Example:</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;```</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;class Foo {</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160; public:</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;  ...</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;  virtual bool Transform(Gadget* g) = 0;</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160; protected:</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;  virtual void Resume();</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160; private:</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;  virtual int GetTimeOut();</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;};</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;class MockFoo : public Foo {</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160; public:</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;  ...</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;  MOCK_METHOD1(Transform, bool(Gadget* g));</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;  // The following must be in the public section, even though the</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;  // methods are protected or private in the base class.</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;  MOCK_METHOD0(Resume, void());</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;  MOCK_METHOD0(GetTimeOut, int());</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;};</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;```</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;## Mocking Overloaded Methods ##</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;You can mock overloaded functions as usual. No special attention is required:</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;```</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;class Foo {</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;  ...</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;  // Must be virtual as we&#39;ll inherit from Foo.</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;  virtual ~Foo();</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;  // Overloaded on the types and/or numbers of arguments.</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;  virtual int Add(Element x);</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;  virtual int Add(int times, Element x);</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;  // Overloaded on the const-ness of this object.</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;  virtual Bar&amp; GetBar();</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;  virtual const Bar&amp; GetBar() const;</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;};</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;class MockFoo : public Foo {</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;  ...</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;  MOCK_METHOD1(Add, int(Element x));</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;  MOCK_METHOD2(Add, int(int times, Element x);</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;  MOCK_METHOD0(GetBar, Bar&amp;());</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;  MOCK_CONST_METHOD0(GetBar, const Bar&amp;());</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;};</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;```</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;**Note:** if you don&#39;t mock all versions of the overloaded method, the</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;compiler will give you a warning about some methods in the base class</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;being hidden. To fix that, use `using` to bring them in scope:</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;```</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;class MockFoo : public Foo {</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;  ...</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;  using Foo::Add;</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;  MOCK_METHOD1(Add, int(Element x));</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;  // We don&#39;t want to mock int Add(int times, Element x);</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;  ...</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;};</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;```</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;## Mocking Class Templates ##</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;To mock a class template, append `_T` to the `MOCK_*` macros:</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;```</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;template &lt;typename Elem&gt;</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;class StackInterface {</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;  ...</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;  // Must be virtual as we&#39;ll inherit from StackInterface.</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;  virtual ~StackInterface();</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;  virtual int GetSize() const = 0;</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;  virtual void Push(const Elem&amp; x) = 0;</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;};</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;template &lt;typename Elem&gt;</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;class MockStack : public StackInterface&lt;Elem&gt; {</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;  ...</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;  MOCK_CONST_METHOD0_T(GetSize, int());</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;  MOCK_METHOD1_T(Push, void(const Elem&amp; x));</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;};</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;```</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;## Mocking Nonvirtual Methods ##</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;Google Mock can mock non-virtual functions to be used in what we call _hi-perf</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;dependency injection_.</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;In this case, instead of sharing a common base class with the real</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;class, your mock class will be _unrelated_ to the real class, but</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;contain methods with the same signatures.  The syntax for mocking</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;non-virtual methods is the _same_ as mocking virtual methods:</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;```</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;// A simple packet stream class.  None of its members is virtual.</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;class ConcretePacketStream {</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160; public:</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;  void AppendPacket(Packet* new_packet);</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;  const Packet* GetPacket(size_t packet_number) const;</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;  size_t NumberOfPackets() const;</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;  ...</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;};</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;// A mock packet stream class.  It inherits from no other, but defines</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;// GetPacket() and NumberOfPackets().</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;class MockPacketStream {</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160; public:</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;  MOCK_CONST_METHOD1(GetPacket, const Packet*(size_t packet_number));</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;  MOCK_CONST_METHOD0(NumberOfPackets, size_t());</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;  ...</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;};</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;```</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;Note that the mock class doesn&#39;t define `AppendPacket()`, unlike the</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;real class. That&#39;s fine as long as the test doesn&#39;t need to call it.</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;Next, you need a way to say that you want to use</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;`ConcretePacketStream` in production code, and use `MockPacketStream`</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;in tests.  Since the functions are not virtual and the two classes are</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;unrelated, you must specify your choice at _compile time_ (as opposed</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;to run time).</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;One way to do it is to templatize your code that needs to use a packet</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;stream.  More specifically, you will give your code a template type</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;argument for the type of the packet stream.  In production, you will</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;instantiate your template with `ConcretePacketStream` as the type</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;argument.  In tests, you will instantiate the same template with</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;`MockPacketStream`.  For example, you may write:</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;```</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;template &lt;class PacketStream&gt;</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;void CreateConnection(PacketStream* stream) { ... }</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;template &lt;class PacketStream&gt;</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;class PacketReader {</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160; public:</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;  void ReadPackets(PacketStream* stream, size_t packet_num);</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;};</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;```</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;Then you can use `CreateConnection&lt;ConcretePacketStream&gt;()` and</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;`PacketReader&lt;ConcretePacketStream&gt;` in production code, and use</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;`CreateConnection&lt;MockPacketStream&gt;()` and</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;`PacketReader&lt;MockPacketStream&gt;` in tests.</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;```</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;  MockPacketStream mock_stream;</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;  EXPECT_CALL(mock_stream, ...)...;</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;  .. set more expectations on mock_stream ...</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;  PacketReader&lt;MockPacketStream&gt; reader(&amp;mock_stream);</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;  ... exercise reader ...</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;```</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;## Mocking Free Functions ##</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;It&#39;s possible to use Google Mock to mock a free function (i.e. a</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;C-style function or a static method).  You just need to rewrite your</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;code to use an interface (abstract class).</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;Instead of calling a free function (say, `OpenFile`) directly,</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;introduce an interface for it and have a concrete subclass that calls</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;the free function:</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;```</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;class FileInterface {</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160; public:</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;  ...</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;  virtual bool Open(const char* path, const char* mode) = 0;</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;};</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;class File : public FileInterface {</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160; public:</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;  ...</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;  virtual bool Open(const char* path, const char* mode) {</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;    return OpenFile(path, mode);</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;  }</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;};</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;```</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;Your code should talk to `FileInterface` to open a file.  Now it&#39;s</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;easy to mock out the function.</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;This may seem much hassle, but in practice you often have multiple</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;related functions that you can put in the same interface, so the</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;per-function syntactic overhead will be much lower.</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;If you are concerned about the performance overhead incurred by</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;virtual functions, and profiling confirms your concern, you can</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;combine this with the recipe for [mocking non-virtual methods](#mocking-nonvirtual-methods).</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;## The Nice, the Strict, and the Naggy ##</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;If a mock method has no `EXPECT_CALL` spec but is called, Google Mock</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;will print a warning about the &quot;uninteresting call&quot;. The rationale is:</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;  * New methods may be added to an interface after a test is written. We shouldn&#39;t fail a test just because a method it doesn&#39;t know about is called.</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;  * However, this may also mean there&#39;s a bug in the test, so Google Mock shouldn&#39;t be silent either. If the user believes these calls are harmless, he can add an `EXPECT_CALL()` to suppress the warning.</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;However, sometimes you may want to suppress all &quot;uninteresting call&quot;</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;warnings, while sometimes you may want the opposite, i.e. to treat all</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;of them as errors. Google Mock lets you make the decision on a</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;per-mock-object basis.</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;Suppose your test uses a mock class `MockFoo`:</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;```</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;TEST(...) {</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;  MockFoo mock_foo;</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;  EXPECT_CALL(mock_foo, DoThis());</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;  ... code that uses mock_foo ...</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;}</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;```</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;If a method of `mock_foo` other than `DoThis()` is called, it will be</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;reported by Google Mock as a warning. However, if you rewrite your</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;test to use `NiceMock&lt;MockFoo&gt;` instead, the warning will be gone,</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;resulting in a cleaner test output:</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;```</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;using ::testing::NiceMock;</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;TEST(...) {</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;  NiceMock&lt;MockFoo&gt; mock_foo;</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;  EXPECT_CALL(mock_foo, DoThis());</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;  ... code that uses mock_foo ...</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;}</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;```</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;`NiceMock&lt;MockFoo&gt;` is a subclass of `MockFoo`, so it can be used</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;wherever `MockFoo` is accepted.</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;It also works if `MockFoo`&#39;s constructor takes some arguments, as</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;`NiceMock&lt;MockFoo&gt;` &quot;inherits&quot; `MockFoo`&#39;s constructors:</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;```</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;using ::testing::NiceMock;</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;TEST(...) {</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;  NiceMock&lt;MockFoo&gt; mock_foo(5, &quot;hi&quot;);  // Calls MockFoo(5, &quot;hi&quot;).</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;  EXPECT_CALL(mock_foo, DoThis());</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;  ... code that uses mock_foo ...</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;}</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;```</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;The usage of `StrictMock` is similar, except that it makes all</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;uninteresting calls failures:</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;```</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;using ::testing::StrictMock;</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;TEST(...) {</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;  StrictMock&lt;MockFoo&gt; mock_foo;</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;  EXPECT_CALL(mock_foo, DoThis());</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;  ... code that uses mock_foo ...</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;  // The test will fail if a method of mock_foo other than DoThis()</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;  // is called.</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;}</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;```</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;There are some caveats though (I don&#39;t like them just as much as the</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;next guy, but sadly they are side effects of C++&#39;s limitations):</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;</div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;  1. `NiceMock&lt;MockFoo&gt;` and `StrictMock&lt;MockFoo&gt;` only work for mock methods defined using the `MOCK_METHOD*` family of macros **directly** in the `MockFoo` class. If a mock method is defined in a **base class** of `MockFoo`, the &quot;nice&quot; or &quot;strict&quot; modifier may not affect it, depending on the compiler. In particular, nesting `NiceMock` and `StrictMock` (e.g. `NiceMock&lt;StrictMock&lt;MockFoo&gt; &gt;`) is **not** supported.</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;  1. The constructors of the base mock (`MockFoo`) cannot have arguments passed by non-const reference, which happens to be banned by the [Google C++ style guide](http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml).</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;  1. During the constructor or destructor of `MockFoo`, the mock object is _not_ nice or strict.  This may cause surprises if the constructor or destructor calls a mock method on `this` object. (This behavior, however, is consistent with C++&#39;s general rule: if a constructor or destructor calls a virtual method of `this` object, that method is treated as non-virtual.  In other words, to the base class&#39;s constructor or destructor, `this` object behaves like an instance of the base class, not the derived class.  This rule is required for safety.  Otherwise a base constructor may use members of a derived class before they are initialized, or a base destructor may use members of a derived class after they have been destroyed.)</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;Finally, you should be **very cautious** about when to use naggy or strict mocks, as they tend to make tests more brittle and harder to maintain. When you refactor your code without changing its externally visible behavior, ideally you should&#39;t need to update any tests. If your code interacts with a naggy mock, however, you may start to get spammed with warnings as the result of your change. Worse, if your code interacts with a strict mock, your tests may start to fail and you&#39;ll be forced to fix them. Our general recommendation is to use nice mocks (not yet the default) most of the time, use naggy mocks (the current default) when developing or debugging tests, and use strict mocks only as the last resort.</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;## Simplifying the Interface without Breaking Existing Code ##</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;Sometimes a method has a long list of arguments that is mostly</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;uninteresting. For example,</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;```</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;class LogSink {</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160; public:</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;  ...</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;  virtual void send(LogSeverity severity, const char* full_filename,</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;                    const char* base_filename, int line,</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;                    const struct tm* tm_time,</div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;                    const char* message, size_t message_len) = 0;</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;};</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;```</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;</div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;This method&#39;s argument list is lengthy and hard to work with (let&#39;s</div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;say that the `message` argument is not even 0-terminated). If we mock</div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;it as is, using the mock will be awkward. If, however, we try to</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;simplify this interface, we&#39;ll need to fix all clients depending on</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;it, which is often infeasible.</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;The trick is to re-dispatch the method in the mock class:</div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;```</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;class ScopedMockLog : public LogSink {</div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160; public:</div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;  ...</div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;  virtual void send(LogSeverity severity, const char* full_filename,</div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;                    const char* base_filename, int line, const tm* tm_time,</div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;                    const char* message, size_t message_len) {</div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;    // We are only interested in the log severity, full file name, and</div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;    // log message.</div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;    Log(severity, full_filename, std::string(message, message_len));</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;  }</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;  // Implements the mock method:</div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;  //</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;  //   void Log(LogSeverity severity,</div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;  //            const string&amp; file_path,</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;  //            const string&amp; message);</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;  MOCK_METHOD3(Log, void(LogSeverity severity, const string&amp; file_path,</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;                         const string&amp; message));</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;};</div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;```</div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;</div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;By defining a new mock method with a trimmed argument list, we make</div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;the mock class much more user-friendly.</div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;</div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;## Alternative to Mocking Concrete Classes ##</div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;</div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;Often you may find yourself using classes that don&#39;t implement</div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;interfaces. In order to test your code that uses such a class (let&#39;s</div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;call it `Concrete`), you may be tempted to make the methods of</div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;`Concrete` virtual and then mock it.</div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;</div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;Try not to do that.</div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;</div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;Making a non-virtual function virtual is a big decision. It creates an</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;extension point where subclasses can tweak your class&#39; behavior. This</div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;weakens your control on the class because now it&#39;s harder to maintain</div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;the class&#39; invariants. You should make a function virtual only when</div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;there is a valid reason for a subclass to override it.</div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;</div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;Mocking concrete classes directly is problematic as it creates a tight</div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;coupling between the class and the tests - any small change in the</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;class may invalidate your tests and make test maintenance a pain.</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;</div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;To avoid such problems, many programmers have been practicing &quot;coding</div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;to interfaces&quot;: instead of talking to the `Concrete` class, your code</div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;would define an interface and talk to it. Then you implement that</div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;interface as an adaptor on top of `Concrete`. In tests, you can easily</div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;mock that interface to observe how your code is doing.</div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;</div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;This technique incurs some overhead:</div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;</div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;  * You pay the cost of virtual function calls (usually not a problem).</div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;  * There is more abstraction for the programmers to learn.</div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;</div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;However, it can also bring significant benefits in addition to better</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;testability:</div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;</div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;  * `Concrete`&#39;s API may not fit your problem domain very well, as you may not be the only client it tries to serve. By designing your own interface, you have a chance to tailor it to your need - you may add higher-level functionalities, rename stuff, etc instead of just trimming the class. This allows you to write your code (user of the interface) in a more natural way, which means it will be more readable, more maintainable, and you&#39;ll be more productive.</div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;  * If `Concrete`&#39;s implementation ever has to change, you don&#39;t have to rewrite everywhere it is used. Instead, you can absorb the change in your implementation of the interface, and your other code and tests will be insulated from this change.</div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;</div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;Some people worry that if everyone is practicing this technique, they</div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;will end up writing lots of redundant code. This concern is totally</div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;understandable. However, there are two reasons why it may not be the</div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;case:</div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;</div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;  * Different projects may need to use `Concrete` in different ways, so the best interfaces for them will be different. Therefore, each of them will have its own domain-specific interface on top of `Concrete`, and they will not be the same code.</div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;  * If enough projects want to use the same interface, they can always share it, just like they have been sharing `Concrete`. You can check in the interface and the adaptor somewhere near `Concrete` (perhaps in a `contrib` sub-directory) and let many projects use it.</div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;</div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;You need to weigh the pros and cons carefully for your particular</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;problem, but I&#39;d like to assure you that the Java community has been</div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;practicing this for a long time and it&#39;s a proven effective technique</div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;applicable in a wide variety of situations. :-)</div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;</div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;## Delegating Calls to a Fake ##</div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;</div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;Some times you have a non-trivial fake implementation of an</div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;interface. For example:</div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;</div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;```</div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;class Foo {</div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160; public:</div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;  virtual ~Foo() {}</div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;  virtual char DoThis(int n) = 0;</div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;  virtual void DoThat(const char* s, int* p) = 0;</div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;};</div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;class FakeFoo : public Foo {</div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160; public:</div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;  virtual char DoThis(int n) {</div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;    return (n &gt; 0) ? &#39;+&#39; :</div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;        (n &lt; 0) ? &#39;-&#39; : &#39;0&#39;;</div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;  }</div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;</div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;  virtual void DoThat(const char* s, int* p) {</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;    *p = strlen(s);</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;  }</div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;};</div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;```</div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;</div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;Now you want to mock this interface such that you can set expectations</div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;on it. However, you also want to use `FakeFoo` for the default</div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;behavior, as duplicating it in the mock object is, well, a lot of</div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;work.</div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;</div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;When you define the mock class using Google Mock, you can have it</div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;delegate its default action to a fake class you already have, using</div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;this pattern:</div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;</div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;```</div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;using ::testing::_;</div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;using ::testing::Invoke;</div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;class MockFoo : public Foo {</div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160; public:</div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;  // Normal mock method definitions using Google Mock.</div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;  MOCK_METHOD1(DoThis, char(int n));</div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;  MOCK_METHOD2(DoThat, void(const char* s, int* p));</div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;</div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;  // Delegates the default actions of the methods to a FakeFoo object.</div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;  // This must be called *before* the custom ON_CALL() statements.</div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;  void DelegateToFake() {</div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;    ON_CALL(*this, DoThis(_))</div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;        .WillByDefault(Invoke(&amp;fake_, &amp;FakeFoo::DoThis));</div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;    ON_CALL(*this, DoThat(_, _))</div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;        .WillByDefault(Invoke(&amp;fake_, &amp;FakeFoo::DoThat));</div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;  }</div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160; private:</div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;  FakeFoo fake_;  // Keeps an instance of the fake in the mock.</div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;};</div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;```</div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;</div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;With that, you can use `MockFoo` in your tests as usual. Just remember</div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;that if you don&#39;t explicitly set an action in an `ON_CALL()` or</div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;`EXPECT_CALL()`, the fake will be called upon to do it:</div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;</div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;```</div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;using ::testing::_;</div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;</div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;TEST(AbcTest, Xyz) {</div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;  MockFoo foo;</div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;  foo.DelegateToFake(); // Enables the fake for delegation.</div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;</div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;  // Put your ON_CALL(foo, ...)s here, if any.</div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;</div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;  // No action specified, meaning to use the default action.</div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;  EXPECT_CALL(foo, DoThis(5));</div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;  EXPECT_CALL(foo, DoThat(_, _));</div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;</div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;  int n = 0;</div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;  EXPECT_EQ(&#39;+&#39;, foo.DoThis(5));  // FakeFoo::DoThis() is invoked.</div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;  foo.DoThat(&quot;Hi&quot;, &amp;n);           // FakeFoo::DoThat() is invoked.</div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;  EXPECT_EQ(2, n);</div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;}</div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;```</div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;</div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;**Some tips:**</div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;</div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;  * If you want, you can still override the default action by providing your own `ON_CALL()` or using `.WillOnce()` / `.WillRepeatedly()` in `EXPECT_CALL()`.</div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;  * In `DelegateToFake()`, you only need to delegate the methods whose fake implementation you intend to use.</div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;  * The general technique discussed here works for overloaded methods, but you&#39;ll need to tell the compiler which version you mean. To disambiguate a mock function (the one you specify inside the parentheses of `ON_CALL()`), see the &quot;Selecting Between Overloaded Functions&quot; section on this page; to disambiguate a fake function (the one you place inside `Invoke()`), use a `static_cast` to specify the function&#39;s type. For instance, if class `Foo` has methods `char DoThis(int n)` and `bool DoThis(double x) const`, and you want to invoke the latter, you need to write `Invoke(&amp;fake_, static_cast&lt;bool (FakeFoo::*)(double) const&gt;(&amp;FakeFoo::DoThis))` instead of `Invoke(&amp;fake_, &amp;FakeFoo::DoThis)` (The strange-looking thing inside the angled brackets of `static_cast` is the type of a function pointer to the second `DoThis()` method.).</div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;  * Having to mix a mock and a fake is often a sign of something gone wrong. Perhaps you haven&#39;t got used to the interaction-based way of testing yet. Or perhaps your interface is taking on too many roles and should be split up. Therefore, **don&#39;t abuse this**. We would only recommend to do it as an intermediate step when you are refactoring your code.</div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;</div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;Regarding the tip on mixing a mock and a fake, here&#39;s an example on</div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;why it may be a bad sign: Suppose you have a class `System` for</div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;low-level system operations. In particular, it does file and I/O</div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;operations. And suppose you want to test how your code uses `System`</div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;to do I/O, and you just want the file operations to work normally. If</div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;you mock out the entire `System` class, you&#39;ll have to provide a fake</div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;implementation for the file operation part, which suggests that</div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;`System` is taking on too many roles.</div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;</div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;Instead, you can define a `FileOps` interface and an `IOOps` interface</div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;and split `System`&#39;s functionalities into the two. Then you can mock</div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;`IOOps` without mocking `FileOps`.</div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;</div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;## Delegating Calls to a Real Object ##</div><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;</div><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;When using testing doubles (mocks, fakes, stubs, and etc), sometimes</div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;their behaviors will differ from those of the real objects. This</div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;difference could be either intentional (as in simulating an error such</div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;that you can test the error handling code) or unintentional. If your</div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;mocks have different behaviors than the real objects by mistake, you</div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;could end up with code that passes the tests but fails in production.</div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;</div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;You can use the _delegating-to-real_ technique to ensure that your</div><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;mock has the same behavior as the real object while retaining the</div><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;ability to validate calls. This technique is very similar to the</div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;delegating-to-fake technique, the difference being that we use a real</div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;object instead of a fake. Here&#39;s an example:</div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;</div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;```</div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;using ::testing::_;</div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;using ::testing::AtLeast;</div><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;using ::testing::Invoke;</div><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;</div><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;class MockFoo : public Foo {</div><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160; public:</div><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;  MockFoo() {</div><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;    // By default, all calls are delegated to the real object.</div><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;    ON_CALL(*this, DoThis())</div><div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;        .WillByDefault(Invoke(&amp;real_, &amp;Foo::DoThis));</div><div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;    ON_CALL(*this, DoThat(_))</div><div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;        .WillByDefault(Invoke(&amp;real_, &amp;Foo::DoThat));</div><div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;    ...</div><div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;  }</div><div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;  MOCK_METHOD0(DoThis, ...);</div><div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;  MOCK_METHOD1(DoThat, ...);</div><div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;  ...</div><div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160; private:</div><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;  Foo real_;</div><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;};</div><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;...</div><div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;</div><div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;  MockFoo mock;</div><div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;</div><div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;  EXPECT_CALL(mock, DoThis())</div><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;      .Times(3);</div><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;  EXPECT_CALL(mock, DoThat(&quot;Hi&quot;))</div><div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;      .Times(AtLeast(1));</div><div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;  ... use mock in test ...</div><div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;```</div><div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;</div><div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;With this, Google Mock will verify that your code made the right calls</div><div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;(with the right arguments, in the right order, called the right number</div><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;of times, etc), and a real object will answer the calls (so the</div><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;behavior will be the same as in production). This gives you the best</div><div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;of both worlds.</div><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;</div><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;## Delegating Calls to a Parent Class ##</div><div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;</div><div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;Ideally, you should code to interfaces, whose methods are all pure</div><div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;virtual. In reality, sometimes you do need to mock a virtual method</div><div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;that is not pure (i.e, it already has an implementation). For example:</div><div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;</div><div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;```</div><div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;class Foo {</div><div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160; public:</div><div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;  virtual ~Foo();</div><div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;</div><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;  virtual void Pure(int n) = 0;</div><div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;  virtual int Concrete(const char* str) { ... }</div><div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;};</div><div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;</div><div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;class MockFoo : public Foo {</div><div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160; public:</div><div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;  // Mocking a pure method.</div><div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;  MOCK_METHOD1(Pure, void(int n));</div><div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;  // Mocking a concrete method.  Foo::Concrete() is shadowed.</div><div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;  MOCK_METHOD1(Concrete, int(const char* str));</div><div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;};</div><div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;```</div><div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;</div><div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;Sometimes you may want to call `Foo::Concrete()` instead of</div><div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;`MockFoo::Concrete()`. Perhaps you want to do it as part of a stub</div><div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;action, or perhaps your test doesn&#39;t need to mock `Concrete()` at all</div><div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;(but it would be oh-so painful to have to define a new mock class</div><div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;whenever you don&#39;t need to mock one of its methods).</div><div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;</div><div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;The trick is to leave a back door in your mock class for accessing the</div><div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;real methods in the base class:</div><div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;</div><div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;```</div><div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;class MockFoo : public Foo {</div><div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160; public:</div><div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;  // Mocking a pure method.</div><div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;  MOCK_METHOD1(Pure, void(int n));</div><div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;  // Mocking a concrete method.  Foo::Concrete() is shadowed.</div><div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;  MOCK_METHOD1(Concrete, int(const char* str));</div><div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;</div><div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;  // Use this to call Concrete() defined in Foo.</div><div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;  int FooConcrete(const char* str) { return Foo::Concrete(str); }</div><div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;};</div><div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;```</div><div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;</div><div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;Now, you can call `Foo::Concrete()` inside an action by:</div><div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;</div><div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;```</div><div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;using ::testing::_;</div><div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;using ::testing::Invoke;</div><div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;...</div><div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;  EXPECT_CALL(foo, Concrete(_))</div><div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;      .WillOnce(Invoke(&amp;foo, &amp;MockFoo::FooConcrete));</div><div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;```</div><div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;</div><div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;or tell the mock object that you don&#39;t want to mock `Concrete()`:</div><div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;</div><div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;```</div><div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;using ::testing::Invoke;</div><div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;...</div><div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;  ON_CALL(foo, Concrete(_))</div><div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;      .WillByDefault(Invoke(&amp;foo, &amp;MockFoo::FooConcrete));</div><div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;```</div><div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;</div><div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;(Why don&#39;t we just write `Invoke(&amp;foo, &amp;Foo::Concrete)`? If you do</div><div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;that, `MockFoo::Concrete()` will be called (and cause an infinite</div><div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;recursion) since `Foo::Concrete()` is virtual. That&#39;s just how C++</div><div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;works.)</div><div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;</div><div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;# Using Matchers #</div><div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;</div><div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;## Matching Argument Values Exactly ##</div><div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;</div><div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;You can specify exactly which arguments a mock method is expecting:</div><div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;</div><div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;```</div><div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;using ::testing::Return;</div><div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;...</div><div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;  EXPECT_CALL(foo, DoThis(5))</div><div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;      .WillOnce(Return(&#39;a&#39;));</div><div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;  EXPECT_CALL(foo, DoThat(&quot;Hello&quot;, bar));</div><div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;```</div><div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;</div><div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;## Using Simple Matchers ##</div><div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;</div><div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;You can use matchers to match arguments that have a certain property:</div><div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;</div><div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;```</div><div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;using ::testing::Ge;</div><div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;using ::testing::NotNull;</div><div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;using ::testing::Return;</div><div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;...</div><div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;  EXPECT_CALL(foo, DoThis(Ge(5)))  // The argument must be &gt;= 5.</div><div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;      .WillOnce(Return(&#39;a&#39;));</div><div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;  EXPECT_CALL(foo, DoThat(&quot;Hello&quot;, NotNull()));</div><div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;  // The second argument must not be NULL.</div><div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;```</div><div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;</div><div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;A frequently used matcher is `_`, which matches anything:</div><div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;</div><div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;```</div><div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;using ::testing::_;</div><div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;using ::testing::NotNull;</div><div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;...</div><div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;  EXPECT_CALL(foo, DoThat(_, NotNull()));</div><div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;```</div><div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;</div><div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;## Combining Matchers ##</div><div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;</div><div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;You can build complex matchers from existing ones using `AllOf()`,</div><div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;`AnyOf()`, and `Not()`:</div><div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;</div><div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;```</div><div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;using ::testing::AllOf;</div><div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;using ::testing::Gt;</div><div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;using ::testing::HasSubstr;</div><div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;using ::testing::Ne;</div><div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;using ::testing::Not;</div><div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;...</div><div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;  // The argument must be &gt; 5 and != 10.</div><div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;  EXPECT_CALL(foo, DoThis(AllOf(Gt(5),</div><div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;                                Ne(10))));</div><div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;</div><div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;  // The first argument must not contain sub-string &quot;blah&quot;.</div><div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;  EXPECT_CALL(foo, DoThat(Not(HasSubstr(&quot;blah&quot;)),</div><div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;                          NULL));</div><div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;```</div><div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;</div><div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;## Casting Matchers ##</div><div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;</div><div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;Google Mock matchers are statically typed, meaning that the compiler</div><div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;can catch your mistake if you use a matcher of the wrong type (for</div><div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;example, if you use `Eq(5)` to match a `string` argument). Good for</div><div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;you!</div><div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;</div><div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;Sometimes, however, you know what you&#39;re doing and want the compiler</div><div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;to give you some slack. One example is that you have a matcher for</div><div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;`long` and the argument you want to match is `int`. While the two</div><div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;types aren&#39;t exactly the same, there is nothing really wrong with</div><div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;using a `Matcher&lt;long&gt;` to match an `int` - after all, we can first</div><div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;convert the `int` argument to a `long` before giving it to the</div><div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;matcher.</div><div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;</div><div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;To support this need, Google Mock gives you the</div><div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;`SafeMatcherCast&lt;T&gt;(m)` function. It casts a matcher `m` to type</div><div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;`Matcher&lt;T&gt;`. To ensure safety, Google Mock checks that (let `U` be the</div><div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;type `m` accepts):</div><div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;</div><div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;  1. Type `T` can be implicitly cast to type `U`;</div><div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;  1. When both `T` and `U` are built-in arithmetic types (`bool`, integers, and floating-point numbers), the conversion from `T` to `U` is not lossy (in other words, any value representable by `T` can also be represented by `U`); and</div><div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;  1. When `U` is a reference, `T` must also be a reference (as the underlying matcher may be interested in the address of the `U` value).</div><div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;</div><div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;The code won&#39;t compile if any of these conditions isn&#39;t met.</div><div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;</div><div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;Here&#39;s one example:</div><div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;</div><div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;```</div><div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;using ::testing::SafeMatcherCast;</div><div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;</div><div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;// A base class and a child class.</div><div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;class Base { ... };</div><div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;class Derived : public Base { ... };</div><div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;</div><div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;class MockFoo : public Foo {</div><div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160; public:</div><div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;  MOCK_METHOD1(DoThis, void(Derived* derived));</div><div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;};</div><div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;...</div><div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;</div><div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;  MockFoo foo;</div><div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;  // m is a Matcher&lt;Base*&gt; we got from somewhere.</div><div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160;  EXPECT_CALL(foo, DoThis(SafeMatcherCast&lt;Derived*&gt;(m)));</div><div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160;```</div><div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;</div><div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;If you find `SafeMatcherCast&lt;T&gt;(m)` too limiting, you can use a similar</div><div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;function `MatcherCast&lt;T&gt;(m)`. The difference is that `MatcherCast` works</div><div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;as long as you can `static_cast` type `T` to type `U`.</div><div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;</div><div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;`MatcherCast` essentially lets you bypass C++&#39;s type system</div><div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;(`static_cast` isn&#39;t always safe as it could throw away information,</div><div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;for example), so be careful not to misuse/abuse it.</div><div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;</div><div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;## Selecting Between Overloaded Functions ##</div><div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;</div><div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;If you expect an overloaded function to be called, the compiler may</div><div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;need some help on which overloaded version it is.</div><div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;</div><div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;To disambiguate functions overloaded on the const-ness of this object,</div><div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;use the `Const()` argument wrapper.</div><div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;</div><div class="line"><a name="l00746"></a><span class="lineno">  746</span>&#160;```</div><div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;using ::testing::ReturnRef;</div><div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;</div><div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;class MockFoo : public Foo {</div><div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;  ...</div><div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;  MOCK_METHOD0(GetBar, Bar&amp;());</div><div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;  MOCK_CONST_METHOD0(GetBar, const Bar&amp;());</div><div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;};</div><div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;...</div><div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;</div><div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;  MockFoo foo;</div><div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;  Bar bar1, bar2;</div><div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;  EXPECT_CALL(foo, GetBar())         // The non-const GetBar().</div><div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;      .WillOnce(ReturnRef(bar1));</div><div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;  EXPECT_CALL(Const(foo), GetBar())  // The const GetBar().</div><div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;      .WillOnce(ReturnRef(bar2));</div><div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;```</div><div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;</div><div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;(`Const()` is defined by Google Mock and returns a `const` reference</div><div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;to its argument.)</div><div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;</div><div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;To disambiguate overloaded functions with the same number of arguments</div><div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;but different argument types, you may need to specify the exact type</div><div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;of a matcher, either by wrapping your matcher in `Matcher&lt;type&gt;()`, or</div><div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;using a matcher whose type is fixed (`TypedEq&lt;type&gt;`, `An&lt;type&gt;()`,</div><div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;etc):</div><div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;</div><div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;```</div><div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160;using ::testing::An;</div><div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;using ::testing::Lt;</div><div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;using ::testing::Matcher;</div><div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;using ::testing::TypedEq;</div><div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;</div><div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;class MockPrinter : public Printer {</div><div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160; public:</div><div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;  MOCK_METHOD1(Print, void(int n));</div><div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;  MOCK_METHOD1(Print, void(char c));</div><div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;};</div><div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;</div><div class="line"><a name="l00785"></a><span class="lineno">  785</span>&#160;TEST(PrinterTest, Print) {</div><div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;  MockPrinter printer;</div><div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;</div><div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;  EXPECT_CALL(printer, Print(An&lt;int&gt;()));            // void Print(int);</div><div class="line"><a name="l00789"></a><span class="lineno">  789</span>&#160;  EXPECT_CALL(printer, Print(Matcher&lt;int&gt;(Lt(5))));  // void Print(int);</div><div class="line"><a name="l00790"></a><span class="lineno">  790</span>&#160;  EXPECT_CALL(printer, Print(TypedEq&lt;char&gt;(&#39;a&#39;)));   // void Print(char);</div><div class="line"><a name="l00791"></a><span class="lineno">  791</span>&#160;</div><div class="line"><a name="l00792"></a><span class="lineno">  792</span>&#160;  printer.Print(3);</div><div class="line"><a name="l00793"></a><span class="lineno">  793</span>&#160;  printer.Print(6);</div><div class="line"><a name="l00794"></a><span class="lineno">  794</span>&#160;  printer.Print(&#39;a&#39;);</div><div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;}</div><div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;```</div><div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160;</div><div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;## Performing Different Actions Based on the Arguments ##</div><div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;</div><div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;When a mock method is called, the _last_ matching expectation that&#39;s</div><div class="line"><a name="l00801"></a><span class="lineno">  801</span>&#160;still active will be selected (think &quot;newer overrides older&quot;). So, you</div><div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;can make a method do different things depending on its argument values</div><div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;like this:</div><div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;</div><div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160;```</div><div class="line"><a name="l00806"></a><span class="lineno">  806</span>&#160;using ::testing::_;</div><div class="line"><a name="l00807"></a><span class="lineno">  807</span>&#160;using ::testing::Lt;</div><div class="line"><a name="l00808"></a><span class="lineno">  808</span>&#160;using ::testing::Return;</div><div class="line"><a name="l00809"></a><span class="lineno">  809</span>&#160;...</div><div class="line"><a name="l00810"></a><span class="lineno">  810</span>&#160;  // The default case.</div><div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;  EXPECT_CALL(foo, DoThis(_))</div><div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160;      .WillRepeatedly(Return(&#39;b&#39;));</div><div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;</div><div class="line"><a name="l00814"></a><span class="lineno">  814</span>&#160;  // The more specific case.</div><div class="line"><a name="l00815"></a><span class="lineno">  815</span>&#160;  EXPECT_CALL(foo, DoThis(Lt(5)))</div><div class="line"><a name="l00816"></a><span class="lineno">  816</span>&#160;      .WillRepeatedly(Return(&#39;a&#39;));</div><div class="line"><a name="l00817"></a><span class="lineno">  817</span>&#160;```</div><div class="line"><a name="l00818"></a><span class="lineno">  818</span>&#160;</div><div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;Now, if `foo.DoThis()` is called with a value less than 5, `&#39;a&#39;` will</div><div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;be returned; otherwise `&#39;b&#39;` will be returned.</div><div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;</div><div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;## Matching Multiple Arguments as a Whole ##</div><div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;</div><div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;Sometimes it&#39;s not enough to match the arguments individually. For</div><div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;example, we may want to say that the first argument must be less than</div><div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;the second argument. The `With()` clause allows us to match</div><div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160;all arguments of a mock function as a whole. For example,</div><div class="line"><a name="l00828"></a><span class="lineno">  828</span>&#160;</div><div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;```</div><div class="line"><a name="l00830"></a><span class="lineno">  830</span>&#160;using ::testing::_;</div><div class="line"><a name="l00831"></a><span class="lineno">  831</span>&#160;using ::testing::Lt;</div><div class="line"><a name="l00832"></a><span class="lineno">  832</span>&#160;using ::testing::Ne;</div><div class="line"><a name="l00833"></a><span class="lineno">  833</span>&#160;...</div><div class="line"><a name="l00834"></a><span class="lineno">  834</span>&#160;  EXPECT_CALL(foo, InRange(Ne(0), _))</div><div class="line"><a name="l00835"></a><span class="lineno">  835</span>&#160;      .With(Lt());</div><div class="line"><a name="l00836"></a><span class="lineno">  836</span>&#160;```</div><div class="line"><a name="l00837"></a><span class="lineno">  837</span>&#160;</div><div class="line"><a name="l00838"></a><span class="lineno">  838</span>&#160;says that the first argument of `InRange()` must not be 0, and must be</div><div class="line"><a name="l00839"></a><span class="lineno">  839</span>&#160;less than the second argument.</div><div class="line"><a name="l00840"></a><span class="lineno">  840</span>&#160;</div><div class="line"><a name="l00841"></a><span class="lineno">  841</span>&#160;The expression inside `With()` must be a matcher of type</div><div class="line"><a name="l00842"></a><span class="lineno">  842</span>&#160;`Matcher&lt; ::testing::tuple&lt;A1, ..., An&gt; &gt;`, where `A1`, ..., `An` are the</div><div class="line"><a name="l00843"></a><span class="lineno">  843</span>&#160;types of the function arguments.</div><div class="line"><a name="l00844"></a><span class="lineno">  844</span>&#160;</div><div class="line"><a name="l00845"></a><span class="lineno">  845</span>&#160;You can also write `AllArgs(m)` instead of `m` inside `.With()`. The</div><div class="line"><a name="l00846"></a><span class="lineno">  846</span>&#160;two forms are equivalent, but `.With(AllArgs(Lt()))` is more readable</div><div class="line"><a name="l00847"></a><span class="lineno">  847</span>&#160;than `.With(Lt())`.</div><div class="line"><a name="l00848"></a><span class="lineno">  848</span>&#160;</div><div class="line"><a name="l00849"></a><span class="lineno">  849</span>&#160;You can use `Args&lt;k1, ..., kn&gt;(m)` to match the `n` selected arguments</div><div class="line"><a name="l00850"></a><span class="lineno">  850</span>&#160;(as a tuple) against `m`. For example,</div><div class="line"><a name="l00851"></a><span class="lineno">  851</span>&#160;</div><div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;```</div><div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;using ::testing::_;</div><div class="line"><a name="l00854"></a><span class="lineno">  854</span>&#160;using ::testing::AllOf;</div><div class="line"><a name="l00855"></a><span class="lineno">  855</span>&#160;using ::testing::Args;</div><div class="line"><a name="l00856"></a><span class="lineno">  856</span>&#160;using ::testing::Lt;</div><div class="line"><a name="l00857"></a><span class="lineno">  857</span>&#160;...</div><div class="line"><a name="l00858"></a><span class="lineno">  858</span>&#160;  EXPECT_CALL(foo, Blah(_, _, _))</div><div class="line"><a name="l00859"></a><span class="lineno">  859</span>&#160;      .With(AllOf(Args&lt;0, 1&gt;(Lt()), Args&lt;1, 2&gt;(Lt())));</div><div class="line"><a name="l00860"></a><span class="lineno">  860</span>&#160;```</div><div class="line"><a name="l00861"></a><span class="lineno">  861</span>&#160;</div><div class="line"><a name="l00862"></a><span class="lineno">  862</span>&#160;says that `Blah()` will be called with arguments `x`, `y`, and `z` where</div><div class="line"><a name="l00863"></a><span class="lineno">  863</span>&#160;`x &lt; y &lt; z`.</div><div class="line"><a name="l00864"></a><span class="lineno">  864</span>&#160;</div><div class="line"><a name="l00865"></a><span class="lineno">  865</span>&#160;As a convenience and example, Google Mock provides some matchers for</div><div class="line"><a name="l00866"></a><span class="lineno">  866</span>&#160;2-tuples, including the `Lt()` matcher above. See the [CheatSheet](CheatSheet.md) for</div><div class="line"><a name="l00867"></a><span class="lineno">  867</span>&#160;the complete list.</div><div class="line"><a name="l00868"></a><span class="lineno">  868</span>&#160;</div><div class="line"><a name="l00869"></a><span class="lineno">  869</span>&#160;Note that if you want to pass the arguments to a predicate of your own</div><div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;(e.g. `.With(Args&lt;0, 1&gt;(Truly(&amp;MyPredicate)))`), that predicate MUST be</div><div class="line"><a name="l00871"></a><span class="lineno">  871</span>&#160;written to take a `::testing::tuple` as its argument; Google Mock will pass the `n` selected arguments as _one_ single tuple to the predicate.</div><div class="line"><a name="l00872"></a><span class="lineno">  872</span>&#160;</div><div class="line"><a name="l00873"></a><span class="lineno">  873</span>&#160;## Using Matchers as Predicates ##</div><div class="line"><a name="l00874"></a><span class="lineno">  874</span>&#160;</div><div class="line"><a name="l00875"></a><span class="lineno">  875</span>&#160;Have you noticed that a matcher is just a fancy predicate that also</div><div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;knows how to describe itself? Many existing algorithms take predicates</div><div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;as arguments (e.g. those defined in STL&#39;s `&lt;algorithm&gt;` header), and</div><div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160;it would be a shame if Google Mock matchers are not allowed to</div><div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;participate.</div><div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;</div><div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;Luckily, you can use a matcher where a unary predicate functor is</div><div class="line"><a name="l00882"></a><span class="lineno">  882</span>&#160;expected by wrapping it inside the `Matches()` function. For example,</div><div class="line"><a name="l00883"></a><span class="lineno">  883</span>&#160;</div><div class="line"><a name="l00884"></a><span class="lineno">  884</span>&#160;```</div><div class="line"><a name="l00885"></a><span class="lineno">  885</span>&#160;#include &lt;algorithm&gt;</div><div class="line"><a name="l00886"></a><span class="lineno">  886</span>&#160;#include &lt;vector&gt;</div><div class="line"><a name="l00887"></a><span class="lineno">  887</span>&#160;</div><div class="line"><a name="l00888"></a><span class="lineno">  888</span>&#160;std::vector&lt;int&gt; v;</div><div class="line"><a name="l00889"></a><span class="lineno">  889</span>&#160;...</div><div class="line"><a name="l00890"></a><span class="lineno">  890</span>&#160;// How many elements in v are &gt;= 10?</div><div class="line"><a name="l00891"></a><span class="lineno">  891</span>&#160;const int count = count_if(v.begin(), v.end(), Matches(Ge(10)));</div><div class="line"><a name="l00892"></a><span class="lineno">  892</span>&#160;```</div><div class="line"><a name="l00893"></a><span class="lineno">  893</span>&#160;</div><div class="line"><a name="l00894"></a><span class="lineno">  894</span>&#160;Since you can build complex matchers from simpler ones easily using</div><div class="line"><a name="l00895"></a><span class="lineno">  895</span>&#160;Google Mock, this gives you a way to conveniently construct composite</div><div class="line"><a name="l00896"></a><span class="lineno">  896</span>&#160;predicates (doing the same using STL&#39;s `&lt;functional&gt;` header is just</div><div class="line"><a name="l00897"></a><span class="lineno">  897</span>&#160;painful). For example, here&#39;s a predicate that&#39;s satisfied by any</div><div class="line"><a name="l00898"></a><span class="lineno">  898</span>&#160;number that is &gt;= 0, &lt;= 100, and != 50:</div><div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160;</div><div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;```</div><div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;Matches(AllOf(Ge(0), Le(100), Ne(50)))</div><div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;```</div><div class="line"><a name="l00903"></a><span class="lineno">  903</span>&#160;</div><div class="line"><a name="l00904"></a><span class="lineno">  904</span>&#160;## Using Matchers in Google Test Assertions ##</div><div class="line"><a name="l00905"></a><span class="lineno">  905</span>&#160;</div><div class="line"><a name="l00906"></a><span class="lineno">  906</span>&#160;Since matchers are basically predicates that also know how to describe</div><div class="line"><a name="l00907"></a><span class="lineno">  907</span>&#160;themselves, there is a way to take advantage of them in</div><div class="line"><a name="l00908"></a><span class="lineno">  908</span>&#160;[Google Test](../../googletest/) assertions. It&#39;s</div><div class="line"><a name="l00909"></a><span class="lineno">  909</span>&#160;called `ASSERT_THAT` and `EXPECT_THAT`:</div><div class="line"><a name="l00910"></a><span class="lineno">  910</span>&#160;</div><div class="line"><a name="l00911"></a><span class="lineno">  911</span>&#160;```</div><div class="line"><a name="l00912"></a><span class="lineno">  912</span>&#160;  ASSERT_THAT(value, matcher);  // Asserts that value matches matcher.</div><div class="line"><a name="l00913"></a><span class="lineno">  913</span>&#160;  EXPECT_THAT(value, matcher);  // The non-fatal version.</div><div class="line"><a name="l00914"></a><span class="lineno">  914</span>&#160;```</div><div class="line"><a name="l00915"></a><span class="lineno">  915</span>&#160;</div><div class="line"><a name="l00916"></a><span class="lineno">  916</span>&#160;For example, in a Google Test test you can write:</div><div class="line"><a name="l00917"></a><span class="lineno">  917</span>&#160;</div><div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;```</div><div class="line"><a name="l00919"></a><span class="lineno">  919</span>&#160;#include &quot;gmock/gmock.h&quot;</div><div class="line"><a name="l00920"></a><span class="lineno">  920</span>&#160;</div><div class="line"><a name="l00921"></a><span class="lineno">  921</span>&#160;using ::testing::AllOf;</div><div class="line"><a name="l00922"></a><span class="lineno">  922</span>&#160;using ::testing::Ge;</div><div class="line"><a name="l00923"></a><span class="lineno">  923</span>&#160;using ::testing::Le;</div><div class="line"><a name="l00924"></a><span class="lineno">  924</span>&#160;using ::testing::MatchesRegex;</div><div class="line"><a name="l00925"></a><span class="lineno">  925</span>&#160;using ::testing::StartsWith;</div><div class="line"><a name="l00926"></a><span class="lineno">  926</span>&#160;...</div><div class="line"><a name="l00927"></a><span class="lineno">  927</span>&#160;</div><div class="line"><a name="l00928"></a><span class="lineno">  928</span>&#160;  EXPECT_THAT(Foo(), StartsWith(&quot;Hello&quot;));</div><div class="line"><a name="l00929"></a><span class="lineno">  929</span>&#160;  EXPECT_THAT(Bar(), MatchesRegex(&quot;Line \\d+&quot;));</div><div class="line"><a name="l00930"></a><span class="lineno">  930</span>&#160;  ASSERT_THAT(Baz(), AllOf(Ge(5), Le(10)));</div><div class="line"><a name="l00931"></a><span class="lineno">  931</span>&#160;```</div><div class="line"><a name="l00932"></a><span class="lineno">  932</span>&#160;</div><div class="line"><a name="l00933"></a><span class="lineno">  933</span>&#160;which (as you can probably guess) executes `Foo()`, `Bar()`, and</div><div class="line"><a name="l00934"></a><span class="lineno">  934</span>&#160;`Baz()`, and verifies that:</div><div class="line"><a name="l00935"></a><span class="lineno">  935</span>&#160;</div><div class="line"><a name="l00936"></a><span class="lineno">  936</span>&#160;  * `Foo()` returns a string that starts with `&quot;Hello&quot;`.</div><div class="line"><a name="l00937"></a><span class="lineno">  937</span>&#160;  * `Bar()` returns a string that matches regular expression `&quot;Line \\d+&quot;`.</div><div class="line"><a name="l00938"></a><span class="lineno">  938</span>&#160;  * `Baz()` returns a number in the range [5, 10].</div><div class="line"><a name="l00939"></a><span class="lineno">  939</span>&#160;</div><div class="line"><a name="l00940"></a><span class="lineno">  940</span>&#160;The nice thing about these macros is that _they read like</div><div class="line"><a name="l00941"></a><span class="lineno">  941</span>&#160;English_. They generate informative messages too. For example, if the</div><div class="line"><a name="l00942"></a><span class="lineno">  942</span>&#160;first `EXPECT_THAT()` above fails, the message will be something like:</div><div class="line"><a name="l00943"></a><span class="lineno">  943</span>&#160;</div><div class="line"><a name="l00944"></a><span class="lineno">  944</span>&#160;```</div><div class="line"><a name="l00945"></a><span class="lineno">  945</span>&#160;Value of: Foo()</div><div class="line"><a name="l00946"></a><span class="lineno">  946</span>&#160;  Actual: &quot;Hi, world!&quot;</div><div class="line"><a name="l00947"></a><span class="lineno">  947</span>&#160;Expected: starts with &quot;Hello&quot;</div><div class="line"><a name="l00948"></a><span class="lineno">  948</span>&#160;```</div><div class="line"><a name="l00949"></a><span class="lineno">  949</span>&#160;</div><div class="line"><a name="l00950"></a><span class="lineno">  950</span>&#160;**Credit:** The idea of `(ASSERT|EXPECT)_THAT` was stolen from the</div><div class="line"><a name="l00951"></a><span class="lineno">  951</span>&#160;[Hamcrest](https://github.com/hamcrest/) project, which adds</div><div class="line"><a name="l00952"></a><span class="lineno">  952</span>&#160;`assertThat()` to JUnit.</div><div class="line"><a name="l00953"></a><span class="lineno">  953</span>&#160;</div><div class="line"><a name="l00954"></a><span class="lineno">  954</span>&#160;## Using Predicates as Matchers ##</div><div class="line"><a name="l00955"></a><span class="lineno">  955</span>&#160;</div><div class="line"><a name="l00956"></a><span class="lineno">  956</span>&#160;Google Mock provides a built-in set of matchers. In case you find them</div><div class="line"><a name="l00957"></a><span class="lineno">  957</span>&#160;lacking, you can use an arbitray unary predicate function or functor</div><div class="line"><a name="l00958"></a><span class="lineno">  958</span>&#160;as a matcher - as long as the predicate accepts a value of the type</div><div class="line"><a name="l00959"></a><span class="lineno">  959</span>&#160;you want. You do this by wrapping the predicate inside the `Truly()`</div><div class="line"><a name="l00960"></a><span class="lineno">  960</span>&#160;function, for example:</div><div class="line"><a name="l00961"></a><span class="lineno">  961</span>&#160;</div><div class="line"><a name="l00962"></a><span class="lineno">  962</span>&#160;```</div><div class="line"><a name="l00963"></a><span class="lineno">  963</span>&#160;using ::testing::Truly;</div><div class="line"><a name="l00964"></a><span class="lineno">  964</span>&#160;</div><div class="line"><a name="l00965"></a><span class="lineno">  965</span>&#160;int IsEven(int n) { return (n % 2) == 0 ? 1 : 0; }</div><div class="line"><a name="l00966"></a><span class="lineno">  966</span>&#160;...</div><div class="line"><a name="l00967"></a><span class="lineno">  967</span>&#160;</div><div class="line"><a name="l00968"></a><span class="lineno">  968</span>&#160;  // Bar() must be called with an even number.</div><div class="line"><a name="l00969"></a><span class="lineno">  969</span>&#160;  EXPECT_CALL(foo, Bar(Truly(IsEven)));</div><div class="line"><a name="l00970"></a><span class="lineno">  970</span>&#160;```</div><div class="line"><a name="l00971"></a><span class="lineno">  971</span>&#160;</div><div class="line"><a name="l00972"></a><span class="lineno">  972</span>&#160;Note that the predicate function / functor doesn&#39;t have to return</div><div class="line"><a name="l00973"></a><span class="lineno">  973</span>&#160;`bool`. It works as long as the return value can be used as the</div><div class="line"><a name="l00974"></a><span class="lineno">  974</span>&#160;condition in statement `if (condition) ...`.</div><div class="line"><a name="l00975"></a><span class="lineno">  975</span>&#160;</div><div class="line"><a name="l00976"></a><span class="lineno">  976</span>&#160;## Matching Arguments that Are Not Copyable ##</div><div class="line"><a name="l00977"></a><span class="lineno">  977</span>&#160;</div><div class="line"><a name="l00978"></a><span class="lineno">  978</span>&#160;When you do an `EXPECT_CALL(mock_obj, Foo(bar))`, Google Mock saves</div><div class="line"><a name="l00979"></a><span class="lineno">  979</span>&#160;away a copy of `bar`. When `Foo()` is called later, Google Mock</div><div class="line"><a name="l00980"></a><span class="lineno">  980</span>&#160;compares the argument to `Foo()` with the saved copy of `bar`. This</div><div class="line"><a name="l00981"></a><span class="lineno">  981</span>&#160;way, you don&#39;t need to worry about `bar` being modified or destroyed</div><div class="line"><a name="l00982"></a><span class="lineno">  982</span>&#160;after the `EXPECT_CALL()` is executed. The same is true when you use</div><div class="line"><a name="l00983"></a><span class="lineno">  983</span>&#160;matchers like `Eq(bar)`, `Le(bar)`, and so on.</div><div class="line"><a name="l00984"></a><span class="lineno">  984</span>&#160;</div><div class="line"><a name="l00985"></a><span class="lineno">  985</span>&#160;But what if `bar` cannot be copied (i.e. has no copy constructor)? You</div><div class="line"><a name="l00986"></a><span class="lineno">  986</span>&#160;could define your own matcher function and use it with `Truly()`, as</div><div class="line"><a name="l00987"></a><span class="lineno">  987</span>&#160;the previous couple of recipes have shown. Or, you may be able to get</div><div class="line"><a name="l00988"></a><span class="lineno">  988</span>&#160;away from it if you can guarantee that `bar` won&#39;t be changed after</div><div class="line"><a name="l00989"></a><span class="lineno">  989</span>&#160;the `EXPECT_CALL()` is executed. Just tell Google Mock that it should</div><div class="line"><a name="l00990"></a><span class="lineno">  990</span>&#160;save a reference to `bar`, instead of a copy of it. Here&#39;s how:</div><div class="line"><a name="l00991"></a><span class="lineno">  991</span>&#160;</div><div class="line"><a name="l00992"></a><span class="lineno">  992</span>&#160;```</div><div class="line"><a name="l00993"></a><span class="lineno">  993</span>&#160;using ::testing::Eq;</div><div class="line"><a name="l00994"></a><span class="lineno">  994</span>&#160;using ::testing::ByRef;</div><div class="line"><a name="l00995"></a><span class="lineno">  995</span>&#160;using ::testing::Lt;</div><div class="line"><a name="l00996"></a><span class="lineno">  996</span>&#160;...</div><div class="line"><a name="l00997"></a><span class="lineno">  997</span>&#160;  // Expects that Foo()&#39;s argument == bar.</div><div class="line"><a name="l00998"></a><span class="lineno">  998</span>&#160;  EXPECT_CALL(mock_obj, Foo(Eq(ByRef(bar))));</div><div class="line"><a name="l00999"></a><span class="lineno">  999</span>&#160;</div><div class="line"><a name="l01000"></a><span class="lineno"> 1000</span>&#160;  // Expects that Foo()&#39;s argument &lt; bar.</div><div class="line"><a name="l01001"></a><span class="lineno"> 1001</span>&#160;  EXPECT_CALL(mock_obj, Foo(Lt(ByRef(bar))));</div><div class="line"><a name="l01002"></a><span class="lineno"> 1002</span>&#160;```</div><div class="line"><a name="l01003"></a><span class="lineno"> 1003</span>&#160;</div><div class="line"><a name="l01004"></a><span class="lineno"> 1004</span>&#160;Remember: if you do this, don&#39;t change `bar` after the</div><div class="line"><a name="l01005"></a><span class="lineno"> 1005</span>&#160;`EXPECT_CALL()`, or the result is undefined.</div><div class="line"><a name="l01006"></a><span class="lineno"> 1006</span>&#160;</div><div class="line"><a name="l01007"></a><span class="lineno"> 1007</span>&#160;## Validating a Member of an Object ##</div><div class="line"><a name="l01008"></a><span class="lineno"> 1008</span>&#160;</div><div class="line"><a name="l01009"></a><span class="lineno"> 1009</span>&#160;Often a mock function takes a reference to object as an argument. When</div><div class="line"><a name="l01010"></a><span class="lineno"> 1010</span>&#160;matching the argument, you may not want to compare the entire object</div><div class="line"><a name="l01011"></a><span class="lineno"> 1011</span>&#160;against a fixed object, as that may be over-specification. Instead,</div><div class="line"><a name="l01012"></a><span class="lineno"> 1012</span>&#160;you may need to validate a certain member variable or the result of a</div><div class="line"><a name="l01013"></a><span class="lineno"> 1013</span>&#160;certain getter method of the object. You can do this with `Field()`</div><div class="line"><a name="l01014"></a><span class="lineno"> 1014</span>&#160;and `Property()`. More specifically,</div><div class="line"><a name="l01015"></a><span class="lineno"> 1015</span>&#160;</div><div class="line"><a name="l01016"></a><span class="lineno"> 1016</span>&#160;```</div><div class="line"><a name="l01017"></a><span class="lineno"> 1017</span>&#160;Field(&amp;Foo::bar, m)</div><div class="line"><a name="l01018"></a><span class="lineno"> 1018</span>&#160;```</div><div class="line"><a name="l01019"></a><span class="lineno"> 1019</span>&#160;</div><div class="line"><a name="l01020"></a><span class="lineno"> 1020</span>&#160;is a matcher that matches a `Foo` object whose `bar` member variable</div><div class="line"><a name="l01021"></a><span class="lineno"> 1021</span>&#160;satisfies matcher `m`.</div><div class="line"><a name="l01022"></a><span class="lineno"> 1022</span>&#160;</div><div class="line"><a name="l01023"></a><span class="lineno"> 1023</span>&#160;```</div><div class="line"><a name="l01024"></a><span class="lineno"> 1024</span>&#160;Property(&amp;Foo::baz, m)</div><div class="line"><a name="l01025"></a><span class="lineno"> 1025</span>&#160;```</div><div class="line"><a name="l01026"></a><span class="lineno"> 1026</span>&#160;</div><div class="line"><a name="l01027"></a><span class="lineno"> 1027</span>&#160;is a matcher that matches a `Foo` object whose `baz()` method returns</div><div class="line"><a name="l01028"></a><span class="lineno"> 1028</span>&#160;a value that satisfies matcher `m`.</div><div class="line"><a name="l01029"></a><span class="lineno"> 1029</span>&#160;</div><div class="line"><a name="l01030"></a><span class="lineno"> 1030</span>&#160;For example:</div><div class="line"><a name="l01031"></a><span class="lineno"> 1031</span>&#160;</div><div class="line"><a name="l01032"></a><span class="lineno"> 1032</span>&#160;&gt; | `Field(&amp;Foo::number, Ge(3))` | Matches `x` where `x.number &gt;= 3`. |</div><div class="line"><a name="l01033"></a><span class="lineno"> 1033</span>&#160;|:-----------------------------|:-----------------------------------|</div><div class="line"><a name="l01034"></a><span class="lineno"> 1034</span>&#160;&gt; | `Property(&amp;Foo::name, StartsWith(&quot;John &quot;))` | Matches `x` where `x.name()` starts with `&quot;John &quot;`. |</div><div class="line"><a name="l01035"></a><span class="lineno"> 1035</span>&#160;</div><div class="line"><a name="l01036"></a><span class="lineno"> 1036</span>&#160;Note that in `Property(&amp;Foo::baz, ...)`, method `baz()` must take no</div><div class="line"><a name="l01037"></a><span class="lineno"> 1037</span>&#160;argument and be declared as `const`.</div><div class="line"><a name="l01038"></a><span class="lineno"> 1038</span>&#160;</div><div class="line"><a name="l01039"></a><span class="lineno"> 1039</span>&#160;BTW, `Field()` and `Property()` can also match plain pointers to</div><div class="line"><a name="l01040"></a><span class="lineno"> 1040</span>&#160;objects. For instance,</div><div class="line"><a name="l01041"></a><span class="lineno"> 1041</span>&#160;</div><div class="line"><a name="l01042"></a><span class="lineno"> 1042</span>&#160;```</div><div class="line"><a name="l01043"></a><span class="lineno"> 1043</span>&#160;Field(&amp;Foo::number, Ge(3))</div><div class="line"><a name="l01044"></a><span class="lineno"> 1044</span>&#160;```</div><div class="line"><a name="l01045"></a><span class="lineno"> 1045</span>&#160;</div><div class="line"><a name="l01046"></a><span class="lineno"> 1046</span>&#160;matches a plain pointer `p` where `p-&gt;number &gt;= 3`. If `p` is `NULL`,</div><div class="line"><a name="l01047"></a><span class="lineno"> 1047</span>&#160;the match will always fail regardless of the inner matcher.</div><div class="line"><a name="l01048"></a><span class="lineno"> 1048</span>&#160;</div><div class="line"><a name="l01049"></a><span class="lineno"> 1049</span>&#160;What if you want to validate more than one members at the same time?</div><div class="line"><a name="l01050"></a><span class="lineno"> 1050</span>&#160;Remember that there is `AllOf()`.</div><div class="line"><a name="l01051"></a><span class="lineno"> 1051</span>&#160;</div><div class="line"><a name="l01052"></a><span class="lineno"> 1052</span>&#160;## Validating the Value Pointed to by a Pointer Argument ##</div><div class="line"><a name="l01053"></a><span class="lineno"> 1053</span>&#160;</div><div class="line"><a name="l01054"></a><span class="lineno"> 1054</span>&#160;C++ functions often take pointers as arguments. You can use matchers</div><div class="line"><a name="l01055"></a><span class="lineno"> 1055</span>&#160;like `IsNull()`, `NotNull()`, and other comparison matchers to match a</div><div class="line"><a name="l01056"></a><span class="lineno"> 1056</span>&#160;pointer, but what if you want to make sure the value _pointed to_ by</div><div class="line"><a name="l01057"></a><span class="lineno"> 1057</span>&#160;the pointer, instead of the pointer itself, has a certain property?</div><div class="line"><a name="l01058"></a><span class="lineno"> 1058</span>&#160;Well, you can use the `Pointee(m)` matcher.</div><div class="line"><a name="l01059"></a><span class="lineno"> 1059</span>&#160;</div><div class="line"><a name="l01060"></a><span class="lineno"> 1060</span>&#160;`Pointee(m)` matches a pointer iff `m` matches the value the pointer</div><div class="line"><a name="l01061"></a><span class="lineno"> 1061</span>&#160;points to. For example:</div><div class="line"><a name="l01062"></a><span class="lineno"> 1062</span>&#160;</div><div class="line"><a name="l01063"></a><span class="lineno"> 1063</span>&#160;```</div><div class="line"><a name="l01064"></a><span class="lineno"> 1064</span>&#160;using ::testing::Ge;</div><div class="line"><a name="l01065"></a><span class="lineno"> 1065</span>&#160;using ::testing::Pointee;</div><div class="line"><a name="l01066"></a><span class="lineno"> 1066</span>&#160;...</div><div class="line"><a name="l01067"></a><span class="lineno"> 1067</span>&#160;  EXPECT_CALL(foo, Bar(Pointee(Ge(3))));</div><div class="line"><a name="l01068"></a><span class="lineno"> 1068</span>&#160;```</div><div class="line"><a name="l01069"></a><span class="lineno"> 1069</span>&#160;</div><div class="line"><a name="l01070"></a><span class="lineno"> 1070</span>&#160;expects `foo.Bar()` to be called with a pointer that points to a value</div><div class="line"><a name="l01071"></a><span class="lineno"> 1071</span>&#160;greater than or equal to 3.</div><div class="line"><a name="l01072"></a><span class="lineno"> 1072</span>&#160;</div><div class="line"><a name="l01073"></a><span class="lineno"> 1073</span>&#160;One nice thing about `Pointee()` is that it treats a `NULL` pointer as</div><div class="line"><a name="l01074"></a><span class="lineno"> 1074</span>&#160;a match failure, so you can write `Pointee(m)` instead of</div><div class="line"><a name="l01075"></a><span class="lineno"> 1075</span>&#160;</div><div class="line"><a name="l01076"></a><span class="lineno"> 1076</span>&#160;```</div><div class="line"><a name="l01077"></a><span class="lineno"> 1077</span>&#160;  AllOf(NotNull(), Pointee(m))</div><div class="line"><a name="l01078"></a><span class="lineno"> 1078</span>&#160;```</div><div class="line"><a name="l01079"></a><span class="lineno"> 1079</span>&#160;</div><div class="line"><a name="l01080"></a><span class="lineno"> 1080</span>&#160;without worrying that a `NULL` pointer will crash your test.</div><div class="line"><a name="l01081"></a><span class="lineno"> 1081</span>&#160;</div><div class="line"><a name="l01082"></a><span class="lineno"> 1082</span>&#160;Also, did we tell you that `Pointee()` works with both raw pointers</div><div class="line"><a name="l01083"></a><span class="lineno"> 1083</span>&#160;**and** smart pointers (`linked_ptr`, `shared_ptr`, `scoped_ptr`, and</div><div class="line"><a name="l01084"></a><span class="lineno"> 1084</span>&#160;etc)?</div><div class="line"><a name="l01085"></a><span class="lineno"> 1085</span>&#160;</div><div class="line"><a name="l01086"></a><span class="lineno"> 1086</span>&#160;What if you have a pointer to pointer? You guessed it - you can use</div><div class="line"><a name="l01087"></a><span class="lineno"> 1087</span>&#160;nested `Pointee()` to probe deeper inside the value. For example,</div><div class="line"><a name="l01088"></a><span class="lineno"> 1088</span>&#160;`Pointee(Pointee(Lt(3)))` matches a pointer that points to a pointer</div><div class="line"><a name="l01089"></a><span class="lineno"> 1089</span>&#160;that points to a number less than 3 (what a mouthful...).</div><div class="line"><a name="l01090"></a><span class="lineno"> 1090</span>&#160;</div><div class="line"><a name="l01091"></a><span class="lineno"> 1091</span>&#160;## Testing a Certain Property of an Object ##</div><div class="line"><a name="l01092"></a><span class="lineno"> 1092</span>&#160;</div><div class="line"><a name="l01093"></a><span class="lineno"> 1093</span>&#160;Sometimes you want to specify that an object argument has a certain</div><div class="line"><a name="l01094"></a><span class="lineno"> 1094</span>&#160;property, but there is no existing matcher that does this. If you want</div><div class="line"><a name="l01095"></a><span class="lineno"> 1095</span>&#160;good error messages, you should define a matcher. If you want to do it</div><div class="line"><a name="l01096"></a><span class="lineno"> 1096</span>&#160;quick and dirty, you could get away with writing an ordinary function.</div><div class="line"><a name="l01097"></a><span class="lineno"> 1097</span>&#160;</div><div class="line"><a name="l01098"></a><span class="lineno"> 1098</span>&#160;Let&#39;s say you have a mock function that takes an object of type `Foo`,</div><div class="line"><a name="l01099"></a><span class="lineno"> 1099</span>&#160;which has an `int bar()` method and an `int baz()` method, and you</div><div class="line"><a name="l01100"></a><span class="lineno"> 1100</span>&#160;want to constrain that the argument&#39;s `bar()` value plus its `baz()`</div><div class="line"><a name="l01101"></a><span class="lineno"> 1101</span>&#160;value is a given number. Here&#39;s how you can define a matcher to do it:</div><div class="line"><a name="l01102"></a><span class="lineno"> 1102</span>&#160;</div><div class="line"><a name="l01103"></a><span class="lineno"> 1103</span>&#160;```</div><div class="line"><a name="l01104"></a><span class="lineno"> 1104</span>&#160;using ::testing::MatcherInterface;</div><div class="line"><a name="l01105"></a><span class="lineno"> 1105</span>&#160;using ::testing::MatchResultListener;</div><div class="line"><a name="l01106"></a><span class="lineno"> 1106</span>&#160;</div><div class="line"><a name="l01107"></a><span class="lineno"> 1107</span>&#160;class BarPlusBazEqMatcher : public MatcherInterface&lt;const Foo&amp;&gt; {</div><div class="line"><a name="l01108"></a><span class="lineno"> 1108</span>&#160; public:</div><div class="line"><a name="l01109"></a><span class="lineno"> 1109</span>&#160;  explicit BarPlusBazEqMatcher(int expected_sum)</div><div class="line"><a name="l01110"></a><span class="lineno"> 1110</span>&#160;      : expected_sum_(expected_sum) {}</div><div class="line"><a name="l01111"></a><span class="lineno"> 1111</span>&#160;</div><div class="line"><a name="l01112"></a><span class="lineno"> 1112</span>&#160;  virtual bool MatchAndExplain(const Foo&amp; foo,</div><div class="line"><a name="l01113"></a><span class="lineno"> 1113</span>&#160;                               MatchResultListener* listener) const {</div><div class="line"><a name="l01114"></a><span class="lineno"> 1114</span>&#160;    return (foo.bar() + foo.baz()) == expected_sum_;</div><div class="line"><a name="l01115"></a><span class="lineno"> 1115</span>&#160;  }</div><div class="line"><a name="l01116"></a><span class="lineno"> 1116</span>&#160;</div><div class="line"><a name="l01117"></a><span class="lineno"> 1117</span>&#160;  virtual void DescribeTo(::std::ostream* os) const {</div><div class="line"><a name="l01118"></a><span class="lineno"> 1118</span>&#160;    *os &lt;&lt; &quot;bar() + baz() equals &quot; &lt;&lt; expected_sum_;</div><div class="line"><a name="l01119"></a><span class="lineno"> 1119</span>&#160;  }</div><div class="line"><a name="l01120"></a><span class="lineno"> 1120</span>&#160;</div><div class="line"><a name="l01121"></a><span class="lineno"> 1121</span>&#160;  virtual void DescribeNegationTo(::std::ostream* os) const {</div><div class="line"><a name="l01122"></a><span class="lineno"> 1122</span>&#160;    *os &lt;&lt; &quot;bar() + baz() does not equal &quot; &lt;&lt; expected_sum_;</div><div class="line"><a name="l01123"></a><span class="lineno"> 1123</span>&#160;  }</div><div class="line"><a name="l01124"></a><span class="lineno"> 1124</span>&#160; private:</div><div class="line"><a name="l01125"></a><span class="lineno"> 1125</span>&#160;  const int expected_sum_;</div><div class="line"><a name="l01126"></a><span class="lineno"> 1126</span>&#160;};</div><div class="line"><a name="l01127"></a><span class="lineno"> 1127</span>&#160;</div><div class="line"><a name="l01128"></a><span class="lineno"> 1128</span>&#160;inline Matcher&lt;const Foo&amp;&gt; BarPlusBazEq(int expected_sum) {</div><div class="line"><a name="l01129"></a><span class="lineno"> 1129</span>&#160;  return MakeMatcher(new BarPlusBazEqMatcher(expected_sum));</div><div class="line"><a name="l01130"></a><span class="lineno"> 1130</span>&#160;}</div><div class="line"><a name="l01131"></a><span class="lineno"> 1131</span>&#160;</div><div class="line"><a name="l01132"></a><span class="lineno"> 1132</span>&#160;...</div><div class="line"><a name="l01133"></a><span class="lineno"> 1133</span>&#160;</div><div class="line"><a name="l01134"></a><span class="lineno"> 1134</span>&#160;  EXPECT_CALL(..., DoThis(BarPlusBazEq(5)))...;</div><div class="line"><a name="l01135"></a><span class="lineno"> 1135</span>&#160;```</div><div class="line"><a name="l01136"></a><span class="lineno"> 1136</span>&#160;</div><div class="line"><a name="l01137"></a><span class="lineno"> 1137</span>&#160;## Matching Containers ##</div><div class="line"><a name="l01138"></a><span class="lineno"> 1138</span>&#160;</div><div class="line"><a name="l01139"></a><span class="lineno"> 1139</span>&#160;Sometimes an STL container (e.g. list, vector, map, ...) is passed to</div><div class="line"><a name="l01140"></a><span class="lineno"> 1140</span>&#160;a mock function and you may want to validate it. Since most STL</div><div class="line"><a name="l01141"></a><span class="lineno"> 1141</span>&#160;containers support the `==` operator, you can write</div><div class="line"><a name="l01142"></a><span class="lineno"> 1142</span>&#160;`Eq(expected_container)` or simply `expected_container` to match a</div><div class="line"><a name="l01143"></a><span class="lineno"> 1143</span>&#160;container exactly.</div><div class="line"><a name="l01144"></a><span class="lineno"> 1144</span>&#160;</div><div class="line"><a name="l01145"></a><span class="lineno"> 1145</span>&#160;Sometimes, though, you may want to be more flexible (for example, the</div><div class="line"><a name="l01146"></a><span class="lineno"> 1146</span>&#160;first element must be an exact match, but the second element can be</div><div class="line"><a name="l01147"></a><span class="lineno"> 1147</span>&#160;any positive number, and so on). Also, containers used in tests often</div><div class="line"><a name="l01148"></a><span class="lineno"> 1148</span>&#160;have a small number of elements, and having to define the expected</div><div class="line"><a name="l01149"></a><span class="lineno"> 1149</span>&#160;container out-of-line is a bit of a hassle.</div><div class="line"><a name="l01150"></a><span class="lineno"> 1150</span>&#160;</div><div class="line"><a name="l01151"></a><span class="lineno"> 1151</span>&#160;You can use the `ElementsAre()` or `UnorderedElementsAre()` matcher in</div><div class="line"><a name="l01152"></a><span class="lineno"> 1152</span>&#160;such cases:</div><div class="line"><a name="l01153"></a><span class="lineno"> 1153</span>&#160;</div><div class="line"><a name="l01154"></a><span class="lineno"> 1154</span>&#160;```</div><div class="line"><a name="l01155"></a><span class="lineno"> 1155</span>&#160;using ::testing::_;</div><div class="line"><a name="l01156"></a><span class="lineno"> 1156</span>&#160;using ::testing::ElementsAre;</div><div class="line"><a name="l01157"></a><span class="lineno"> 1157</span>&#160;using ::testing::Gt;</div><div class="line"><a name="l01158"></a><span class="lineno"> 1158</span>&#160;...</div><div class="line"><a name="l01159"></a><span class="lineno"> 1159</span>&#160;</div><div class="line"><a name="l01160"></a><span class="lineno"> 1160</span>&#160;  MOCK_METHOD1(Foo, void(const vector&lt;int&gt;&amp; numbers));</div><div class="line"><a name="l01161"></a><span class="lineno"> 1161</span>&#160;...</div><div class="line"><a name="l01162"></a><span class="lineno"> 1162</span>&#160;</div><div class="line"><a name="l01163"></a><span class="lineno"> 1163</span>&#160;  EXPECT_CALL(mock, Foo(ElementsAre(1, Gt(0), _, 5)));</div><div class="line"><a name="l01164"></a><span class="lineno"> 1164</span>&#160;```</div><div class="line"><a name="l01165"></a><span class="lineno"> 1165</span>&#160;</div><div class="line"><a name="l01166"></a><span class="lineno"> 1166</span>&#160;The above matcher says that the container must have 4 elements, which</div><div class="line"><a name="l01167"></a><span class="lineno"> 1167</span>&#160;must be 1, greater than 0, anything, and 5 respectively.</div><div class="line"><a name="l01168"></a><span class="lineno"> 1168</span>&#160;</div><div class="line"><a name="l01169"></a><span class="lineno"> 1169</span>&#160;If you instead write:</div><div class="line"><a name="l01170"></a><span class="lineno"> 1170</span>&#160;</div><div class="line"><a name="l01171"></a><span class="lineno"> 1171</span>&#160;```</div><div class="line"><a name="l01172"></a><span class="lineno"> 1172</span>&#160;using ::testing::_;</div><div class="line"><a name="l01173"></a><span class="lineno"> 1173</span>&#160;using ::testing::Gt;</div><div class="line"><a name="l01174"></a><span class="lineno"> 1174</span>&#160;using ::testing::UnorderedElementsAre;</div><div class="line"><a name="l01175"></a><span class="lineno"> 1175</span>&#160;...</div><div class="line"><a name="l01176"></a><span class="lineno"> 1176</span>&#160;</div><div class="line"><a name="l01177"></a><span class="lineno"> 1177</span>&#160;  MOCK_METHOD1(Foo, void(const vector&lt;int&gt;&amp; numbers));</div><div class="line"><a name="l01178"></a><span class="lineno"> 1178</span>&#160;...</div><div class="line"><a name="l01179"></a><span class="lineno"> 1179</span>&#160;</div><div class="line"><a name="l01180"></a><span class="lineno"> 1180</span>&#160;  EXPECT_CALL(mock, Foo(UnorderedElementsAre(1, Gt(0), _, 5)));</div><div class="line"><a name="l01181"></a><span class="lineno"> 1181</span>&#160;```</div><div class="line"><a name="l01182"></a><span class="lineno"> 1182</span>&#160;</div><div class="line"><a name="l01183"></a><span class="lineno"> 1183</span>&#160;It means that the container must have 4 elements, which under some</div><div class="line"><a name="l01184"></a><span class="lineno"> 1184</span>&#160;permutation must be 1, greater than 0, anything, and 5 respectively.</div><div class="line"><a name="l01185"></a><span class="lineno"> 1185</span>&#160;</div><div class="line"><a name="l01186"></a><span class="lineno"> 1186</span>&#160;`ElementsAre()` and `UnorderedElementsAre()` are overloaded to take 0</div><div class="line"><a name="l01187"></a><span class="lineno"> 1187</span>&#160;to 10 arguments. If more are needed, you can place them in a C-style</div><div class="line"><a name="l01188"></a><span class="lineno"> 1188</span>&#160;array and use `ElementsAreArray()` or `UnorderedElementsAreArray()`</div><div class="line"><a name="l01189"></a><span class="lineno"> 1189</span>&#160;instead:</div><div class="line"><a name="l01190"></a><span class="lineno"> 1190</span>&#160;</div><div class="line"><a name="l01191"></a><span class="lineno"> 1191</span>&#160;```</div><div class="line"><a name="l01192"></a><span class="lineno"> 1192</span>&#160;using ::testing::ElementsAreArray;</div><div class="line"><a name="l01193"></a><span class="lineno"> 1193</span>&#160;...</div><div class="line"><a name="l01194"></a><span class="lineno"> 1194</span>&#160;</div><div class="line"><a name="l01195"></a><span class="lineno"> 1195</span>&#160;  // ElementsAreArray accepts an array of element values.</div><div class="line"><a name="l01196"></a><span class="lineno"> 1196</span>&#160;  const int expected_vector1[] = { 1, 5, 2, 4, ... };</div><div class="line"><a name="l01197"></a><span class="lineno"> 1197</span>&#160;  EXPECT_CALL(mock, Foo(ElementsAreArray(expected_vector1)));</div><div class="line"><a name="l01198"></a><span class="lineno"> 1198</span>&#160;</div><div class="line"><a name="l01199"></a><span class="lineno"> 1199</span>&#160;  // Or, an array of element matchers.</div><div class="line"><a name="l01200"></a><span class="lineno"> 1200</span>&#160;  Matcher&lt;int&gt; expected_vector2 = { 1, Gt(2), _, 3, ... };</div><div class="line"><a name="l01201"></a><span class="lineno"> 1201</span>&#160;  EXPECT_CALL(mock, Foo(ElementsAreArray(expected_vector2)));</div><div class="line"><a name="l01202"></a><span class="lineno"> 1202</span>&#160;```</div><div class="line"><a name="l01203"></a><span class="lineno"> 1203</span>&#160;</div><div class="line"><a name="l01204"></a><span class="lineno"> 1204</span>&#160;In case the array needs to be dynamically created (and therefore the</div><div class="line"><a name="l01205"></a><span class="lineno"> 1205</span>&#160;array size cannot be inferred by the compiler), you can give</div><div class="line"><a name="l01206"></a><span class="lineno"> 1206</span>&#160;`ElementsAreArray()` an additional argument to specify the array size:</div><div class="line"><a name="l01207"></a><span class="lineno"> 1207</span>&#160;</div><div class="line"><a name="l01208"></a><span class="lineno"> 1208</span>&#160;```</div><div class="line"><a name="l01209"></a><span class="lineno"> 1209</span>&#160;using ::testing::ElementsAreArray;</div><div class="line"><a name="l01210"></a><span class="lineno"> 1210</span>&#160;...</div><div class="line"><a name="l01211"></a><span class="lineno"> 1211</span>&#160;  int* const expected_vector3 = new int[count];</div><div class="line"><a name="l01212"></a><span class="lineno"> 1212</span>&#160;  ... fill expected_vector3 with values ...</div><div class="line"><a name="l01213"></a><span class="lineno"> 1213</span>&#160;  EXPECT_CALL(mock, Foo(ElementsAreArray(expected_vector3, count)));</div><div class="line"><a name="l01214"></a><span class="lineno"> 1214</span>&#160;```</div><div class="line"><a name="l01215"></a><span class="lineno"> 1215</span>&#160;</div><div class="line"><a name="l01216"></a><span class="lineno"> 1216</span>&#160;**Tips:**</div><div class="line"><a name="l01217"></a><span class="lineno"> 1217</span>&#160;</div><div class="line"><a name="l01218"></a><span class="lineno"> 1218</span>&#160;  * `ElementsAre*()` can be used to match _any_ container that implements the STL iterator pattern (i.e. it has a `const_iterator` type and supports `begin()/end()`), not just the ones defined in STL. It will even work with container types yet to be written - as long as they follows the above pattern.</div><div class="line"><a name="l01219"></a><span class="lineno"> 1219</span>&#160;  * You can use nested `ElementsAre*()` to match nested (multi-dimensional) containers.</div><div class="line"><a name="l01220"></a><span class="lineno"> 1220</span>&#160;  * If the container is passed by pointer instead of by reference, just write `Pointee(ElementsAre*(...))`.</div><div class="line"><a name="l01221"></a><span class="lineno"> 1221</span>&#160;  * The order of elements _matters_ for `ElementsAre*()`. Therefore don&#39;t use it with containers whose element order is undefined (e.g. `hash_map`).</div><div class="line"><a name="l01222"></a><span class="lineno"> 1222</span>&#160;</div><div class="line"><a name="l01223"></a><span class="lineno"> 1223</span>&#160;## Sharing Matchers ##</div><div class="line"><a name="l01224"></a><span class="lineno"> 1224</span>&#160;</div><div class="line"><a name="l01225"></a><span class="lineno"> 1225</span>&#160;Under the hood, a Google Mock matcher object consists of a pointer to</div><div class="line"><a name="l01226"></a><span class="lineno"> 1226</span>&#160;a ref-counted implementation object. Copying matchers is allowed and</div><div class="line"><a name="l01227"></a><span class="lineno"> 1227</span>&#160;very efficient, as only the pointer is copied. When the last matcher</div><div class="line"><a name="l01228"></a><span class="lineno"> 1228</span>&#160;that references the implementation object dies, the implementation</div><div class="line"><a name="l01229"></a><span class="lineno"> 1229</span>&#160;object will be deleted.</div><div class="line"><a name="l01230"></a><span class="lineno"> 1230</span>&#160;</div><div class="line"><a name="l01231"></a><span class="lineno"> 1231</span>&#160;Therefore, if you have some complex matcher that you want to use again</div><div class="line"><a name="l01232"></a><span class="lineno"> 1232</span>&#160;and again, there is no need to build it everytime. Just assign it to a</div><div class="line"><a name="l01233"></a><span class="lineno"> 1233</span>&#160;matcher variable and use that variable repeatedly! For example,</div><div class="line"><a name="l01234"></a><span class="lineno"> 1234</span>&#160;</div><div class="line"><a name="l01235"></a><span class="lineno"> 1235</span>&#160;```</div><div class="line"><a name="l01236"></a><span class="lineno"> 1236</span>&#160;  Matcher&lt;int&gt; in_range = AllOf(Gt(5), Le(10));</div><div class="line"><a name="l01237"></a><span class="lineno"> 1237</span>&#160;  ... use in_range as a matcher in multiple EXPECT_CALLs ...</div><div class="line"><a name="l01238"></a><span class="lineno"> 1238</span>&#160;```</div><div class="line"><a name="l01239"></a><span class="lineno"> 1239</span>&#160;</div><div class="line"><a name="l01240"></a><span class="lineno"> 1240</span>&#160;# Setting Expectations #</div><div class="line"><a name="l01241"></a><span class="lineno"> 1241</span>&#160;</div><div class="line"><a name="l01242"></a><span class="lineno"> 1242</span>&#160;## Knowing When to Expect ##</div><div class="line"><a name="l01243"></a><span class="lineno"> 1243</span>&#160;</div><div class="line"><a name="l01244"></a><span class="lineno"> 1244</span>&#160;`ON_CALL` is likely the single most under-utilized construct in Google Mock.</div><div class="line"><a name="l01245"></a><span class="lineno"> 1245</span>&#160;</div><div class="line"><a name="l01246"></a><span class="lineno"> 1246</span>&#160;There are basically two constructs for defining the behavior of a mock object: `ON_CALL` and `EXPECT_CALL`. The difference? `ON_CALL` defines what happens when a mock method is called, but _doesn&#39;t imply any expectation on the method being called._ `EXPECT_CALL` not only defines the behavior, but also sets an expectation that _the method will be called with the given arguments, for the given number of times_ (and _in the given order_ when you specify the order too).</div><div class="line"><a name="l01247"></a><span class="lineno"> 1247</span>&#160;</div><div class="line"><a name="l01248"></a><span class="lineno"> 1248</span>&#160;Since `EXPECT_CALL` does more, isn&#39;t it better than `ON_CALL`? Not really. Every `EXPECT_CALL` adds a constraint on the behavior of the code under test. Having more constraints than necessary is _baaad_ - even worse than not having enough constraints.</div><div class="line"><a name="l01249"></a><span class="lineno"> 1249</span>&#160;</div><div class="line"><a name="l01250"></a><span class="lineno"> 1250</span>&#160;This may be counter-intuitive. How could tests that verify more be worse than tests that verify less? Isn&#39;t verification the whole point of tests?</div><div class="line"><a name="l01251"></a><span class="lineno"> 1251</span>&#160;</div><div class="line"><a name="l01252"></a><span class="lineno"> 1252</span>&#160;The answer, lies in _what_ a test should verify. **A good test verifies the contract of the code.** If a test over-specifies, it doesn&#39;t leave enough freedom to the implementation. As a result, changing the implementation without breaking the contract (e.g. refactoring and optimization), which should be perfectly fine to do, can break such tests. Then you have to spend time fixing them, only to see them broken again the next time the implementation is changed.</div><div class="line"><a name="l01253"></a><span class="lineno"> 1253</span>&#160;</div><div class="line"><a name="l01254"></a><span class="lineno"> 1254</span>&#160;Keep in mind that one doesn&#39;t have to verify more than one property in one test. In fact, **it&#39;s a good style to verify only one thing in one test.** If you do that, a bug will likely break only one or two tests instead of dozens (which case would you rather debug?). If you are also in the habit of giving tests descriptive names that tell what they verify, you can often easily guess what&#39;s wrong just from the test log itself.</div><div class="line"><a name="l01255"></a><span class="lineno"> 1255</span>&#160;</div><div class="line"><a name="l01256"></a><span class="lineno"> 1256</span>&#160;So use `ON_CALL` by default, and only use `EXPECT_CALL` when you actually intend to verify that the call is made. For example, you may have a bunch of `ON_CALL`s in your test fixture to set the common mock behavior shared by all tests in the same group, and write (scarcely) different `EXPECT_CALL`s in different `TEST_F`s to verify different aspects of the code&#39;s behavior. Compared with the style where each `TEST` has many `EXPECT_CALL`s, this leads to tests that are more resilient to implementational changes (and thus less likely to require maintenance) and makes the intent of the tests more obvious (so they are easier to maintain when you do need to maintain them).</div><div class="line"><a name="l01257"></a><span class="lineno"> 1257</span>&#160;</div><div class="line"><a name="l01258"></a><span class="lineno"> 1258</span>&#160;If you are bothered by the &quot;Uninteresting mock function call&quot; message printed when a mock method without an `EXPECT_CALL` is called, you may use a `NiceMock` instead to suppress all such messages for the mock object, or suppress the message for specific methods by adding `EXPECT_CALL(...).Times(AnyNumber())`. DO NOT suppress it by blindly adding an `EXPECT_CALL(...)`, or you&#39;ll have a test that&#39;s a pain to maintain.</div><div class="line"><a name="l01259"></a><span class="lineno"> 1259</span>&#160;</div><div class="line"><a name="l01260"></a><span class="lineno"> 1260</span>&#160;## Ignoring Uninteresting Calls ##</div><div class="line"><a name="l01261"></a><span class="lineno"> 1261</span>&#160;</div><div class="line"><a name="l01262"></a><span class="lineno"> 1262</span>&#160;If you are not interested in how a mock method is called, just don&#39;t</div><div class="line"><a name="l01263"></a><span class="lineno"> 1263</span>&#160;say anything about it. In this case, if the method is ever called,</div><div class="line"><a name="l01264"></a><span class="lineno"> 1264</span>&#160;Google Mock will perform its default action to allow the test program</div><div class="line"><a name="l01265"></a><span class="lineno"> 1265</span>&#160;to continue. If you are not happy with the default action taken by</div><div class="line"><a name="l01266"></a><span class="lineno"> 1266</span>&#160;Google Mock, you can override it using `DefaultValue&lt;T&gt;::Set()`</div><div class="line"><a name="l01267"></a><span class="lineno"> 1267</span>&#160;(described later in this document) or `ON_CALL()`.</div><div class="line"><a name="l01268"></a><span class="lineno"> 1268</span>&#160;</div><div class="line"><a name="l01269"></a><span class="lineno"> 1269</span>&#160;Please note that once you expressed interest in a particular mock</div><div class="line"><a name="l01270"></a><span class="lineno"> 1270</span>&#160;method (via `EXPECT_CALL()`), all invocations to it must match some</div><div class="line"><a name="l01271"></a><span class="lineno"> 1271</span>&#160;expectation. If this function is called but the arguments don&#39;t match</div><div class="line"><a name="l01272"></a><span class="lineno"> 1272</span>&#160;any `EXPECT_CALL()` statement, it will be an error.</div><div class="line"><a name="l01273"></a><span class="lineno"> 1273</span>&#160;</div><div class="line"><a name="l01274"></a><span class="lineno"> 1274</span>&#160;## Disallowing Unexpected Calls ##</div><div class="line"><a name="l01275"></a><span class="lineno"> 1275</span>&#160;</div><div class="line"><a name="l01276"></a><span class="lineno"> 1276</span>&#160;If a mock method shouldn&#39;t be called at all, explicitly say so:</div><div class="line"><a name="l01277"></a><span class="lineno"> 1277</span>&#160;</div><div class="line"><a name="l01278"></a><span class="lineno"> 1278</span>&#160;```</div><div class="line"><a name="l01279"></a><span class="lineno"> 1279</span>&#160;using ::testing::_;</div><div class="line"><a name="l01280"></a><span class="lineno"> 1280</span>&#160;...</div><div class="line"><a name="l01281"></a><span class="lineno"> 1281</span>&#160;  EXPECT_CALL(foo, Bar(_))</div><div class="line"><a name="l01282"></a><span class="lineno"> 1282</span>&#160;      .Times(0);</div><div class="line"><a name="l01283"></a><span class="lineno"> 1283</span>&#160;```</div><div class="line"><a name="l01284"></a><span class="lineno"> 1284</span>&#160;</div><div class="line"><a name="l01285"></a><span class="lineno"> 1285</span>&#160;If some calls to the method are allowed, but the rest are not, just</div><div class="line"><a name="l01286"></a><span class="lineno"> 1286</span>&#160;list all the expected calls:</div><div class="line"><a name="l01287"></a><span class="lineno"> 1287</span>&#160;</div><div class="line"><a name="l01288"></a><span class="lineno"> 1288</span>&#160;```</div><div class="line"><a name="l01289"></a><span class="lineno"> 1289</span>&#160;using ::testing::AnyNumber;</div><div class="line"><a name="l01290"></a><span class="lineno"> 1290</span>&#160;using ::testing::Gt;</div><div class="line"><a name="l01291"></a><span class="lineno"> 1291</span>&#160;...</div><div class="line"><a name="l01292"></a><span class="lineno"> 1292</span>&#160;  EXPECT_CALL(foo, Bar(5));</div><div class="line"><a name="l01293"></a><span class="lineno"> 1293</span>&#160;  EXPECT_CALL(foo, Bar(Gt(10)))</div><div class="line"><a name="l01294"></a><span class="lineno"> 1294</span>&#160;      .Times(AnyNumber());</div><div class="line"><a name="l01295"></a><span class="lineno"> 1295</span>&#160;```</div><div class="line"><a name="l01296"></a><span class="lineno"> 1296</span>&#160;</div><div class="line"><a name="l01297"></a><span class="lineno"> 1297</span>&#160;A call to `foo.Bar()` that doesn&#39;t match any of the `EXPECT_CALL()`</div><div class="line"><a name="l01298"></a><span class="lineno"> 1298</span>&#160;statements will be an error.</div><div class="line"><a name="l01299"></a><span class="lineno"> 1299</span>&#160;</div><div class="line"><a name="l01300"></a><span class="lineno"> 1300</span>&#160;## Understanding Uninteresting vs Unexpected Calls ##</div><div class="line"><a name="l01301"></a><span class="lineno"> 1301</span>&#160;</div><div class="line"><a name="l01302"></a><span class="lineno"> 1302</span>&#160;_Uninteresting_ calls and _unexpected_ calls are different concepts in Google Mock. _Very_ different.</div><div class="line"><a name="l01303"></a><span class="lineno"> 1303</span>&#160;</div><div class="line"><a name="l01304"></a><span class="lineno"> 1304</span>&#160;A call `x.Y(...)` is **uninteresting** if there&#39;s _not even a single_ `EXPECT_CALL(x, Y(...))` set. In other words, the test isn&#39;t interested in the `x.Y()` method at all, as evident in that the test doesn&#39;t care to say anything about it.</div><div class="line"><a name="l01305"></a><span class="lineno"> 1305</span>&#160;</div><div class="line"><a name="l01306"></a><span class="lineno"> 1306</span>&#160;A call `x.Y(...)` is **unexpected** if there are some `EXPECT_CALL(x, Y(...))s` set, but none of them matches the call. Put another way, the test is interested in the `x.Y()` method (therefore it _explicitly_ sets some `EXPECT_CALL` to verify how it&#39;s called); however, the verification fails as the test doesn&#39;t expect this particular call to happen.</div><div class="line"><a name="l01307"></a><span class="lineno"> 1307</span>&#160;</div><div class="line"><a name="l01308"></a><span class="lineno"> 1308</span>&#160;**An unexpected call is always an error,** as the code under test doesn&#39;t behave the way the test expects it to behave.</div><div class="line"><a name="l01309"></a><span class="lineno"> 1309</span>&#160;</div><div class="line"><a name="l01310"></a><span class="lineno"> 1310</span>&#160;**By default, an uninteresting call is not an error,** as it violates no constraint specified by the test. (Google Mock&#39;s philosophy is that saying nothing means there is no constraint.) However, it leads to a warning, as it _might_ indicate a problem (e.g. the test author might have forgotten to specify a constraint).</div><div class="line"><a name="l01311"></a><span class="lineno"> 1311</span>&#160;</div><div class="line"><a name="l01312"></a><span class="lineno"> 1312</span>&#160;In Google Mock, `NiceMock` and `StrictMock` can be used to make a mock class &quot;nice&quot; or &quot;strict&quot;. How does this affect uninteresting calls and unexpected calls?</div><div class="line"><a name="l01313"></a><span class="lineno"> 1313</span>&#160;</div><div class="line"><a name="l01314"></a><span class="lineno"> 1314</span>&#160;A **nice mock** suppresses uninteresting call warnings. It is less chatty than the default mock, but otherwise is the same. If a test fails with a default mock, it will also fail using a nice mock instead. And vice versa. Don&#39;t expect making a mock nice to change the test&#39;s result.</div><div class="line"><a name="l01315"></a><span class="lineno"> 1315</span>&#160;</div><div class="line"><a name="l01316"></a><span class="lineno"> 1316</span>&#160;A **strict mock** turns uninteresting call warnings into errors. So making a mock strict may change the test&#39;s result.</div><div class="line"><a name="l01317"></a><span class="lineno"> 1317</span>&#160;</div><div class="line"><a name="l01318"></a><span class="lineno"> 1318</span>&#160;Let&#39;s look at an example:</div><div class="line"><a name="l01319"></a><span class="lineno"> 1319</span>&#160;</div><div class="line"><a name="l01320"></a><span class="lineno"> 1320</span>&#160;```</div><div class="line"><a name="l01321"></a><span class="lineno"> 1321</span>&#160;TEST(...) {</div><div class="line"><a name="l01322"></a><span class="lineno"> 1322</span>&#160;  NiceMock&lt;MockDomainRegistry&gt; mock_registry;</div><div class="line"><a name="l01323"></a><span class="lineno"> 1323</span>&#160;  EXPECT_CALL(mock_registry, GetDomainOwner(&quot;google.com&quot;))</div><div class="line"><a name="l01324"></a><span class="lineno"> 1324</span>&#160;          .WillRepeatedly(Return(&quot;Larry Page&quot;));</div><div class="line"><a name="l01325"></a><span class="lineno"> 1325</span>&#160;</div><div class="line"><a name="l01326"></a><span class="lineno"> 1326</span>&#160;  // Use mock_registry in code under test.</div><div class="line"><a name="l01327"></a><span class="lineno"> 1327</span>&#160;  ... &amp;mock_registry ...</div><div class="line"><a name="l01328"></a><span class="lineno"> 1328</span>&#160;}</div><div class="line"><a name="l01329"></a><span class="lineno"> 1329</span>&#160;```</div><div class="line"><a name="l01330"></a><span class="lineno"> 1330</span>&#160;</div><div class="line"><a name="l01331"></a><span class="lineno"> 1331</span>&#160;The sole `EXPECT_CALL` here says that all calls to `GetDomainOwner()` must have `&quot;google.com&quot;` as the argument. If `GetDomainOwner(&quot;yahoo.com&quot;)` is called, it will be an unexpected call, and thus an error. Having a nice mock doesn&#39;t change the severity of an unexpected call.</div><div class="line"><a name="l01332"></a><span class="lineno"> 1332</span>&#160;</div><div class="line"><a name="l01333"></a><span class="lineno"> 1333</span>&#160;So how do we tell Google Mock that `GetDomainOwner()` can be called with some other arguments as well? The standard technique is to add a &quot;catch all&quot; `EXPECT_CALL`:</div><div class="line"><a name="l01334"></a><span class="lineno"> 1334</span>&#160;</div><div class="line"><a name="l01335"></a><span class="lineno"> 1335</span>&#160;```</div><div class="line"><a name="l01336"></a><span class="lineno"> 1336</span>&#160;  EXPECT_CALL(mock_registry, GetDomainOwner(_))</div><div class="line"><a name="l01337"></a><span class="lineno"> 1337</span>&#160;        .Times(AnyNumber());  // catches all other calls to this method.</div><div class="line"><a name="l01338"></a><span class="lineno"> 1338</span>&#160;  EXPECT_CALL(mock_registry, GetDomainOwner(&quot;google.com&quot;))</div><div class="line"><a name="l01339"></a><span class="lineno"> 1339</span>&#160;        .WillRepeatedly(Return(&quot;Larry Page&quot;));</div><div class="line"><a name="l01340"></a><span class="lineno"> 1340</span>&#160;```</div><div class="line"><a name="l01341"></a><span class="lineno"> 1341</span>&#160;</div><div class="line"><a name="l01342"></a><span class="lineno"> 1342</span>&#160;Remember that `_` is the wildcard matcher that matches anything. With this, if `GetDomainOwner(&quot;google.com&quot;)` is called, it will do what the second `EXPECT_CALL` says; if it is called with a different argument, it will do what the first `EXPECT_CALL` says.</div><div class="line"><a name="l01343"></a><span class="lineno"> 1343</span>&#160;</div><div class="line"><a name="l01344"></a><span class="lineno"> 1344</span>&#160;Note that the order of the two `EXPECT_CALLs` is important, as a newer `EXPECT_CALL` takes precedence over an older one.</div><div class="line"><a name="l01345"></a><span class="lineno"> 1345</span>&#160;</div><div class="line"><a name="l01346"></a><span class="lineno"> 1346</span>&#160;For more on uninteresting calls, nice mocks, and strict mocks, read [&quot;The Nice, the Strict, and the Naggy&quot;](#the-nice-the-strict-and-the-naggy).</div><div class="line"><a name="l01347"></a><span class="lineno"> 1347</span>&#160;</div><div class="line"><a name="l01348"></a><span class="lineno"> 1348</span>&#160;## Expecting Ordered Calls ##</div><div class="line"><a name="l01349"></a><span class="lineno"> 1349</span>&#160;</div><div class="line"><a name="l01350"></a><span class="lineno"> 1350</span>&#160;Although an `EXPECT_CALL()` statement defined earlier takes precedence</div><div class="line"><a name="l01351"></a><span class="lineno"> 1351</span>&#160;when Google Mock tries to match a function call with an expectation,</div><div class="line"><a name="l01352"></a><span class="lineno"> 1352</span>&#160;by default calls don&#39;t have to happen in the order `EXPECT_CALL()`</div><div class="line"><a name="l01353"></a><span class="lineno"> 1353</span>&#160;statements are written. For example, if the arguments match the</div><div class="line"><a name="l01354"></a><span class="lineno"> 1354</span>&#160;matchers in the third `EXPECT_CALL()`, but not those in the first two,</div><div class="line"><a name="l01355"></a><span class="lineno"> 1355</span>&#160;then the third expectation will be used.</div><div class="line"><a name="l01356"></a><span class="lineno"> 1356</span>&#160;</div><div class="line"><a name="l01357"></a><span class="lineno"> 1357</span>&#160;If you would rather have all calls occur in the order of the</div><div class="line"><a name="l01358"></a><span class="lineno"> 1358</span>&#160;expectations, put the `EXPECT_CALL()` statements in a block where you</div><div class="line"><a name="l01359"></a><span class="lineno"> 1359</span>&#160;define a variable of type `InSequence`:</div><div class="line"><a name="l01360"></a><span class="lineno"> 1360</span>&#160;</div><div class="line"><a name="l01361"></a><span class="lineno"> 1361</span>&#160;```</div><div class="line"><a name="l01362"></a><span class="lineno"> 1362</span>&#160;  using ::testing::_;</div><div class="line"><a name="l01363"></a><span class="lineno"> 1363</span>&#160;  using ::testing::InSequence;</div><div class="line"><a name="l01364"></a><span class="lineno"> 1364</span>&#160;</div><div class="line"><a name="l01365"></a><span class="lineno"> 1365</span>&#160;  {</div><div class="line"><a name="l01366"></a><span class="lineno"> 1366</span>&#160;    InSequence s;</div><div class="line"><a name="l01367"></a><span class="lineno"> 1367</span>&#160;</div><div class="line"><a name="l01368"></a><span class="lineno"> 1368</span>&#160;    EXPECT_CALL(foo, DoThis(5));</div><div class="line"><a name="l01369"></a><span class="lineno"> 1369</span>&#160;    EXPECT_CALL(bar, DoThat(_))</div><div class="line"><a name="l01370"></a><span class="lineno"> 1370</span>&#160;        .Times(2);</div><div class="line"><a name="l01371"></a><span class="lineno"> 1371</span>&#160;    EXPECT_CALL(foo, DoThis(6));</div><div class="line"><a name="l01372"></a><span class="lineno"> 1372</span>&#160;  }</div><div class="line"><a name="l01373"></a><span class="lineno"> 1373</span>&#160;```</div><div class="line"><a name="l01374"></a><span class="lineno"> 1374</span>&#160;</div><div class="line"><a name="l01375"></a><span class="lineno"> 1375</span>&#160;In this example, we expect a call to `foo.DoThis(5)`, followed by two</div><div class="line"><a name="l01376"></a><span class="lineno"> 1376</span>&#160;calls to `bar.DoThat()` where the argument can be anything, which are</div><div class="line"><a name="l01377"></a><span class="lineno"> 1377</span>&#160;in turn followed by a call to `foo.DoThis(6)`. If a call occurred</div><div class="line"><a name="l01378"></a><span class="lineno"> 1378</span>&#160;out-of-order, Google Mock will report an error.</div><div class="line"><a name="l01379"></a><span class="lineno"> 1379</span>&#160;</div><div class="line"><a name="l01380"></a><span class="lineno"> 1380</span>&#160;## Expecting Partially Ordered Calls ##</div><div class="line"><a name="l01381"></a><span class="lineno"> 1381</span>&#160;</div><div class="line"><a name="l01382"></a><span class="lineno"> 1382</span>&#160;Sometimes requiring everything to occur in a predetermined order can</div><div class="line"><a name="l01383"></a><span class="lineno"> 1383</span>&#160;lead to brittle tests. For example, we may care about `A` occurring</div><div class="line"><a name="l01384"></a><span class="lineno"> 1384</span>&#160;before both `B` and `C`, but aren&#39;t interested in the relative order</div><div class="line"><a name="l01385"></a><span class="lineno"> 1385</span>&#160;of `B` and `C`. In this case, the test should reflect our real intent,</div><div class="line"><a name="l01386"></a><span class="lineno"> 1386</span>&#160;instead of being overly constraining.</div><div class="line"><a name="l01387"></a><span class="lineno"> 1387</span>&#160;</div><div class="line"><a name="l01388"></a><span class="lineno"> 1388</span>&#160;Google Mock allows you to impose an arbitrary DAG (directed acyclic</div><div class="line"><a name="l01389"></a><span class="lineno"> 1389</span>&#160;graph) on the calls. One way to express the DAG is to use the</div><div class="line"><a name="l01390"></a><span class="lineno"> 1390</span>&#160;[After](CheatSheet.md#the-after-clause) clause of `EXPECT_CALL`.</div><div class="line"><a name="l01391"></a><span class="lineno"> 1391</span>&#160;</div><div class="line"><a name="l01392"></a><span class="lineno"> 1392</span>&#160;Another way is via the `InSequence()` clause (not the same as the</div><div class="line"><a name="l01393"></a><span class="lineno"> 1393</span>&#160;`InSequence` class), which we borrowed from jMock 2. It&#39;s less</div><div class="line"><a name="l01394"></a><span class="lineno"> 1394</span>&#160;flexible than `After()`, but more convenient when you have long chains</div><div class="line"><a name="l01395"></a><span class="lineno"> 1395</span>&#160;of sequential calls, as it doesn&#39;t require you to come up with</div><div class="line"><a name="l01396"></a><span class="lineno"> 1396</span>&#160;different names for the expectations in the chains.  Here&#39;s how it</div><div class="line"><a name="l01397"></a><span class="lineno"> 1397</span>&#160;works:</div><div class="line"><a name="l01398"></a><span class="lineno"> 1398</span>&#160;</div><div class="line"><a name="l01399"></a><span class="lineno"> 1399</span>&#160;If we view `EXPECT_CALL()` statements as nodes in a graph, and add an</div><div class="line"><a name="l01400"></a><span class="lineno"> 1400</span>&#160;edge from node A to node B wherever A must occur before B, we can get</div><div class="line"><a name="l01401"></a><span class="lineno"> 1401</span>&#160;a DAG. We use the term &quot;sequence&quot; to mean a directed path in this</div><div class="line"><a name="l01402"></a><span class="lineno"> 1402</span>&#160;DAG. Now, if we decompose the DAG into sequences, we just need to know</div><div class="line"><a name="l01403"></a><span class="lineno"> 1403</span>&#160;which sequences each `EXPECT_CALL()` belongs to in order to be able to</div><div class="line"><a name="l01404"></a><span class="lineno"> 1404</span>&#160;reconstruct the orginal DAG.</div><div class="line"><a name="l01405"></a><span class="lineno"> 1405</span>&#160;</div><div class="line"><a name="l01406"></a><span class="lineno"> 1406</span>&#160;So, to specify the partial order on the expectations we need to do two</div><div class="line"><a name="l01407"></a><span class="lineno"> 1407</span>&#160;things: first to define some `Sequence` objects, and then for each</div><div class="line"><a name="l01408"></a><span class="lineno"> 1408</span>&#160;`EXPECT_CALL()` say which `Sequence` objects it is part</div><div class="line"><a name="l01409"></a><span class="lineno"> 1409</span>&#160;of. Expectations in the same sequence must occur in the order they are</div><div class="line"><a name="l01410"></a><span class="lineno"> 1410</span>&#160;written. For example,</div><div class="line"><a name="l01411"></a><span class="lineno"> 1411</span>&#160;</div><div class="line"><a name="l01412"></a><span class="lineno"> 1412</span>&#160;```</div><div class="line"><a name="l01413"></a><span class="lineno"> 1413</span>&#160;  using ::testing::Sequence;</div><div class="line"><a name="l01414"></a><span class="lineno"> 1414</span>&#160;</div><div class="line"><a name="l01415"></a><span class="lineno"> 1415</span>&#160;  Sequence s1, s2;</div><div class="line"><a name="l01416"></a><span class="lineno"> 1416</span>&#160;</div><div class="line"><a name="l01417"></a><span class="lineno"> 1417</span>&#160;  EXPECT_CALL(foo, A())</div><div class="line"><a name="l01418"></a><span class="lineno"> 1418</span>&#160;      .InSequence(s1, s2);</div><div class="line"><a name="l01419"></a><span class="lineno"> 1419</span>&#160;  EXPECT_CALL(bar, B())</div><div class="line"><a name="l01420"></a><span class="lineno"> 1420</span>&#160;      .InSequence(s1);</div><div class="line"><a name="l01421"></a><span class="lineno"> 1421</span>&#160;  EXPECT_CALL(bar, C())</div><div class="line"><a name="l01422"></a><span class="lineno"> 1422</span>&#160;      .InSequence(s2);</div><div class="line"><a name="l01423"></a><span class="lineno"> 1423</span>&#160;  EXPECT_CALL(foo, D())</div><div class="line"><a name="l01424"></a><span class="lineno"> 1424</span>&#160;      .InSequence(s2);</div><div class="line"><a name="l01425"></a><span class="lineno"> 1425</span>&#160;```</div><div class="line"><a name="l01426"></a><span class="lineno"> 1426</span>&#160;</div><div class="line"><a name="l01427"></a><span class="lineno"> 1427</span>&#160;specifies the following DAG (where `s1` is `A -&gt; B`, and `s2` is `A -&gt;</div><div class="line"><a name="l01428"></a><span class="lineno"> 1428</span>&#160;C -&gt; D`):</div><div class="line"><a name="l01429"></a><span class="lineno"> 1429</span>&#160;</div><div class="line"><a name="l01430"></a><span class="lineno"> 1430</span>&#160;```</div><div class="line"><a name="l01431"></a><span class="lineno"> 1431</span>&#160;       +---&gt; B</div><div class="line"><a name="l01432"></a><span class="lineno"> 1432</span>&#160;       |</div><div class="line"><a name="l01433"></a><span class="lineno"> 1433</span>&#160;  A ---|</div><div class="line"><a name="l01434"></a><span class="lineno"> 1434</span>&#160;       |</div><div class="line"><a name="l01435"></a><span class="lineno"> 1435</span>&#160;       +---&gt; C ---&gt; D</div><div class="line"><a name="l01436"></a><span class="lineno"> 1436</span>&#160;```</div><div class="line"><a name="l01437"></a><span class="lineno"> 1437</span>&#160;</div><div class="line"><a name="l01438"></a><span class="lineno"> 1438</span>&#160;This means that A must occur before B and C, and C must occur before</div><div class="line"><a name="l01439"></a><span class="lineno"> 1439</span>&#160;D. There&#39;s no restriction about the order other than these.</div><div class="line"><a name="l01440"></a><span class="lineno"> 1440</span>&#160;</div><div class="line"><a name="l01441"></a><span class="lineno"> 1441</span>&#160;## Controlling When an Expectation Retires ##</div><div class="line"><a name="l01442"></a><span class="lineno"> 1442</span>&#160;</div><div class="line"><a name="l01443"></a><span class="lineno"> 1443</span>&#160;When a mock method is called, Google Mock only consider expectations</div><div class="line"><a name="l01444"></a><span class="lineno"> 1444</span>&#160;that are still active. An expectation is active when created, and</div><div class="line"><a name="l01445"></a><span class="lineno"> 1445</span>&#160;becomes inactive (aka _retires_) when a call that has to occur later</div><div class="line"><a name="l01446"></a><span class="lineno"> 1446</span>&#160;has occurred. For example, in</div><div class="line"><a name="l01447"></a><span class="lineno"> 1447</span>&#160;</div><div class="line"><a name="l01448"></a><span class="lineno"> 1448</span>&#160;```</div><div class="line"><a name="l01449"></a><span class="lineno"> 1449</span>&#160;  using ::testing::_;</div><div class="line"><a name="l01450"></a><span class="lineno"> 1450</span>&#160;  using ::testing::Sequence;</div><div class="line"><a name="l01451"></a><span class="lineno"> 1451</span>&#160;</div><div class="line"><a name="l01452"></a><span class="lineno"> 1452</span>&#160;  Sequence s1, s2;</div><div class="line"><a name="l01453"></a><span class="lineno"> 1453</span>&#160;</div><div class="line"><a name="l01454"></a><span class="lineno"> 1454</span>&#160;  EXPECT_CALL(log, Log(WARNING, _, &quot;File too large.&quot;))     // #1</div><div class="line"><a name="l01455"></a><span class="lineno"> 1455</span>&#160;      .Times(AnyNumber())</div><div class="line"><a name="l01456"></a><span class="lineno"> 1456</span>&#160;      .InSequence(s1, s2);</div><div class="line"><a name="l01457"></a><span class="lineno"> 1457</span>&#160;  EXPECT_CALL(log, Log(WARNING, _, &quot;Data set is empty.&quot;))  // #2</div><div class="line"><a name="l01458"></a><span class="lineno"> 1458</span>&#160;      .InSequence(s1);</div><div class="line"><a name="l01459"></a><span class="lineno"> 1459</span>&#160;  EXPECT_CALL(log, Log(WARNING, _, &quot;User not found.&quot;))     // #3</div><div class="line"><a name="l01460"></a><span class="lineno"> 1460</span>&#160;      .InSequence(s2);</div><div class="line"><a name="l01461"></a><span class="lineno"> 1461</span>&#160;```</div><div class="line"><a name="l01462"></a><span class="lineno"> 1462</span>&#160;</div><div class="line"><a name="l01463"></a><span class="lineno"> 1463</span>&#160;as soon as either #2 or #3 is matched, #1 will retire. If a warning</div><div class="line"><a name="l01464"></a><span class="lineno"> 1464</span>&#160;`&quot;File too large.&quot;` is logged after this, it will be an error.</div><div class="line"><a name="l01465"></a><span class="lineno"> 1465</span>&#160;</div><div class="line"><a name="l01466"></a><span class="lineno"> 1466</span>&#160;Note that an expectation doesn&#39;t retire automatically when it&#39;s</div><div class="line"><a name="l01467"></a><span class="lineno"> 1467</span>&#160;saturated. For example,</div><div class="line"><a name="l01468"></a><span class="lineno"> 1468</span>&#160;</div><div class="line"><a name="l01469"></a><span class="lineno"> 1469</span>&#160;```</div><div class="line"><a name="l01470"></a><span class="lineno"> 1470</span>&#160;using ::testing::_;</div><div class="line"><a name="l01471"></a><span class="lineno"> 1471</span>&#160;...</div><div class="line"><a name="l01472"></a><span class="lineno"> 1472</span>&#160;  EXPECT_CALL(log, Log(WARNING, _, _));                  // #1</div><div class="line"><a name="l01473"></a><span class="lineno"> 1473</span>&#160;  EXPECT_CALL(log, Log(WARNING, _, &quot;File too large.&quot;));  // #2</div><div class="line"><a name="l01474"></a><span class="lineno"> 1474</span>&#160;```</div><div class="line"><a name="l01475"></a><span class="lineno"> 1475</span>&#160;</div><div class="line"><a name="l01476"></a><span class="lineno"> 1476</span>&#160;says that there will be exactly one warning with the message `&quot;File</div><div class="line"><a name="l01477"></a><span class="lineno"> 1477</span>&#160;too large.&quot;`. If the second warning contains this message too, #2 will</div><div class="line"><a name="l01478"></a><span class="lineno"> 1478</span>&#160;match again and result in an upper-bound-violated error.</div><div class="line"><a name="l01479"></a><span class="lineno"> 1479</span>&#160;</div><div class="line"><a name="l01480"></a><span class="lineno"> 1480</span>&#160;If this is not what you want, you can ask an expectation to retire as</div><div class="line"><a name="l01481"></a><span class="lineno"> 1481</span>&#160;soon as it becomes saturated:</div><div class="line"><a name="l01482"></a><span class="lineno"> 1482</span>&#160;</div><div class="line"><a name="l01483"></a><span class="lineno"> 1483</span>&#160;```</div><div class="line"><a name="l01484"></a><span class="lineno"> 1484</span>&#160;using ::testing::_;</div><div class="line"><a name="l01485"></a><span class="lineno"> 1485</span>&#160;...</div><div class="line"><a name="l01486"></a><span class="lineno"> 1486</span>&#160;  EXPECT_CALL(log, Log(WARNING, _, _));                 // #1</div><div class="line"><a name="l01487"></a><span class="lineno"> 1487</span>&#160;  EXPECT_CALL(log, Log(WARNING, _, &quot;File too large.&quot;))  // #2</div><div class="line"><a name="l01488"></a><span class="lineno"> 1488</span>&#160;      .RetiresOnSaturation();</div><div class="line"><a name="l01489"></a><span class="lineno"> 1489</span>&#160;```</div><div class="line"><a name="l01490"></a><span class="lineno"> 1490</span>&#160;</div><div class="line"><a name="l01491"></a><span class="lineno"> 1491</span>&#160;Here #2 can be used only once, so if you have two warnings with the</div><div class="line"><a name="l01492"></a><span class="lineno"> 1492</span>&#160;message `&quot;File too large.&quot;`, the first will match #2 and the second</div><div class="line"><a name="l01493"></a><span class="lineno"> 1493</span>&#160;will match #1 - there will be no error.</div><div class="line"><a name="l01494"></a><span class="lineno"> 1494</span>&#160;</div><div class="line"><a name="l01495"></a><span class="lineno"> 1495</span>&#160;# Using Actions #</div><div class="line"><a name="l01496"></a><span class="lineno"> 1496</span>&#160;</div><div class="line"><a name="l01497"></a><span class="lineno"> 1497</span>&#160;## Returning References from Mock Methods ##</div><div class="line"><a name="l01498"></a><span class="lineno"> 1498</span>&#160;</div><div class="line"><a name="l01499"></a><span class="lineno"> 1499</span>&#160;If a mock function&#39;s return type is a reference, you need to use</div><div class="line"><a name="l01500"></a><span class="lineno"> 1500</span>&#160;`ReturnRef()` instead of `Return()` to return a result:</div><div class="line"><a name="l01501"></a><span class="lineno"> 1501</span>&#160;</div><div class="line"><a name="l01502"></a><span class="lineno"> 1502</span>&#160;```</div><div class="line"><a name="l01503"></a><span class="lineno"> 1503</span>&#160;using ::testing::ReturnRef;</div><div class="line"><a name="l01504"></a><span class="lineno"> 1504</span>&#160;</div><div class="line"><a name="l01505"></a><span class="lineno"> 1505</span>&#160;class MockFoo : public Foo {</div><div class="line"><a name="l01506"></a><span class="lineno"> 1506</span>&#160; public:</div><div class="line"><a name="l01507"></a><span class="lineno"> 1507</span>&#160;  MOCK_METHOD0(GetBar, Bar&amp;());</div><div class="line"><a name="l01508"></a><span class="lineno"> 1508</span>&#160;};</div><div class="line"><a name="l01509"></a><span class="lineno"> 1509</span>&#160;...</div><div class="line"><a name="l01510"></a><span class="lineno"> 1510</span>&#160;</div><div class="line"><a name="l01511"></a><span class="lineno"> 1511</span>&#160;  MockFoo foo;</div><div class="line"><a name="l01512"></a><span class="lineno"> 1512</span>&#160;  Bar bar;</div><div class="line"><a name="l01513"></a><span class="lineno"> 1513</span>&#160;  EXPECT_CALL(foo, GetBar())</div><div class="line"><a name="l01514"></a><span class="lineno"> 1514</span>&#160;      .WillOnce(ReturnRef(bar));</div><div class="line"><a name="l01515"></a><span class="lineno"> 1515</span>&#160;```</div><div class="line"><a name="l01516"></a><span class="lineno"> 1516</span>&#160;</div><div class="line"><a name="l01517"></a><span class="lineno"> 1517</span>&#160;## Returning Live Values from Mock Methods ##</div><div class="line"><a name="l01518"></a><span class="lineno"> 1518</span>&#160;</div><div class="line"><a name="l01519"></a><span class="lineno"> 1519</span>&#160;The `Return(x)` action saves a copy of `x` when the action is</div><div class="line"><a name="l01520"></a><span class="lineno"> 1520</span>&#160;_created_, and always returns the same value whenever it&#39;s</div><div class="line"><a name="l01521"></a><span class="lineno"> 1521</span>&#160;executed. Sometimes you may want to instead return the _live_ value of</div><div class="line"><a name="l01522"></a><span class="lineno"> 1522</span>&#160;`x` (i.e. its value at the time when the action is _executed_.).</div><div class="line"><a name="l01523"></a><span class="lineno"> 1523</span>&#160;</div><div class="line"><a name="l01524"></a><span class="lineno"> 1524</span>&#160;If the mock function&#39;s return type is a reference, you can do it using</div><div class="line"><a name="l01525"></a><span class="lineno"> 1525</span>&#160;`ReturnRef(x)`, as shown in the previous recipe (&quot;Returning References</div><div class="line"><a name="l01526"></a><span class="lineno"> 1526</span>&#160;from Mock Methods&quot;). However, Google Mock doesn&#39;t let you use</div><div class="line"><a name="l01527"></a><span class="lineno"> 1527</span>&#160;`ReturnRef()` in a mock function whose return type is not a reference,</div><div class="line"><a name="l01528"></a><span class="lineno"> 1528</span>&#160;as doing that usually indicates a user error. So, what shall you do?</div><div class="line"><a name="l01529"></a><span class="lineno"> 1529</span>&#160;</div><div class="line"><a name="l01530"></a><span class="lineno"> 1530</span>&#160;You may be tempted to try `ByRef()`:</div><div class="line"><a name="l01531"></a><span class="lineno"> 1531</span>&#160;</div><div class="line"><a name="l01532"></a><span class="lineno"> 1532</span>&#160;```</div><div class="line"><a name="l01533"></a><span class="lineno"> 1533</span>&#160;using testing::ByRef;</div><div class="line"><a name="l01534"></a><span class="lineno"> 1534</span>&#160;using testing::Return;</div><div class="line"><a name="l01535"></a><span class="lineno"> 1535</span>&#160;</div><div class="line"><a name="l01536"></a><span class="lineno"> 1536</span>&#160;class MockFoo : public Foo {</div><div class="line"><a name="l01537"></a><span class="lineno"> 1537</span>&#160; public:</div><div class="line"><a name="l01538"></a><span class="lineno"> 1538</span>&#160;  MOCK_METHOD0(GetValue, int());</div><div class="line"><a name="l01539"></a><span class="lineno"> 1539</span>&#160;};</div><div class="line"><a name="l01540"></a><span class="lineno"> 1540</span>&#160;...</div><div class="line"><a name="l01541"></a><span class="lineno"> 1541</span>&#160;  int x = 0;</div><div class="line"><a name="l01542"></a><span class="lineno"> 1542</span>&#160;  MockFoo foo;</div><div class="line"><a name="l01543"></a><span class="lineno"> 1543</span>&#160;  EXPECT_CALL(foo, GetValue())</div><div class="line"><a name="l01544"></a><span class="lineno"> 1544</span>&#160;      .WillRepeatedly(Return(ByRef(x)));</div><div class="line"><a name="l01545"></a><span class="lineno"> 1545</span>&#160;  x = 42;</div><div class="line"><a name="l01546"></a><span class="lineno"> 1546</span>&#160;  EXPECT_EQ(42, foo.GetValue());</div><div class="line"><a name="l01547"></a><span class="lineno"> 1547</span>&#160;```</div><div class="line"><a name="l01548"></a><span class="lineno"> 1548</span>&#160;</div><div class="line"><a name="l01549"></a><span class="lineno"> 1549</span>&#160;Unfortunately, it doesn&#39;t work here. The above code will fail with error:</div><div class="line"><a name="l01550"></a><span class="lineno"> 1550</span>&#160;</div><div class="line"><a name="l01551"></a><span class="lineno"> 1551</span>&#160;```</div><div class="line"><a name="l01552"></a><span class="lineno"> 1552</span>&#160;Value of: foo.GetValue()</div><div class="line"><a name="l01553"></a><span class="lineno"> 1553</span>&#160;  Actual: 0</div><div class="line"><a name="l01554"></a><span class="lineno"> 1554</span>&#160;Expected: 42</div><div class="line"><a name="l01555"></a><span class="lineno"> 1555</span>&#160;```</div><div class="line"><a name="l01556"></a><span class="lineno"> 1556</span>&#160;</div><div class="line"><a name="l01557"></a><span class="lineno"> 1557</span>&#160;The reason is that `Return(value)` converts `value` to the actual</div><div class="line"><a name="l01558"></a><span class="lineno"> 1558</span>&#160;return type of the mock function at the time when the action is</div><div class="line"><a name="l01559"></a><span class="lineno"> 1559</span>&#160;_created_, not when it is _executed_. (This behavior was chosen for</div><div class="line"><a name="l01560"></a><span class="lineno"> 1560</span>&#160;the action to be safe when `value` is a proxy object that references</div><div class="line"><a name="l01561"></a><span class="lineno"> 1561</span>&#160;some temporary objects.) As a result, `ByRef(x)` is converted to an</div><div class="line"><a name="l01562"></a><span class="lineno"> 1562</span>&#160;`int` value (instead of a `const int&amp;`) when the expectation is set,</div><div class="line"><a name="l01563"></a><span class="lineno"> 1563</span>&#160;and `Return(ByRef(x))` will always return 0.</div><div class="line"><a name="l01564"></a><span class="lineno"> 1564</span>&#160;</div><div class="line"><a name="l01565"></a><span class="lineno"> 1565</span>&#160;`ReturnPointee(pointer)` was provided to solve this problem</div><div class="line"><a name="l01566"></a><span class="lineno"> 1566</span>&#160;specifically. It returns the value pointed to by `pointer` at the time</div><div class="line"><a name="l01567"></a><span class="lineno"> 1567</span>&#160;the action is _executed_:</div><div class="line"><a name="l01568"></a><span class="lineno"> 1568</span>&#160;</div><div class="line"><a name="l01569"></a><span class="lineno"> 1569</span>&#160;```</div><div class="line"><a name="l01570"></a><span class="lineno"> 1570</span>&#160;using testing::ReturnPointee;</div><div class="line"><a name="l01571"></a><span class="lineno"> 1571</span>&#160;...</div><div class="line"><a name="l01572"></a><span class="lineno"> 1572</span>&#160;  int x = 0;</div><div class="line"><a name="l01573"></a><span class="lineno"> 1573</span>&#160;  MockFoo foo;</div><div class="line"><a name="l01574"></a><span class="lineno"> 1574</span>&#160;  EXPECT_CALL(foo, GetValue())</div><div class="line"><a name="l01575"></a><span class="lineno"> 1575</span>&#160;      .WillRepeatedly(ReturnPointee(&amp;x));  // Note the &amp; here.</div><div class="line"><a name="l01576"></a><span class="lineno"> 1576</span>&#160;  x = 42;</div><div class="line"><a name="l01577"></a><span class="lineno"> 1577</span>&#160;  EXPECT_EQ(42, foo.GetValue());  // This will succeed now.</div><div class="line"><a name="l01578"></a><span class="lineno"> 1578</span>&#160;```</div><div class="line"><a name="l01579"></a><span class="lineno"> 1579</span>&#160;</div><div class="line"><a name="l01580"></a><span class="lineno"> 1580</span>&#160;## Combining Actions ##</div><div class="line"><a name="l01581"></a><span class="lineno"> 1581</span>&#160;</div><div class="line"><a name="l01582"></a><span class="lineno"> 1582</span>&#160;Want to do more than one thing when a function is called? That&#39;s</div><div class="line"><a name="l01583"></a><span class="lineno"> 1583</span>&#160;fine. `DoAll()` allow you to do sequence of actions every time. Only</div><div class="line"><a name="l01584"></a><span class="lineno"> 1584</span>&#160;the return value of the last action in the sequence will be used.</div><div class="line"><a name="l01585"></a><span class="lineno"> 1585</span>&#160;</div><div class="line"><a name="l01586"></a><span class="lineno"> 1586</span>&#160;```</div><div class="line"><a name="l01587"></a><span class="lineno"> 1587</span>&#160;using ::testing::DoAll;</div><div class="line"><a name="l01588"></a><span class="lineno"> 1588</span>&#160;</div><div class="line"><a name="l01589"></a><span class="lineno"> 1589</span>&#160;class MockFoo : public Foo {</div><div class="line"><a name="l01590"></a><span class="lineno"> 1590</span>&#160; public:</div><div class="line"><a name="l01591"></a><span class="lineno"> 1591</span>&#160;  MOCK_METHOD1(Bar, bool(int n));</div><div class="line"><a name="l01592"></a><span class="lineno"> 1592</span>&#160;};</div><div class="line"><a name="l01593"></a><span class="lineno"> 1593</span>&#160;...</div><div class="line"><a name="l01594"></a><span class="lineno"> 1594</span>&#160;</div><div class="line"><a name="l01595"></a><span class="lineno"> 1595</span>&#160;  EXPECT_CALL(foo, Bar(_))</div><div class="line"><a name="l01596"></a><span class="lineno"> 1596</span>&#160;      .WillOnce(DoAll(action_1,</div><div class="line"><a name="l01597"></a><span class="lineno"> 1597</span>&#160;                      action_2,</div><div class="line"><a name="l01598"></a><span class="lineno"> 1598</span>&#160;                      ...</div><div class="line"><a name="l01599"></a><span class="lineno"> 1599</span>&#160;                      action_n));</div><div class="line"><a name="l01600"></a><span class="lineno"> 1600</span>&#160;```</div><div class="line"><a name="l01601"></a><span class="lineno"> 1601</span>&#160;</div><div class="line"><a name="l01602"></a><span class="lineno"> 1602</span>&#160;## Mocking Side Effects ##</div><div class="line"><a name="l01603"></a><span class="lineno"> 1603</span>&#160;</div><div class="line"><a name="l01604"></a><span class="lineno"> 1604</span>&#160;Sometimes a method exhibits its effect not via returning a value but</div><div class="line"><a name="l01605"></a><span class="lineno"> 1605</span>&#160;via side effects. For example, it may change some global state or</div><div class="line"><a name="l01606"></a><span class="lineno"> 1606</span>&#160;modify an output argument. To mock side effects, in general you can</div><div class="line"><a name="l01607"></a><span class="lineno"> 1607</span>&#160;define your own action by implementing `::testing::ActionInterface`.</div><div class="line"><a name="l01608"></a><span class="lineno"> 1608</span>&#160;</div><div class="line"><a name="l01609"></a><span class="lineno"> 1609</span>&#160;If all you need to do is to change an output argument, the built-in</div><div class="line"><a name="l01610"></a><span class="lineno"> 1610</span>&#160;`SetArgPointee()` action is convenient:</div><div class="line"><a name="l01611"></a><span class="lineno"> 1611</span>&#160;</div><div class="line"><a name="l01612"></a><span class="lineno"> 1612</span>&#160;```</div><div class="line"><a name="l01613"></a><span class="lineno"> 1613</span>&#160;using ::testing::SetArgPointee;</div><div class="line"><a name="l01614"></a><span class="lineno"> 1614</span>&#160;</div><div class="line"><a name="l01615"></a><span class="lineno"> 1615</span>&#160;class MockMutator : public Mutator {</div><div class="line"><a name="l01616"></a><span class="lineno"> 1616</span>&#160; public:</div><div class="line"><a name="l01617"></a><span class="lineno"> 1617</span>&#160;  MOCK_METHOD2(Mutate, void(bool mutate, int* value));</div><div class="line"><a name="l01618"></a><span class="lineno"> 1618</span>&#160;  ...</div><div class="line"><a name="l01619"></a><span class="lineno"> 1619</span>&#160;};</div><div class="line"><a name="l01620"></a><span class="lineno"> 1620</span>&#160;...</div><div class="line"><a name="l01621"></a><span class="lineno"> 1621</span>&#160;</div><div class="line"><a name="l01622"></a><span class="lineno"> 1622</span>&#160;  MockMutator mutator;</div><div class="line"><a name="l01623"></a><span class="lineno"> 1623</span>&#160;  EXPECT_CALL(mutator, Mutate(true, _))</div><div class="line"><a name="l01624"></a><span class="lineno"> 1624</span>&#160;      .WillOnce(SetArgPointee&lt;1&gt;(5));</div><div class="line"><a name="l01625"></a><span class="lineno"> 1625</span>&#160;```</div><div class="line"><a name="l01626"></a><span class="lineno"> 1626</span>&#160;</div><div class="line"><a name="l01627"></a><span class="lineno"> 1627</span>&#160;In this example, when `mutator.Mutate()` is called, we will assign 5</div><div class="line"><a name="l01628"></a><span class="lineno"> 1628</span>&#160;to the `int` variable pointed to by argument #1</div><div class="line"><a name="l01629"></a><span class="lineno"> 1629</span>&#160;(0-based).</div><div class="line"><a name="l01630"></a><span class="lineno"> 1630</span>&#160;</div><div class="line"><a name="l01631"></a><span class="lineno"> 1631</span>&#160;`SetArgPointee()` conveniently makes an internal copy of the</div><div class="line"><a name="l01632"></a><span class="lineno"> 1632</span>&#160;value you pass to it, removing the need to keep the value in scope and</div><div class="line"><a name="l01633"></a><span class="lineno"> 1633</span>&#160;alive. The implication however is that the value must have a copy</div><div class="line"><a name="l01634"></a><span class="lineno"> 1634</span>&#160;constructor and assignment operator.</div><div class="line"><a name="l01635"></a><span class="lineno"> 1635</span>&#160;</div><div class="line"><a name="l01636"></a><span class="lineno"> 1636</span>&#160;If the mock method also needs to return a value as well, you can chain</div><div class="line"><a name="l01637"></a><span class="lineno"> 1637</span>&#160;`SetArgPointee()` with `Return()` using `DoAll()`:</div><div class="line"><a name="l01638"></a><span class="lineno"> 1638</span>&#160;</div><div class="line"><a name="l01639"></a><span class="lineno"> 1639</span>&#160;```</div><div class="line"><a name="l01640"></a><span class="lineno"> 1640</span>&#160;using ::testing::_;</div><div class="line"><a name="l01641"></a><span class="lineno"> 1641</span>&#160;using ::testing::Return;</div><div class="line"><a name="l01642"></a><span class="lineno"> 1642</span>&#160;using ::testing::SetArgPointee;</div><div class="line"><a name="l01643"></a><span class="lineno"> 1643</span>&#160;</div><div class="line"><a name="l01644"></a><span class="lineno"> 1644</span>&#160;class MockMutator : public Mutator {</div><div class="line"><a name="l01645"></a><span class="lineno"> 1645</span>&#160; public:</div><div class="line"><a name="l01646"></a><span class="lineno"> 1646</span>&#160;  ...</div><div class="line"><a name="l01647"></a><span class="lineno"> 1647</span>&#160;  MOCK_METHOD1(MutateInt, bool(int* value));</div><div class="line"><a name="l01648"></a><span class="lineno"> 1648</span>&#160;};</div><div class="line"><a name="l01649"></a><span class="lineno"> 1649</span>&#160;...</div><div class="line"><a name="l01650"></a><span class="lineno"> 1650</span>&#160;</div><div class="line"><a name="l01651"></a><span class="lineno"> 1651</span>&#160;  MockMutator mutator;</div><div class="line"><a name="l01652"></a><span class="lineno"> 1652</span>&#160;  EXPECT_CALL(mutator, MutateInt(_))</div><div class="line"><a name="l01653"></a><span class="lineno"> 1653</span>&#160;      .WillOnce(DoAll(SetArgPointee&lt;0&gt;(5),</div><div class="line"><a name="l01654"></a><span class="lineno"> 1654</span>&#160;                      Return(true)));</div><div class="line"><a name="l01655"></a><span class="lineno"> 1655</span>&#160;```</div><div class="line"><a name="l01656"></a><span class="lineno"> 1656</span>&#160;</div><div class="line"><a name="l01657"></a><span class="lineno"> 1657</span>&#160;If the output argument is an array, use the</div><div class="line"><a name="l01658"></a><span class="lineno"> 1658</span>&#160;`SetArrayArgument&lt;N&gt;(first, last)` action instead. It copies the</div><div class="line"><a name="l01659"></a><span class="lineno"> 1659</span>&#160;elements in source range `[first, last)` to the array pointed to by</div><div class="line"><a name="l01660"></a><span class="lineno"> 1660</span>&#160;the `N`-th (0-based) argument:</div><div class="line"><a name="l01661"></a><span class="lineno"> 1661</span>&#160;</div><div class="line"><a name="l01662"></a><span class="lineno"> 1662</span>&#160;```</div><div class="line"><a name="l01663"></a><span class="lineno"> 1663</span>&#160;using ::testing::NotNull;</div><div class="line"><a name="l01664"></a><span class="lineno"> 1664</span>&#160;using ::testing::SetArrayArgument;</div><div class="line"><a name="l01665"></a><span class="lineno"> 1665</span>&#160;</div><div class="line"><a name="l01666"></a><span class="lineno"> 1666</span>&#160;class MockArrayMutator : public ArrayMutator {</div><div class="line"><a name="l01667"></a><span class="lineno"> 1667</span>&#160; public:</div><div class="line"><a name="l01668"></a><span class="lineno"> 1668</span>&#160;  MOCK_METHOD2(Mutate, void(int* values, int num_values));</div><div class="line"><a name="l01669"></a><span class="lineno"> 1669</span>&#160;  ...</div><div class="line"><a name="l01670"></a><span class="lineno"> 1670</span>&#160;};</div><div class="line"><a name="l01671"></a><span class="lineno"> 1671</span>&#160;...</div><div class="line"><a name="l01672"></a><span class="lineno"> 1672</span>&#160;</div><div class="line"><a name="l01673"></a><span class="lineno"> 1673</span>&#160;  MockArrayMutator mutator;</div><div class="line"><a name="l01674"></a><span class="lineno"> 1674</span>&#160;  int values[5] = { 1, 2, 3, 4, 5 };</div><div class="line"><a name="l01675"></a><span class="lineno"> 1675</span>&#160;  EXPECT_CALL(mutator, Mutate(NotNull(), 5))</div><div class="line"><a name="l01676"></a><span class="lineno"> 1676</span>&#160;      .WillOnce(SetArrayArgument&lt;0&gt;(values, values + 5));</div><div class="line"><a name="l01677"></a><span class="lineno"> 1677</span>&#160;```</div><div class="line"><a name="l01678"></a><span class="lineno"> 1678</span>&#160;</div><div class="line"><a name="l01679"></a><span class="lineno"> 1679</span>&#160;This also works when the argument is an output iterator:</div><div class="line"><a name="l01680"></a><span class="lineno"> 1680</span>&#160;</div><div class="line"><a name="l01681"></a><span class="lineno"> 1681</span>&#160;```</div><div class="line"><a name="l01682"></a><span class="lineno"> 1682</span>&#160;using ::testing::_;</div><div class="line"><a name="l01683"></a><span class="lineno"> 1683</span>&#160;using ::testing::SeArrayArgument;</div><div class="line"><a name="l01684"></a><span class="lineno"> 1684</span>&#160;</div><div class="line"><a name="l01685"></a><span class="lineno"> 1685</span>&#160;class MockRolodex : public Rolodex {</div><div class="line"><a name="l01686"></a><span class="lineno"> 1686</span>&#160; public:</div><div class="line"><a name="l01687"></a><span class="lineno"> 1687</span>&#160;  MOCK_METHOD1(GetNames, void(std::back_insert_iterator&lt;vector&lt;string&gt; &gt;));</div><div class="line"><a name="l01688"></a><span class="lineno"> 1688</span>&#160;  ...</div><div class="line"><a name="l01689"></a><span class="lineno"> 1689</span>&#160;};</div><div class="line"><a name="l01690"></a><span class="lineno"> 1690</span>&#160;...</div><div class="line"><a name="l01691"></a><span class="lineno"> 1691</span>&#160;</div><div class="line"><a name="l01692"></a><span class="lineno"> 1692</span>&#160;  MockRolodex rolodex;</div><div class="line"><a name="l01693"></a><span class="lineno"> 1693</span>&#160;  vector&lt;string&gt; names;</div><div class="line"><a name="l01694"></a><span class="lineno"> 1694</span>&#160;  names.push_back(&quot;George&quot;);</div><div class="line"><a name="l01695"></a><span class="lineno"> 1695</span>&#160;  names.push_back(&quot;John&quot;);</div><div class="line"><a name="l01696"></a><span class="lineno"> 1696</span>&#160;  names.push_back(&quot;Thomas&quot;);</div><div class="line"><a name="l01697"></a><span class="lineno"> 1697</span>&#160;  EXPECT_CALL(rolodex, GetNames(_))</div><div class="line"><a name="l01698"></a><span class="lineno"> 1698</span>&#160;      .WillOnce(SetArrayArgument&lt;0&gt;(names.begin(), names.end()));</div><div class="line"><a name="l01699"></a><span class="lineno"> 1699</span>&#160;```</div><div class="line"><a name="l01700"></a><span class="lineno"> 1700</span>&#160;</div><div class="line"><a name="l01701"></a><span class="lineno"> 1701</span>&#160;## Changing a Mock Object&#39;s Behavior Based on the State ##</div><div class="line"><a name="l01702"></a><span class="lineno"> 1702</span>&#160;</div><div class="line"><a name="l01703"></a><span class="lineno"> 1703</span>&#160;If you expect a call to change the behavior of a mock object, you can use `::testing::InSequence` to specify different behaviors before and after the call:</div><div class="line"><a name="l01704"></a><span class="lineno"> 1704</span>&#160;</div><div class="line"><a name="l01705"></a><span class="lineno"> 1705</span>&#160;```</div><div class="line"><a name="l01706"></a><span class="lineno"> 1706</span>&#160;using ::testing::InSequence;</div><div class="line"><a name="l01707"></a><span class="lineno"> 1707</span>&#160;using ::testing::Return;</div><div class="line"><a name="l01708"></a><span class="lineno"> 1708</span>&#160;</div><div class="line"><a name="l01709"></a><span class="lineno"> 1709</span>&#160;...</div><div class="line"><a name="l01710"></a><span class="lineno"> 1710</span>&#160;  {</div><div class="line"><a name="l01711"></a><span class="lineno"> 1711</span>&#160;    InSequence seq;</div><div class="line"><a name="l01712"></a><span class="lineno"> 1712</span>&#160;    EXPECT_CALL(my_mock, IsDirty())</div><div class="line"><a name="l01713"></a><span class="lineno"> 1713</span>&#160;        .WillRepeatedly(Return(true));</div><div class="line"><a name="l01714"></a><span class="lineno"> 1714</span>&#160;    EXPECT_CALL(my_mock, Flush());</div><div class="line"><a name="l01715"></a><span class="lineno"> 1715</span>&#160;    EXPECT_CALL(my_mock, IsDirty())</div><div class="line"><a name="l01716"></a><span class="lineno"> 1716</span>&#160;        .WillRepeatedly(Return(false));</div><div class="line"><a name="l01717"></a><span class="lineno"> 1717</span>&#160;  }</div><div class="line"><a name="l01718"></a><span class="lineno"> 1718</span>&#160;  my_mock.FlushIfDirty();</div><div class="line"><a name="l01719"></a><span class="lineno"> 1719</span>&#160;```</div><div class="line"><a name="l01720"></a><span class="lineno"> 1720</span>&#160;</div><div class="line"><a name="l01721"></a><span class="lineno"> 1721</span>&#160;This makes `my_mock.IsDirty()` return `true` before `my_mock.Flush()` is called and return `false` afterwards.</div><div class="line"><a name="l01722"></a><span class="lineno"> 1722</span>&#160;</div><div class="line"><a name="l01723"></a><span class="lineno"> 1723</span>&#160;If the behavior change is more complex, you can store the effects in a variable and make a mock method get its return value from that variable:</div><div class="line"><a name="l01724"></a><span class="lineno"> 1724</span>&#160;</div><div class="line"><a name="l01725"></a><span class="lineno"> 1725</span>&#160;```</div><div class="line"><a name="l01726"></a><span class="lineno"> 1726</span>&#160;using ::testing::_;</div><div class="line"><a name="l01727"></a><span class="lineno"> 1727</span>&#160;using ::testing::SaveArg;</div><div class="line"><a name="l01728"></a><span class="lineno"> 1728</span>&#160;using ::testing::Return;</div><div class="line"><a name="l01729"></a><span class="lineno"> 1729</span>&#160;</div><div class="line"><a name="l01730"></a><span class="lineno"> 1730</span>&#160;ACTION_P(ReturnPointee, p) { return *p; }</div><div class="line"><a name="l01731"></a><span class="lineno"> 1731</span>&#160;...</div><div class="line"><a name="l01732"></a><span class="lineno"> 1732</span>&#160;  int previous_value = 0;</div><div class="line"><a name="l01733"></a><span class="lineno"> 1733</span>&#160;  EXPECT_CALL(my_mock, GetPrevValue())</div><div class="line"><a name="l01734"></a><span class="lineno"> 1734</span>&#160;      .WillRepeatedly(ReturnPointee(&amp;previous_value));</div><div class="line"><a name="l01735"></a><span class="lineno"> 1735</span>&#160;  EXPECT_CALL(my_mock, UpdateValue(_))</div><div class="line"><a name="l01736"></a><span class="lineno"> 1736</span>&#160;      .WillRepeatedly(SaveArg&lt;0&gt;(&amp;previous_value));</div><div class="line"><a name="l01737"></a><span class="lineno"> 1737</span>&#160;  my_mock.DoSomethingToUpdateValue();</div><div class="line"><a name="l01738"></a><span class="lineno"> 1738</span>&#160;```</div><div class="line"><a name="l01739"></a><span class="lineno"> 1739</span>&#160;</div><div class="line"><a name="l01740"></a><span class="lineno"> 1740</span>&#160;Here `my_mock.GetPrevValue()` will always return the argument of the last `UpdateValue()` call.</div><div class="line"><a name="l01741"></a><span class="lineno"> 1741</span>&#160;</div><div class="line"><a name="l01742"></a><span class="lineno"> 1742</span>&#160;## Setting the Default Value for a Return Type ##</div><div class="line"><a name="l01743"></a><span class="lineno"> 1743</span>&#160;</div><div class="line"><a name="l01744"></a><span class="lineno"> 1744</span>&#160;If a mock method&#39;s return type is a built-in C++ type or pointer, by</div><div class="line"><a name="l01745"></a><span class="lineno"> 1745</span>&#160;default it will return 0 when invoked. Also, in C++ 11 and above, a mock</div><div class="line"><a name="l01746"></a><span class="lineno"> 1746</span>&#160;method whose return type has a default constructor will return a default-constructed</div><div class="line"><a name="l01747"></a><span class="lineno"> 1747</span>&#160;value by default.  You only need to specify an</div><div class="line"><a name="l01748"></a><span class="lineno"> 1748</span>&#160;action if this default value doesn&#39;t work for you.</div><div class="line"><a name="l01749"></a><span class="lineno"> 1749</span>&#160;</div><div class="line"><a name="l01750"></a><span class="lineno"> 1750</span>&#160;Sometimes, you may want to change this default value, or you may want</div><div class="line"><a name="l01751"></a><span class="lineno"> 1751</span>&#160;to specify a default value for types Google Mock doesn&#39;t know</div><div class="line"><a name="l01752"></a><span class="lineno"> 1752</span>&#160;about. You can do this using the `::testing::DefaultValue` class</div><div class="line"><a name="l01753"></a><span class="lineno"> 1753</span>&#160;template:</div><div class="line"><a name="l01754"></a><span class="lineno"> 1754</span>&#160;</div><div class="line"><a name="l01755"></a><span class="lineno"> 1755</span>&#160;```</div><div class="line"><a name="l01756"></a><span class="lineno"> 1756</span>&#160;class MockFoo : public Foo {</div><div class="line"><a name="l01757"></a><span class="lineno"> 1757</span>&#160; public:</div><div class="line"><a name="l01758"></a><span class="lineno"> 1758</span>&#160;  MOCK_METHOD0(CalculateBar, Bar());</div><div class="line"><a name="l01759"></a><span class="lineno"> 1759</span>&#160;};</div><div class="line"><a name="l01760"></a><span class="lineno"> 1760</span>&#160;...</div><div class="line"><a name="l01761"></a><span class="lineno"> 1761</span>&#160;</div><div class="line"><a name="l01762"></a><span class="lineno"> 1762</span>&#160;  Bar default_bar;</div><div class="line"><a name="l01763"></a><span class="lineno"> 1763</span>&#160;  // Sets the default return value for type Bar.</div><div class="line"><a name="l01764"></a><span class="lineno"> 1764</span>&#160;  DefaultValue&lt;Bar&gt;::Set(default_bar);</div><div class="line"><a name="l01765"></a><span class="lineno"> 1765</span>&#160;</div><div class="line"><a name="l01766"></a><span class="lineno"> 1766</span>&#160;  MockFoo foo;</div><div class="line"><a name="l01767"></a><span class="lineno"> 1767</span>&#160;</div><div class="line"><a name="l01768"></a><span class="lineno"> 1768</span>&#160;  // We don&#39;t need to specify an action here, as the default</div><div class="line"><a name="l01769"></a><span class="lineno"> 1769</span>&#160;  // return value works for us.</div><div class="line"><a name="l01770"></a><span class="lineno"> 1770</span>&#160;  EXPECT_CALL(foo, CalculateBar());</div><div class="line"><a name="l01771"></a><span class="lineno"> 1771</span>&#160;</div><div class="line"><a name="l01772"></a><span class="lineno"> 1772</span>&#160;  foo.CalculateBar();  // This should return default_bar.</div><div class="line"><a name="l01773"></a><span class="lineno"> 1773</span>&#160;</div><div class="line"><a name="l01774"></a><span class="lineno"> 1774</span>&#160;  // Unsets the default return value.</div><div class="line"><a name="l01775"></a><span class="lineno"> 1775</span>&#160;  DefaultValue&lt;Bar&gt;::Clear();</div><div class="line"><a name="l01776"></a><span class="lineno"> 1776</span>&#160;```</div><div class="line"><a name="l01777"></a><span class="lineno"> 1777</span>&#160;</div><div class="line"><a name="l01778"></a><span class="lineno"> 1778</span>&#160;Please note that changing the default value for a type can make you</div><div class="line"><a name="l01779"></a><span class="lineno"> 1779</span>&#160;tests hard to understand. We recommend you to use this feature</div><div class="line"><a name="l01780"></a><span class="lineno"> 1780</span>&#160;judiciously. For example, you may want to make sure the `Set()` and</div><div class="line"><a name="l01781"></a><span class="lineno"> 1781</span>&#160;`Clear()` calls are right next to the code that uses your mock.</div><div class="line"><a name="l01782"></a><span class="lineno"> 1782</span>&#160;</div><div class="line"><a name="l01783"></a><span class="lineno"> 1783</span>&#160;## Setting the Default Actions for a Mock Method ##</div><div class="line"><a name="l01784"></a><span class="lineno"> 1784</span>&#160;</div><div class="line"><a name="l01785"></a><span class="lineno"> 1785</span>&#160;You&#39;ve learned how to change the default value of a given</div><div class="line"><a name="l01786"></a><span class="lineno"> 1786</span>&#160;type. However, this may be too coarse for your purpose: perhaps you</div><div class="line"><a name="l01787"></a><span class="lineno"> 1787</span>&#160;have two mock methods with the same return type and you want them to</div><div class="line"><a name="l01788"></a><span class="lineno"> 1788</span>&#160;have different behaviors. The `ON_CALL()` macro allows you to</div><div class="line"><a name="l01789"></a><span class="lineno"> 1789</span>&#160;customize your mock&#39;s behavior at the method level:</div><div class="line"><a name="l01790"></a><span class="lineno"> 1790</span>&#160;</div><div class="line"><a name="l01791"></a><span class="lineno"> 1791</span>&#160;```</div><div class="line"><a name="l01792"></a><span class="lineno"> 1792</span>&#160;using ::testing::_;</div><div class="line"><a name="l01793"></a><span class="lineno"> 1793</span>&#160;using ::testing::AnyNumber;</div><div class="line"><a name="l01794"></a><span class="lineno"> 1794</span>&#160;using ::testing::Gt;</div><div class="line"><a name="l01795"></a><span class="lineno"> 1795</span>&#160;using ::testing::Return;</div><div class="line"><a name="l01796"></a><span class="lineno"> 1796</span>&#160;...</div><div class="line"><a name="l01797"></a><span class="lineno"> 1797</span>&#160;  ON_CALL(foo, Sign(_))</div><div class="line"><a name="l01798"></a><span class="lineno"> 1798</span>&#160;      .WillByDefault(Return(-1));</div><div class="line"><a name="l01799"></a><span class="lineno"> 1799</span>&#160;  ON_CALL(foo, Sign(0))</div><div class="line"><a name="l01800"></a><span class="lineno"> 1800</span>&#160;      .WillByDefault(Return(0));</div><div class="line"><a name="l01801"></a><span class="lineno"> 1801</span>&#160;  ON_CALL(foo, Sign(Gt(0)))</div><div class="line"><a name="l01802"></a><span class="lineno"> 1802</span>&#160;      .WillByDefault(Return(1));</div><div class="line"><a name="l01803"></a><span class="lineno"> 1803</span>&#160;</div><div class="line"><a name="l01804"></a><span class="lineno"> 1804</span>&#160;  EXPECT_CALL(foo, Sign(_))</div><div class="line"><a name="l01805"></a><span class="lineno"> 1805</span>&#160;      .Times(AnyNumber());</div><div class="line"><a name="l01806"></a><span class="lineno"> 1806</span>&#160;</div><div class="line"><a name="l01807"></a><span class="lineno"> 1807</span>&#160;  foo.Sign(5);   // This should return 1.</div><div class="line"><a name="l01808"></a><span class="lineno"> 1808</span>&#160;  foo.Sign(-9);  // This should return -1.</div><div class="line"><a name="l01809"></a><span class="lineno"> 1809</span>&#160;  foo.Sign(0);   // This should return 0.</div><div class="line"><a name="l01810"></a><span class="lineno"> 1810</span>&#160;```</div><div class="line"><a name="l01811"></a><span class="lineno"> 1811</span>&#160;</div><div class="line"><a name="l01812"></a><span class="lineno"> 1812</span>&#160;As you may have guessed, when there are more than one `ON_CALL()`</div><div class="line"><a name="l01813"></a><span class="lineno"> 1813</span>&#160;statements, the news order take precedence over the older ones. In</div><div class="line"><a name="l01814"></a><span class="lineno"> 1814</span>&#160;other words, the **last** one that matches the function arguments will</div><div class="line"><a name="l01815"></a><span class="lineno"> 1815</span>&#160;be used. This matching order allows you to set up the common behavior</div><div class="line"><a name="l01816"></a><span class="lineno"> 1816</span>&#160;in a mock object&#39;s constructor or the test fixture&#39;s set-up phase and</div><div class="line"><a name="l01817"></a><span class="lineno"> 1817</span>&#160;specialize the mock&#39;s behavior later.</div><div class="line"><a name="l01818"></a><span class="lineno"> 1818</span>&#160;</div><div class="line"><a name="l01819"></a><span class="lineno"> 1819</span>&#160;## Using Functions/Methods/Functors as Actions ##</div><div class="line"><a name="l01820"></a><span class="lineno"> 1820</span>&#160;</div><div class="line"><a name="l01821"></a><span class="lineno"> 1821</span>&#160;If the built-in actions don&#39;t suit you, you can easily use an existing</div><div class="line"><a name="l01822"></a><span class="lineno"> 1822</span>&#160;function, method, or functor as an action:</div><div class="line"><a name="l01823"></a><span class="lineno"> 1823</span>&#160;</div><div class="line"><a name="l01824"></a><span class="lineno"> 1824</span>&#160;```</div><div class="line"><a name="l01825"></a><span class="lineno"> 1825</span>&#160;using ::testing::_;</div><div class="line"><a name="l01826"></a><span class="lineno"> 1826</span>&#160;using ::testing::Invoke;</div><div class="line"><a name="l01827"></a><span class="lineno"> 1827</span>&#160;</div><div class="line"><a name="l01828"></a><span class="lineno"> 1828</span>&#160;class MockFoo : public Foo {</div><div class="line"><a name="l01829"></a><span class="lineno"> 1829</span>&#160; public:</div><div class="line"><a name="l01830"></a><span class="lineno"> 1830</span>&#160;  MOCK_METHOD2(Sum, int(int x, int y));</div><div class="line"><a name="l01831"></a><span class="lineno"> 1831</span>&#160;  MOCK_METHOD1(ComplexJob, bool(int x));</div><div class="line"><a name="l01832"></a><span class="lineno"> 1832</span>&#160;};</div><div class="line"><a name="l01833"></a><span class="lineno"> 1833</span>&#160;</div><div class="line"><a name="l01834"></a><span class="lineno"> 1834</span>&#160;int CalculateSum(int x, int y) { return x + y; }</div><div class="line"><a name="l01835"></a><span class="lineno"> 1835</span>&#160;</div><div class="line"><a name="l01836"></a><span class="lineno"> 1836</span>&#160;class Helper {</div><div class="line"><a name="l01837"></a><span class="lineno"> 1837</span>&#160; public:</div><div class="line"><a name="l01838"></a><span class="lineno"> 1838</span>&#160;  bool ComplexJob(int x);</div><div class="line"><a name="l01839"></a><span class="lineno"> 1839</span>&#160;};</div><div class="line"><a name="l01840"></a><span class="lineno"> 1840</span>&#160;...</div><div class="line"><a name="l01841"></a><span class="lineno"> 1841</span>&#160;</div><div class="line"><a name="l01842"></a><span class="lineno"> 1842</span>&#160;  MockFoo foo;</div><div class="line"><a name="l01843"></a><span class="lineno"> 1843</span>&#160;  Helper helper;</div><div class="line"><a name="l01844"></a><span class="lineno"> 1844</span>&#160;  EXPECT_CALL(foo, Sum(_, _))</div><div class="line"><a name="l01845"></a><span class="lineno"> 1845</span>&#160;      .WillOnce(Invoke(CalculateSum));</div><div class="line"><a name="l01846"></a><span class="lineno"> 1846</span>&#160;  EXPECT_CALL(foo, ComplexJob(_))</div><div class="line"><a name="l01847"></a><span class="lineno"> 1847</span>&#160;      .WillOnce(Invoke(&amp;helper, &amp;Helper::ComplexJob));</div><div class="line"><a name="l01848"></a><span class="lineno"> 1848</span>&#160;</div><div class="line"><a name="l01849"></a><span class="lineno"> 1849</span>&#160;  foo.Sum(5, 6);       // Invokes CalculateSum(5, 6).</div><div class="line"><a name="l01850"></a><span class="lineno"> 1850</span>&#160;  foo.ComplexJob(10);  // Invokes helper.ComplexJob(10);</div><div class="line"><a name="l01851"></a><span class="lineno"> 1851</span>&#160;```</div><div class="line"><a name="l01852"></a><span class="lineno"> 1852</span>&#160;</div><div class="line"><a name="l01853"></a><span class="lineno"> 1853</span>&#160;The only requirement is that the type of the function, etc must be</div><div class="line"><a name="l01854"></a><span class="lineno"> 1854</span>&#160;_compatible_ with the signature of the mock function, meaning that the</div><div class="line"><a name="l01855"></a><span class="lineno"> 1855</span>&#160;latter&#39;s arguments can be implicitly converted to the corresponding</div><div class="line"><a name="l01856"></a><span class="lineno"> 1856</span>&#160;arguments of the former, and the former&#39;s return type can be</div><div class="line"><a name="l01857"></a><span class="lineno"> 1857</span>&#160;implicitly converted to that of the latter. So, you can invoke</div><div class="line"><a name="l01858"></a><span class="lineno"> 1858</span>&#160;something whose type is _not_ exactly the same as the mock function,</div><div class="line"><a name="l01859"></a><span class="lineno"> 1859</span>&#160;as long as it&#39;s safe to do so - nice, huh?</div><div class="line"><a name="l01860"></a><span class="lineno"> 1860</span>&#160;</div><div class="line"><a name="l01861"></a><span class="lineno"> 1861</span>&#160;## Invoking a Function/Method/Functor Without Arguments ##</div><div class="line"><a name="l01862"></a><span class="lineno"> 1862</span>&#160;</div><div class="line"><a name="l01863"></a><span class="lineno"> 1863</span>&#160;`Invoke()` is very useful for doing actions that are more complex. It</div><div class="line"><a name="l01864"></a><span class="lineno"> 1864</span>&#160;passes the mock function&#39;s arguments to the function or functor being</div><div class="line"><a name="l01865"></a><span class="lineno"> 1865</span>&#160;invoked such that the callee has the full context of the call to work</div><div class="line"><a name="l01866"></a><span class="lineno"> 1866</span>&#160;with. If the invoked function is not interested in some or all of the</div><div class="line"><a name="l01867"></a><span class="lineno"> 1867</span>&#160;arguments, it can simply ignore them.</div><div class="line"><a name="l01868"></a><span class="lineno"> 1868</span>&#160;</div><div class="line"><a name="l01869"></a><span class="lineno"> 1869</span>&#160;Yet, a common pattern is that a test author wants to invoke a function</div><div class="line"><a name="l01870"></a><span class="lineno"> 1870</span>&#160;without the arguments of the mock function. `Invoke()` allows her to</div><div class="line"><a name="l01871"></a><span class="lineno"> 1871</span>&#160;do that using a wrapper function that throws away the arguments before</div><div class="line"><a name="l01872"></a><span class="lineno"> 1872</span>&#160;invoking an underlining nullary function. Needless to say, this can be</div><div class="line"><a name="l01873"></a><span class="lineno"> 1873</span>&#160;tedious and obscures the intent of the test.</div><div class="line"><a name="l01874"></a><span class="lineno"> 1874</span>&#160;</div><div class="line"><a name="l01875"></a><span class="lineno"> 1875</span>&#160;`InvokeWithoutArgs()` solves this problem. It&#39;s like `Invoke()` except</div><div class="line"><a name="l01876"></a><span class="lineno"> 1876</span>&#160;that it doesn&#39;t pass the mock function&#39;s arguments to the</div><div class="line"><a name="l01877"></a><span class="lineno"> 1877</span>&#160;callee. Here&#39;s an example:</div><div class="line"><a name="l01878"></a><span class="lineno"> 1878</span>&#160;</div><div class="line"><a name="l01879"></a><span class="lineno"> 1879</span>&#160;```</div><div class="line"><a name="l01880"></a><span class="lineno"> 1880</span>&#160;using ::testing::_;</div><div class="line"><a name="l01881"></a><span class="lineno"> 1881</span>&#160;using ::testing::InvokeWithoutArgs;</div><div class="line"><a name="l01882"></a><span class="lineno"> 1882</span>&#160;</div><div class="line"><a name="l01883"></a><span class="lineno"> 1883</span>&#160;class MockFoo : public Foo {</div><div class="line"><a name="l01884"></a><span class="lineno"> 1884</span>&#160; public:</div><div class="line"><a name="l01885"></a><span class="lineno"> 1885</span>&#160;  MOCK_METHOD1(ComplexJob, bool(int n));</div><div class="line"><a name="l01886"></a><span class="lineno"> 1886</span>&#160;};</div><div class="line"><a name="l01887"></a><span class="lineno"> 1887</span>&#160;</div><div class="line"><a name="l01888"></a><span class="lineno"> 1888</span>&#160;bool Job1() { ... }</div><div class="line"><a name="l01889"></a><span class="lineno"> 1889</span>&#160;...</div><div class="line"><a name="l01890"></a><span class="lineno"> 1890</span>&#160;</div><div class="line"><a name="l01891"></a><span class="lineno"> 1891</span>&#160;  MockFoo foo;</div><div class="line"><a name="l01892"></a><span class="lineno"> 1892</span>&#160;  EXPECT_CALL(foo, ComplexJob(_))</div><div class="line"><a name="l01893"></a><span class="lineno"> 1893</span>&#160;      .WillOnce(InvokeWithoutArgs(Job1));</div><div class="line"><a name="l01894"></a><span class="lineno"> 1894</span>&#160;</div><div class="line"><a name="l01895"></a><span class="lineno"> 1895</span>&#160;  foo.ComplexJob(10);  // Invokes Job1().</div><div class="line"><a name="l01896"></a><span class="lineno"> 1896</span>&#160;```</div><div class="line"><a name="l01897"></a><span class="lineno"> 1897</span>&#160;</div><div class="line"><a name="l01898"></a><span class="lineno"> 1898</span>&#160;## Invoking an Argument of the Mock Function ##</div><div class="line"><a name="l01899"></a><span class="lineno"> 1899</span>&#160;</div><div class="line"><a name="l01900"></a><span class="lineno"> 1900</span>&#160;Sometimes a mock function will receive a function pointer or a functor</div><div class="line"><a name="l01901"></a><span class="lineno"> 1901</span>&#160;(in other words, a &quot;callable&quot;) as an argument, e.g.</div><div class="line"><a name="l01902"></a><span class="lineno"> 1902</span>&#160;</div><div class="line"><a name="l01903"></a><span class="lineno"> 1903</span>&#160;```</div><div class="line"><a name="l01904"></a><span class="lineno"> 1904</span>&#160;class MockFoo : public Foo {</div><div class="line"><a name="l01905"></a><span class="lineno"> 1905</span>&#160; public:</div><div class="line"><a name="l01906"></a><span class="lineno"> 1906</span>&#160;  MOCK_METHOD2(DoThis, bool(int n, bool (*fp)(int)));</div><div class="line"><a name="l01907"></a><span class="lineno"> 1907</span>&#160;};</div><div class="line"><a name="l01908"></a><span class="lineno"> 1908</span>&#160;```</div><div class="line"><a name="l01909"></a><span class="lineno"> 1909</span>&#160;</div><div class="line"><a name="l01910"></a><span class="lineno"> 1910</span>&#160;and you may want to invoke this callable argument:</div><div class="line"><a name="l01911"></a><span class="lineno"> 1911</span>&#160;</div><div class="line"><a name="l01912"></a><span class="lineno"> 1912</span>&#160;```</div><div class="line"><a name="l01913"></a><span class="lineno"> 1913</span>&#160;using ::testing::_;</div><div class="line"><a name="l01914"></a><span class="lineno"> 1914</span>&#160;...</div><div class="line"><a name="l01915"></a><span class="lineno"> 1915</span>&#160;  MockFoo foo;</div><div class="line"><a name="l01916"></a><span class="lineno"> 1916</span>&#160;  EXPECT_CALL(foo, DoThis(_, _))</div><div class="line"><a name="l01917"></a><span class="lineno"> 1917</span>&#160;      .WillOnce(...);</div><div class="line"><a name="l01918"></a><span class="lineno"> 1918</span>&#160;  // Will execute (*fp)(5), where fp is the</div><div class="line"><a name="l01919"></a><span class="lineno"> 1919</span>&#160;  // second argument DoThis() receives.</div><div class="line"><a name="l01920"></a><span class="lineno"> 1920</span>&#160;```</div><div class="line"><a name="l01921"></a><span class="lineno"> 1921</span>&#160;</div><div class="line"><a name="l01922"></a><span class="lineno"> 1922</span>&#160;Arghh, you need to refer to a mock function argument but C++ has no</div><div class="line"><a name="l01923"></a><span class="lineno"> 1923</span>&#160;lambda (yet), so you have to define your own action. :-( Or do you</div><div class="line"><a name="l01924"></a><span class="lineno"> 1924</span>&#160;really?</div><div class="line"><a name="l01925"></a><span class="lineno"> 1925</span>&#160;</div><div class="line"><a name="l01926"></a><span class="lineno"> 1926</span>&#160;Well, Google Mock has an action to solve _exactly_ this problem:</div><div class="line"><a name="l01927"></a><span class="lineno"> 1927</span>&#160;</div><div class="line"><a name="l01928"></a><span class="lineno"> 1928</span>&#160;```</div><div class="line"><a name="l01929"></a><span class="lineno"> 1929</span>&#160;  InvokeArgument&lt;N&gt;(arg_1, arg_2, ..., arg_m)</div><div class="line"><a name="l01930"></a><span class="lineno"> 1930</span>&#160;```</div><div class="line"><a name="l01931"></a><span class="lineno"> 1931</span>&#160;</div><div class="line"><a name="l01932"></a><span class="lineno"> 1932</span>&#160;will invoke the `N`-th (0-based) argument the mock function receives,</div><div class="line"><a name="l01933"></a><span class="lineno"> 1933</span>&#160;with `arg_1`, `arg_2`, ..., and `arg_m`. No matter if the argument is</div><div class="line"><a name="l01934"></a><span class="lineno"> 1934</span>&#160;a function pointer or a functor, Google Mock handles them both.</div><div class="line"><a name="l01935"></a><span class="lineno"> 1935</span>&#160;</div><div class="line"><a name="l01936"></a><span class="lineno"> 1936</span>&#160;With that, you could write:</div><div class="line"><a name="l01937"></a><span class="lineno"> 1937</span>&#160;</div><div class="line"><a name="l01938"></a><span class="lineno"> 1938</span>&#160;```</div><div class="line"><a name="l01939"></a><span class="lineno"> 1939</span>&#160;using ::testing::_;</div><div class="line"><a name="l01940"></a><span class="lineno"> 1940</span>&#160;using ::testing::InvokeArgument;</div><div class="line"><a name="l01941"></a><span class="lineno"> 1941</span>&#160;...</div><div class="line"><a name="l01942"></a><span class="lineno"> 1942</span>&#160;  EXPECT_CALL(foo, DoThis(_, _))</div><div class="line"><a name="l01943"></a><span class="lineno"> 1943</span>&#160;      .WillOnce(InvokeArgument&lt;1&gt;(5));</div><div class="line"><a name="l01944"></a><span class="lineno"> 1944</span>&#160;  // Will execute (*fp)(5), where fp is the</div><div class="line"><a name="l01945"></a><span class="lineno"> 1945</span>&#160;  // second argument DoThis() receives.</div><div class="line"><a name="l01946"></a><span class="lineno"> 1946</span>&#160;```</div><div class="line"><a name="l01947"></a><span class="lineno"> 1947</span>&#160;</div><div class="line"><a name="l01948"></a><span class="lineno"> 1948</span>&#160;What if the callable takes an argument by reference? No problem - just</div><div class="line"><a name="l01949"></a><span class="lineno"> 1949</span>&#160;wrap it inside `ByRef()`:</div><div class="line"><a name="l01950"></a><span class="lineno"> 1950</span>&#160;</div><div class="line"><a name="l01951"></a><span class="lineno"> 1951</span>&#160;```</div><div class="line"><a name="l01952"></a><span class="lineno"> 1952</span>&#160;...</div><div class="line"><a name="l01953"></a><span class="lineno"> 1953</span>&#160;  MOCK_METHOD1(Bar, bool(bool (*fp)(int, const Helper&amp;)));</div><div class="line"><a name="l01954"></a><span class="lineno"> 1954</span>&#160;...</div><div class="line"><a name="l01955"></a><span class="lineno"> 1955</span>&#160;using ::testing::_;</div><div class="line"><a name="l01956"></a><span class="lineno"> 1956</span>&#160;using ::testing::ByRef;</div><div class="line"><a name="l01957"></a><span class="lineno"> 1957</span>&#160;using ::testing::InvokeArgument;</div><div class="line"><a name="l01958"></a><span class="lineno"> 1958</span>&#160;...</div><div class="line"><a name="l01959"></a><span class="lineno"> 1959</span>&#160;</div><div class="line"><a name="l01960"></a><span class="lineno"> 1960</span>&#160;  MockFoo foo;</div><div class="line"><a name="l01961"></a><span class="lineno"> 1961</span>&#160;  Helper helper;</div><div class="line"><a name="l01962"></a><span class="lineno"> 1962</span>&#160;  ...</div><div class="line"><a name="l01963"></a><span class="lineno"> 1963</span>&#160;  EXPECT_CALL(foo, Bar(_))</div><div class="line"><a name="l01964"></a><span class="lineno"> 1964</span>&#160;      .WillOnce(InvokeArgument&lt;0&gt;(5, ByRef(helper)));</div><div class="line"><a name="l01965"></a><span class="lineno"> 1965</span>&#160;  // ByRef(helper) guarantees that a reference to helper, not a copy of it,</div><div class="line"><a name="l01966"></a><span class="lineno"> 1966</span>&#160;  // will be passed to the callable.</div><div class="line"><a name="l01967"></a><span class="lineno"> 1967</span>&#160;```</div><div class="line"><a name="l01968"></a><span class="lineno"> 1968</span>&#160;</div><div class="line"><a name="l01969"></a><span class="lineno"> 1969</span>&#160;What if the callable takes an argument by reference and we do **not**</div><div class="line"><a name="l01970"></a><span class="lineno"> 1970</span>&#160;wrap the argument in `ByRef()`? Then `InvokeArgument()` will _make a</div><div class="line"><a name="l01971"></a><span class="lineno"> 1971</span>&#160;copy_ of the argument, and pass a _reference to the copy_, instead of</div><div class="line"><a name="l01972"></a><span class="lineno"> 1972</span>&#160;a reference to the original value, to the callable. This is especially</div><div class="line"><a name="l01973"></a><span class="lineno"> 1973</span>&#160;handy when the argument is a temporary value:</div><div class="line"><a name="l01974"></a><span class="lineno"> 1974</span>&#160;</div><div class="line"><a name="l01975"></a><span class="lineno"> 1975</span>&#160;```</div><div class="line"><a name="l01976"></a><span class="lineno"> 1976</span>&#160;...</div><div class="line"><a name="l01977"></a><span class="lineno"> 1977</span>&#160;  MOCK_METHOD1(DoThat, bool(bool (*f)(const double&amp; x, const string&amp; s)));</div><div class="line"><a name="l01978"></a><span class="lineno"> 1978</span>&#160;...</div><div class="line"><a name="l01979"></a><span class="lineno"> 1979</span>&#160;using ::testing::_;</div><div class="line"><a name="l01980"></a><span class="lineno"> 1980</span>&#160;using ::testing::InvokeArgument;</div><div class="line"><a name="l01981"></a><span class="lineno"> 1981</span>&#160;...</div><div class="line"><a name="l01982"></a><span class="lineno"> 1982</span>&#160;</div><div class="line"><a name="l01983"></a><span class="lineno"> 1983</span>&#160;  MockFoo foo;</div><div class="line"><a name="l01984"></a><span class="lineno"> 1984</span>&#160;  ...</div><div class="line"><a name="l01985"></a><span class="lineno"> 1985</span>&#160;  EXPECT_CALL(foo, DoThat(_))</div><div class="line"><a name="l01986"></a><span class="lineno"> 1986</span>&#160;      .WillOnce(InvokeArgument&lt;0&gt;(5.0, string(&quot;Hi&quot;)));</div><div class="line"><a name="l01987"></a><span class="lineno"> 1987</span>&#160;  // Will execute (*f)(5.0, string(&quot;Hi&quot;)), where f is the function pointer</div><div class="line"><a name="l01988"></a><span class="lineno"> 1988</span>&#160;  // DoThat() receives.  Note that the values 5.0 and string(&quot;Hi&quot;) are</div><div class="line"><a name="l01989"></a><span class="lineno"> 1989</span>&#160;  // temporary and dead once the EXPECT_CALL() statement finishes.  Yet</div><div class="line"><a name="l01990"></a><span class="lineno"> 1990</span>&#160;  // it&#39;s fine to perform this action later, since a copy of the values</div><div class="line"><a name="l01991"></a><span class="lineno"> 1991</span>&#160;  // are kept inside the InvokeArgument action.</div><div class="line"><a name="l01992"></a><span class="lineno"> 1992</span>&#160;```</div><div class="line"><a name="l01993"></a><span class="lineno"> 1993</span>&#160;</div><div class="line"><a name="l01994"></a><span class="lineno"> 1994</span>&#160;## Ignoring an Action&#39;s Result ##</div><div class="line"><a name="l01995"></a><span class="lineno"> 1995</span>&#160;</div><div class="line"><a name="l01996"></a><span class="lineno"> 1996</span>&#160;Sometimes you have an action that returns _something_, but you need an</div><div class="line"><a name="l01997"></a><span class="lineno"> 1997</span>&#160;action that returns `void` (perhaps you want to use it in a mock</div><div class="line"><a name="l01998"></a><span class="lineno"> 1998</span>&#160;function that returns `void`, or perhaps it needs to be used in</div><div class="line"><a name="l01999"></a><span class="lineno"> 1999</span>&#160;`DoAll()` and it&#39;s not the last in the list). `IgnoreResult()` lets</div><div class="line"><a name="l02000"></a><span class="lineno"> 2000</span>&#160;you do that. For example:</div><div class="line"><a name="l02001"></a><span class="lineno"> 2001</span>&#160;</div><div class="line"><a name="l02002"></a><span class="lineno"> 2002</span>&#160;```</div><div class="line"><a name="l02003"></a><span class="lineno"> 2003</span>&#160;using ::testing::_;</div><div class="line"><a name="l02004"></a><span class="lineno"> 2004</span>&#160;using ::testing::Invoke;</div><div class="line"><a name="l02005"></a><span class="lineno"> 2005</span>&#160;using ::testing::Return;</div><div class="line"><a name="l02006"></a><span class="lineno"> 2006</span>&#160;</div><div class="line"><a name="l02007"></a><span class="lineno"> 2007</span>&#160;int Process(const MyData&amp; data);</div><div class="line"><a name="l02008"></a><span class="lineno"> 2008</span>&#160;string DoSomething();</div><div class="line"><a name="l02009"></a><span class="lineno"> 2009</span>&#160;</div><div class="line"><a name="l02010"></a><span class="lineno"> 2010</span>&#160;class MockFoo : public Foo {</div><div class="line"><a name="l02011"></a><span class="lineno"> 2011</span>&#160; public:</div><div class="line"><a name="l02012"></a><span class="lineno"> 2012</span>&#160;  MOCK_METHOD1(Abc, void(const MyData&amp; data));</div><div class="line"><a name="l02013"></a><span class="lineno"> 2013</span>&#160;  MOCK_METHOD0(Xyz, bool());</div><div class="line"><a name="l02014"></a><span class="lineno"> 2014</span>&#160;};</div><div class="line"><a name="l02015"></a><span class="lineno"> 2015</span>&#160;...</div><div class="line"><a name="l02016"></a><span class="lineno"> 2016</span>&#160;</div><div class="line"><a name="l02017"></a><span class="lineno"> 2017</span>&#160;  MockFoo foo;</div><div class="line"><a name="l02018"></a><span class="lineno"> 2018</span>&#160;  EXPECT_CALL(foo, Abc(_))</div><div class="line"><a name="l02019"></a><span class="lineno"> 2019</span>&#160;  // .WillOnce(Invoke(Process));</div><div class="line"><a name="l02020"></a><span class="lineno"> 2020</span>&#160;  // The above line won&#39;t compile as Process() returns int but Abc() needs</div><div class="line"><a name="l02021"></a><span class="lineno"> 2021</span>&#160;  // to return void.</div><div class="line"><a name="l02022"></a><span class="lineno"> 2022</span>&#160;      .WillOnce(IgnoreResult(Invoke(Process)));</div><div class="line"><a name="l02023"></a><span class="lineno"> 2023</span>&#160;</div><div class="line"><a name="l02024"></a><span class="lineno"> 2024</span>&#160;  EXPECT_CALL(foo, Xyz())</div><div class="line"><a name="l02025"></a><span class="lineno"> 2025</span>&#160;      .WillOnce(DoAll(IgnoreResult(Invoke(DoSomething)),</div><div class="line"><a name="l02026"></a><span class="lineno"> 2026</span>&#160;      // Ignores the string DoSomething() returns.</div><div class="line"><a name="l02027"></a><span class="lineno"> 2027</span>&#160;                      Return(true)));</div><div class="line"><a name="l02028"></a><span class="lineno"> 2028</span>&#160;```</div><div class="line"><a name="l02029"></a><span class="lineno"> 2029</span>&#160;</div><div class="line"><a name="l02030"></a><span class="lineno"> 2030</span>&#160;Note that you **cannot** use `IgnoreResult()` on an action that already</div><div class="line"><a name="l02031"></a><span class="lineno"> 2031</span>&#160;returns `void`. Doing so will lead to ugly compiler errors.</div><div class="line"><a name="l02032"></a><span class="lineno"> 2032</span>&#160;</div><div class="line"><a name="l02033"></a><span class="lineno"> 2033</span>&#160;## Selecting an Action&#39;s Arguments ##</div><div class="line"><a name="l02034"></a><span class="lineno"> 2034</span>&#160;</div><div class="line"><a name="l02035"></a><span class="lineno"> 2035</span>&#160;Say you have a mock function `Foo()` that takes seven arguments, and</div><div class="line"><a name="l02036"></a><span class="lineno"> 2036</span>&#160;you have a custom action that you want to invoke when `Foo()` is</div><div class="line"><a name="l02037"></a><span class="lineno"> 2037</span>&#160;called. Trouble is, the custom action only wants three arguments:</div><div class="line"><a name="l02038"></a><span class="lineno"> 2038</span>&#160;</div><div class="line"><a name="l02039"></a><span class="lineno"> 2039</span>&#160;```</div><div class="line"><a name="l02040"></a><span class="lineno"> 2040</span>&#160;using ::testing::_;</div><div class="line"><a name="l02041"></a><span class="lineno"> 2041</span>&#160;using ::testing::Invoke;</div><div class="line"><a name="l02042"></a><span class="lineno"> 2042</span>&#160;...</div><div class="line"><a name="l02043"></a><span class="lineno"> 2043</span>&#160;  MOCK_METHOD7(Foo, bool(bool visible, const string&amp; name, int x, int y,</div><div class="line"><a name="l02044"></a><span class="lineno"> 2044</span>&#160;                         const map&lt;pair&lt;int, int&gt;, double&gt;&amp; weight,</div><div class="line"><a name="l02045"></a><span class="lineno"> 2045</span>&#160;                         double min_weight, double max_wight));</div><div class="line"><a name="l02046"></a><span class="lineno"> 2046</span>&#160;...</div><div class="line"><a name="l02047"></a><span class="lineno"> 2047</span>&#160;</div><div class="line"><a name="l02048"></a><span class="lineno"> 2048</span>&#160;bool IsVisibleInQuadrant1(bool visible, int x, int y) {</div><div class="line"><a name="l02049"></a><span class="lineno"> 2049</span>&#160;  return visible &amp;&amp; x &gt;= 0 &amp;&amp; y &gt;= 0;</div><div class="line"><a name="l02050"></a><span class="lineno"> 2050</span>&#160;}</div><div class="line"><a name="l02051"></a><span class="lineno"> 2051</span>&#160;...</div><div class="line"><a name="l02052"></a><span class="lineno"> 2052</span>&#160;</div><div class="line"><a name="l02053"></a><span class="lineno"> 2053</span>&#160;  EXPECT_CALL(mock, Foo(_, _, _, _, _, _, _))</div><div class="line"><a name="l02054"></a><span class="lineno"> 2054</span>&#160;      .WillOnce(Invoke(IsVisibleInQuadrant1));  // Uh, won&#39;t compile. :-(</div><div class="line"><a name="l02055"></a><span class="lineno"> 2055</span>&#160;```</div><div class="line"><a name="l02056"></a><span class="lineno"> 2056</span>&#160;</div><div class="line"><a name="l02057"></a><span class="lineno"> 2057</span>&#160;To please the compiler God, you can to define an &quot;adaptor&quot; that has</div><div class="line"><a name="l02058"></a><span class="lineno"> 2058</span>&#160;the same signature as `Foo()` and calls the custom action with the</div><div class="line"><a name="l02059"></a><span class="lineno"> 2059</span>&#160;right arguments:</div><div class="line"><a name="l02060"></a><span class="lineno"> 2060</span>&#160;</div><div class="line"><a name="l02061"></a><span class="lineno"> 2061</span>&#160;```</div><div class="line"><a name="l02062"></a><span class="lineno"> 2062</span>&#160;using ::testing::_;</div><div class="line"><a name="l02063"></a><span class="lineno"> 2063</span>&#160;using ::testing::Invoke;</div><div class="line"><a name="l02064"></a><span class="lineno"> 2064</span>&#160;</div><div class="line"><a name="l02065"></a><span class="lineno"> 2065</span>&#160;bool MyIsVisibleInQuadrant1(bool visible, const string&amp; name, int x, int y,</div><div class="line"><a name="l02066"></a><span class="lineno"> 2066</span>&#160;                            const map&lt;pair&lt;int, int&gt;, double&gt;&amp; weight,</div><div class="line"><a name="l02067"></a><span class="lineno"> 2067</span>&#160;                            double min_weight, double max_wight) {</div><div class="line"><a name="l02068"></a><span class="lineno"> 2068</span>&#160;  return IsVisibleInQuadrant1(visible, x, y);</div><div class="line"><a name="l02069"></a><span class="lineno"> 2069</span>&#160;}</div><div class="line"><a name="l02070"></a><span class="lineno"> 2070</span>&#160;...</div><div class="line"><a name="l02071"></a><span class="lineno"> 2071</span>&#160;</div><div class="line"><a name="l02072"></a><span class="lineno"> 2072</span>&#160;  EXPECT_CALL(mock, Foo(_, _, _, _, _, _, _))</div><div class="line"><a name="l02073"></a><span class="lineno"> 2073</span>&#160;      .WillOnce(Invoke(MyIsVisibleInQuadrant1));  // Now it works.</div><div class="line"><a name="l02074"></a><span class="lineno"> 2074</span>&#160;```</div><div class="line"><a name="l02075"></a><span class="lineno"> 2075</span>&#160;</div><div class="line"><a name="l02076"></a><span class="lineno"> 2076</span>&#160;But isn&#39;t this awkward?</div><div class="line"><a name="l02077"></a><span class="lineno"> 2077</span>&#160;</div><div class="line"><a name="l02078"></a><span class="lineno"> 2078</span>&#160;Google Mock provides a generic _action adaptor_, so you can spend your</div><div class="line"><a name="l02079"></a><span class="lineno"> 2079</span>&#160;time minding more important business than writing your own</div><div class="line"><a name="l02080"></a><span class="lineno"> 2080</span>&#160;adaptors. Here&#39;s the syntax:</div><div class="line"><a name="l02081"></a><span class="lineno"> 2081</span>&#160;</div><div class="line"><a name="l02082"></a><span class="lineno"> 2082</span>&#160;```</div><div class="line"><a name="l02083"></a><span class="lineno"> 2083</span>&#160;  WithArgs&lt;N1, N2, ..., Nk&gt;(action)</div><div class="line"><a name="l02084"></a><span class="lineno"> 2084</span>&#160;```</div><div class="line"><a name="l02085"></a><span class="lineno"> 2085</span>&#160;</div><div class="line"><a name="l02086"></a><span class="lineno"> 2086</span>&#160;creates an action that passes the arguments of the mock function at</div><div class="line"><a name="l02087"></a><span class="lineno"> 2087</span>&#160;the given indices (0-based) to the inner `action` and performs</div><div class="line"><a name="l02088"></a><span class="lineno"> 2088</span>&#160;it. Using `WithArgs`, our original example can be written as:</div><div class="line"><a name="l02089"></a><span class="lineno"> 2089</span>&#160;</div><div class="line"><a name="l02090"></a><span class="lineno"> 2090</span>&#160;```</div><div class="line"><a name="l02091"></a><span class="lineno"> 2091</span>&#160;using ::testing::_;</div><div class="line"><a name="l02092"></a><span class="lineno"> 2092</span>&#160;using ::testing::Invoke;</div><div class="line"><a name="l02093"></a><span class="lineno"> 2093</span>&#160;using ::testing::WithArgs;</div><div class="line"><a name="l02094"></a><span class="lineno"> 2094</span>&#160;...</div><div class="line"><a name="l02095"></a><span class="lineno"> 2095</span>&#160;  EXPECT_CALL(mock, Foo(_, _, _, _, _, _, _))</div><div class="line"><a name="l02096"></a><span class="lineno"> 2096</span>&#160;      .WillOnce(WithArgs&lt;0, 2, 3&gt;(Invoke(IsVisibleInQuadrant1)));</div><div class="line"><a name="l02097"></a><span class="lineno"> 2097</span>&#160;      // No need to define your own adaptor.</div><div class="line"><a name="l02098"></a><span class="lineno"> 2098</span>&#160;```</div><div class="line"><a name="l02099"></a><span class="lineno"> 2099</span>&#160;</div><div class="line"><a name="l02100"></a><span class="lineno"> 2100</span>&#160;For better readability, Google Mock also gives you:</div><div class="line"><a name="l02101"></a><span class="lineno"> 2101</span>&#160;</div><div class="line"><a name="l02102"></a><span class="lineno"> 2102</span>&#160;  * `WithoutArgs(action)` when the inner `action` takes _no_ argument, and</div><div class="line"><a name="l02103"></a><span class="lineno"> 2103</span>&#160;  * `WithArg&lt;N&gt;(action)` (no `s` after `Arg`) when the inner `action` takes _one_ argument.</div><div class="line"><a name="l02104"></a><span class="lineno"> 2104</span>&#160;</div><div class="line"><a name="l02105"></a><span class="lineno"> 2105</span>&#160;As you may have realized, `InvokeWithoutArgs(...)` is just syntactic</div><div class="line"><a name="l02106"></a><span class="lineno"> 2106</span>&#160;sugar for `WithoutArgs(Invoke(...))`.</div><div class="line"><a name="l02107"></a><span class="lineno"> 2107</span>&#160;</div><div class="line"><a name="l02108"></a><span class="lineno"> 2108</span>&#160;Here are more tips:</div><div class="line"><a name="l02109"></a><span class="lineno"> 2109</span>&#160;</div><div class="line"><a name="l02110"></a><span class="lineno"> 2110</span>&#160;  * The inner action used in `WithArgs` and friends does not have to be `Invoke()` -- it can be anything.</div><div class="line"><a name="l02111"></a><span class="lineno"> 2111</span>&#160;  * You can repeat an argument in the argument list if necessary, e.g. `WithArgs&lt;2, 3, 3, 5&gt;(...)`.</div><div class="line"><a name="l02112"></a><span class="lineno"> 2112</span>&#160;  * You can change the order of the arguments, e.g. `WithArgs&lt;3, 2, 1&gt;(...)`.</div><div class="line"><a name="l02113"></a><span class="lineno"> 2113</span>&#160;  * The types of the selected arguments do _not_ have to match the signature of the inner action exactly. It works as long as they can be implicitly converted to the corresponding arguments of the inner action. For example, if the 4-th argument of the mock function is an `int` and `my_action` takes a `double`, `WithArg&lt;4&gt;(my_action)` will work.</div><div class="line"><a name="l02114"></a><span class="lineno"> 2114</span>&#160;</div><div class="line"><a name="l02115"></a><span class="lineno"> 2115</span>&#160;## Ignoring Arguments in Action Functions ##</div><div class="line"><a name="l02116"></a><span class="lineno"> 2116</span>&#160;</div><div class="line"><a name="l02117"></a><span class="lineno"> 2117</span>&#160;The selecting-an-action&#39;s-arguments recipe showed us one way to make a</div><div class="line"><a name="l02118"></a><span class="lineno"> 2118</span>&#160;mock function and an action with incompatible argument lists fit</div><div class="line"><a name="l02119"></a><span class="lineno"> 2119</span>&#160;together. The downside is that wrapping the action in</div><div class="line"><a name="l02120"></a><span class="lineno"> 2120</span>&#160;`WithArgs&lt;...&gt;()` can get tedious for people writing the tests.</div><div class="line"><a name="l02121"></a><span class="lineno"> 2121</span>&#160;</div><div class="line"><a name="l02122"></a><span class="lineno"> 2122</span>&#160;If you are defining a function, method, or functor to be used with</div><div class="line"><a name="l02123"></a><span class="lineno"> 2123</span>&#160;`Invoke*()`, and you are not interested in some of its arguments, an</div><div class="line"><a name="l02124"></a><span class="lineno"> 2124</span>&#160;alternative to `WithArgs` is to declare the uninteresting arguments as</div><div class="line"><a name="l02125"></a><span class="lineno"> 2125</span>&#160;`Unused`. This makes the definition less cluttered and less fragile in</div><div class="line"><a name="l02126"></a><span class="lineno"> 2126</span>&#160;case the types of the uninteresting arguments change. It could also</div><div class="line"><a name="l02127"></a><span class="lineno"> 2127</span>&#160;increase the chance the action function can be reused. For example,</div><div class="line"><a name="l02128"></a><span class="lineno"> 2128</span>&#160;given</div><div class="line"><a name="l02129"></a><span class="lineno"> 2129</span>&#160;</div><div class="line"><a name="l02130"></a><span class="lineno"> 2130</span>&#160;```</div><div class="line"><a name="l02131"></a><span class="lineno"> 2131</span>&#160;  MOCK_METHOD3(Foo, double(const string&amp; label, double x, double y));</div><div class="line"><a name="l02132"></a><span class="lineno"> 2132</span>&#160;  MOCK_METHOD3(Bar, double(int index, double x, double y));</div><div class="line"><a name="l02133"></a><span class="lineno"> 2133</span>&#160;```</div><div class="line"><a name="l02134"></a><span class="lineno"> 2134</span>&#160;</div><div class="line"><a name="l02135"></a><span class="lineno"> 2135</span>&#160;instead of</div><div class="line"><a name="l02136"></a><span class="lineno"> 2136</span>&#160;</div><div class="line"><a name="l02137"></a><span class="lineno"> 2137</span>&#160;```</div><div class="line"><a name="l02138"></a><span class="lineno"> 2138</span>&#160;using ::testing::_;</div><div class="line"><a name="l02139"></a><span class="lineno"> 2139</span>&#160;using ::testing::Invoke;</div><div class="line"><a name="l02140"></a><span class="lineno"> 2140</span>&#160;</div><div class="line"><a name="l02141"></a><span class="lineno"> 2141</span>&#160;double DistanceToOriginWithLabel(const string&amp; label, double x, double y) {</div><div class="line"><a name="l02142"></a><span class="lineno"> 2142</span>&#160;  return sqrt(x*x + y*y);</div><div class="line"><a name="l02143"></a><span class="lineno"> 2143</span>&#160;}</div><div class="line"><a name="l02144"></a><span class="lineno"> 2144</span>&#160;</div><div class="line"><a name="l02145"></a><span class="lineno"> 2145</span>&#160;double DistanceToOriginWithIndex(int index, double x, double y) {</div><div class="line"><a name="l02146"></a><span class="lineno"> 2146</span>&#160;  return sqrt(x*x + y*y);</div><div class="line"><a name="l02147"></a><span class="lineno"> 2147</span>&#160;}</div><div class="line"><a name="l02148"></a><span class="lineno"> 2148</span>&#160;...</div><div class="line"><a name="l02149"></a><span class="lineno"> 2149</span>&#160;</div><div class="line"><a name="l02150"></a><span class="lineno"> 2150</span>&#160;  EXEPCT_CALL(mock, Foo(&quot;abc&quot;, _, _))</div><div class="line"><a name="l02151"></a><span class="lineno"> 2151</span>&#160;      .WillOnce(Invoke(DistanceToOriginWithLabel));</div><div class="line"><a name="l02152"></a><span class="lineno"> 2152</span>&#160;  EXEPCT_CALL(mock, Bar(5, _, _))</div><div class="line"><a name="l02153"></a><span class="lineno"> 2153</span>&#160;      .WillOnce(Invoke(DistanceToOriginWithIndex));</div><div class="line"><a name="l02154"></a><span class="lineno"> 2154</span>&#160;```</div><div class="line"><a name="l02155"></a><span class="lineno"> 2155</span>&#160;</div><div class="line"><a name="l02156"></a><span class="lineno"> 2156</span>&#160;you could write</div><div class="line"><a name="l02157"></a><span class="lineno"> 2157</span>&#160;</div><div class="line"><a name="l02158"></a><span class="lineno"> 2158</span>&#160;```</div><div class="line"><a name="l02159"></a><span class="lineno"> 2159</span>&#160;using ::testing::_;</div><div class="line"><a name="l02160"></a><span class="lineno"> 2160</span>&#160;using ::testing::Invoke;</div><div class="line"><a name="l02161"></a><span class="lineno"> 2161</span>&#160;using ::testing::Unused;</div><div class="line"><a name="l02162"></a><span class="lineno"> 2162</span>&#160;</div><div class="line"><a name="l02163"></a><span class="lineno"> 2163</span>&#160;double DistanceToOrigin(Unused, double x, double y) {</div><div class="line"><a name="l02164"></a><span class="lineno"> 2164</span>&#160;  return sqrt(x*x + y*y);</div><div class="line"><a name="l02165"></a><span class="lineno"> 2165</span>&#160;}</div><div class="line"><a name="l02166"></a><span class="lineno"> 2166</span>&#160;...</div><div class="line"><a name="l02167"></a><span class="lineno"> 2167</span>&#160;</div><div class="line"><a name="l02168"></a><span class="lineno"> 2168</span>&#160;  EXEPCT_CALL(mock, Foo(&quot;abc&quot;, _, _))</div><div class="line"><a name="l02169"></a><span class="lineno"> 2169</span>&#160;      .WillOnce(Invoke(DistanceToOrigin));</div><div class="line"><a name="l02170"></a><span class="lineno"> 2170</span>&#160;  EXEPCT_CALL(mock, Bar(5, _, _))</div><div class="line"><a name="l02171"></a><span class="lineno"> 2171</span>&#160;      .WillOnce(Invoke(DistanceToOrigin));</div><div class="line"><a name="l02172"></a><span class="lineno"> 2172</span>&#160;```</div><div class="line"><a name="l02173"></a><span class="lineno"> 2173</span>&#160;</div><div class="line"><a name="l02174"></a><span class="lineno"> 2174</span>&#160;## Sharing Actions ##</div><div class="line"><a name="l02175"></a><span class="lineno"> 2175</span>&#160;</div><div class="line"><a name="l02176"></a><span class="lineno"> 2176</span>&#160;Just like matchers, a Google Mock action object consists of a pointer</div><div class="line"><a name="l02177"></a><span class="lineno"> 2177</span>&#160;to a ref-counted implementation object. Therefore copying actions is</div><div class="line"><a name="l02178"></a><span class="lineno"> 2178</span>&#160;also allowed and very efficient. When the last action that references</div><div class="line"><a name="l02179"></a><span class="lineno"> 2179</span>&#160;the implementation object dies, the implementation object will be</div><div class="line"><a name="l02180"></a><span class="lineno"> 2180</span>&#160;deleted.</div><div class="line"><a name="l02181"></a><span class="lineno"> 2181</span>&#160;</div><div class="line"><a name="l02182"></a><span class="lineno"> 2182</span>&#160;If you have some complex action that you want to use again and again,</div><div class="line"><a name="l02183"></a><span class="lineno"> 2183</span>&#160;you may not have to build it from scratch everytime. If the action</div><div class="line"><a name="l02184"></a><span class="lineno"> 2184</span>&#160;doesn&#39;t have an internal state (i.e. if it always does the same thing</div><div class="line"><a name="l02185"></a><span class="lineno"> 2185</span>&#160;no matter how many times it has been called), you can assign it to an</div><div class="line"><a name="l02186"></a><span class="lineno"> 2186</span>&#160;action variable and use that variable repeatedly. For example:</div><div class="line"><a name="l02187"></a><span class="lineno"> 2187</span>&#160;</div><div class="line"><a name="l02188"></a><span class="lineno"> 2188</span>&#160;```</div><div class="line"><a name="l02189"></a><span class="lineno"> 2189</span>&#160;  Action&lt;bool(int*)&gt; set_flag = DoAll(SetArgPointee&lt;0&gt;(5),</div><div class="line"><a name="l02190"></a><span class="lineno"> 2190</span>&#160;                                      Return(true));</div><div class="line"><a name="l02191"></a><span class="lineno"> 2191</span>&#160;  ... use set_flag in .WillOnce() and .WillRepeatedly() ...</div><div class="line"><a name="l02192"></a><span class="lineno"> 2192</span>&#160;```</div><div class="line"><a name="l02193"></a><span class="lineno"> 2193</span>&#160;</div><div class="line"><a name="l02194"></a><span class="lineno"> 2194</span>&#160;However, if the action has its own state, you may be surprised if you</div><div class="line"><a name="l02195"></a><span class="lineno"> 2195</span>&#160;share the action object. Suppose you have an action factory</div><div class="line"><a name="l02196"></a><span class="lineno"> 2196</span>&#160;`IncrementCounter(init)` which creates an action that increments and</div><div class="line"><a name="l02197"></a><span class="lineno"> 2197</span>&#160;returns a counter whose initial value is `init`, using two actions</div><div class="line"><a name="l02198"></a><span class="lineno"> 2198</span>&#160;created from the same expression and using a shared action will</div><div class="line"><a name="l02199"></a><span class="lineno"> 2199</span>&#160;exihibit different behaviors. Example:</div><div class="line"><a name="l02200"></a><span class="lineno"> 2200</span>&#160;</div><div class="line"><a name="l02201"></a><span class="lineno"> 2201</span>&#160;```</div><div class="line"><a name="l02202"></a><span class="lineno"> 2202</span>&#160;  EXPECT_CALL(foo, DoThis())</div><div class="line"><a name="l02203"></a><span class="lineno"> 2203</span>&#160;      .WillRepeatedly(IncrementCounter(0));</div><div class="line"><a name="l02204"></a><span class="lineno"> 2204</span>&#160;  EXPECT_CALL(foo, DoThat())</div><div class="line"><a name="l02205"></a><span class="lineno"> 2205</span>&#160;      .WillRepeatedly(IncrementCounter(0));</div><div class="line"><a name="l02206"></a><span class="lineno"> 2206</span>&#160;  foo.DoThis();  // Returns 1.</div><div class="line"><a name="l02207"></a><span class="lineno"> 2207</span>&#160;  foo.DoThis();  // Returns 2.</div><div class="line"><a name="l02208"></a><span class="lineno"> 2208</span>&#160;  foo.DoThat();  // Returns 1 - Blah() uses a different</div><div class="line"><a name="l02209"></a><span class="lineno"> 2209</span>&#160;                 // counter than Bar()&#39;s.</div><div class="line"><a name="l02210"></a><span class="lineno"> 2210</span>&#160;```</div><div class="line"><a name="l02211"></a><span class="lineno"> 2211</span>&#160;</div><div class="line"><a name="l02212"></a><span class="lineno"> 2212</span>&#160;versus</div><div class="line"><a name="l02213"></a><span class="lineno"> 2213</span>&#160;</div><div class="line"><a name="l02214"></a><span class="lineno"> 2214</span>&#160;```</div><div class="line"><a name="l02215"></a><span class="lineno"> 2215</span>&#160;  Action&lt;int()&gt; increment = IncrementCounter(0);</div><div class="line"><a name="l02216"></a><span class="lineno"> 2216</span>&#160;</div><div class="line"><a name="l02217"></a><span class="lineno"> 2217</span>&#160;  EXPECT_CALL(foo, DoThis())</div><div class="line"><a name="l02218"></a><span class="lineno"> 2218</span>&#160;      .WillRepeatedly(increment);</div><div class="line"><a name="l02219"></a><span class="lineno"> 2219</span>&#160;  EXPECT_CALL(foo, DoThat())</div><div class="line"><a name="l02220"></a><span class="lineno"> 2220</span>&#160;      .WillRepeatedly(increment);</div><div class="line"><a name="l02221"></a><span class="lineno"> 2221</span>&#160;  foo.DoThis();  // Returns 1.</div><div class="line"><a name="l02222"></a><span class="lineno"> 2222</span>&#160;  foo.DoThis();  // Returns 2.</div><div class="line"><a name="l02223"></a><span class="lineno"> 2223</span>&#160;  foo.DoThat();  // Returns 3 - the counter is shared.</div><div class="line"><a name="l02224"></a><span class="lineno"> 2224</span>&#160;```</div><div class="line"><a name="l02225"></a><span class="lineno"> 2225</span>&#160;</div><div class="line"><a name="l02226"></a><span class="lineno"> 2226</span>&#160;# Misc Recipes on Using Google Mock #</div><div class="line"><a name="l02227"></a><span class="lineno"> 2227</span>&#160;</div><div class="line"><a name="l02228"></a><span class="lineno"> 2228</span>&#160;## Mocking Methods That Use Move-Only Types ##</div><div class="line"><a name="l02229"></a><span class="lineno"> 2229</span>&#160;</div><div class="line"><a name="l02230"></a><span class="lineno"> 2230</span>&#160;C++11 introduced &lt;em&gt;move-only types&lt;/em&gt;.  A move-only-typed value can be moved from one object to another, but cannot be copied.  `std::unique_ptr&lt;T&gt;` is probably the most commonly used move-only type.</div><div class="line"><a name="l02231"></a><span class="lineno"> 2231</span>&#160;</div><div class="line"><a name="l02232"></a><span class="lineno"> 2232</span>&#160;Mocking a method that takes and/or returns move-only types presents some challenges, but nothing insurmountable.  This recipe shows you how you can do it.</div><div class="line"><a name="l02233"></a><span class="lineno"> 2233</span>&#160;</div><div class="line"><a name="l02234"></a><span class="lineno"> 2234</span>&#160;Let’s say we are working on a fictional project that lets one post and share snippets called “buzzes”.  Your code uses these types:</div><div class="line"><a name="l02235"></a><span class="lineno"> 2235</span>&#160;</div><div class="line"><a name="l02236"></a><span class="lineno"> 2236</span>&#160;```</div><div class="line"><a name="l02237"></a><span class="lineno"> 2237</span>&#160;enum class AccessLevel { kInternal, kPublic };</div><div class="line"><a name="l02238"></a><span class="lineno"> 2238</span>&#160;</div><div class="line"><a name="l02239"></a><span class="lineno"> 2239</span>&#160;class Buzz {</div><div class="line"><a name="l02240"></a><span class="lineno"> 2240</span>&#160; public:</div><div class="line"><a name="l02241"></a><span class="lineno"> 2241</span>&#160;  explicit Buzz(AccessLevel access) { … }</div><div class="line"><a name="l02242"></a><span class="lineno"> 2242</span>&#160;  ...</div><div class="line"><a name="l02243"></a><span class="lineno"> 2243</span>&#160;};</div><div class="line"><a name="l02244"></a><span class="lineno"> 2244</span>&#160;</div><div class="line"><a name="l02245"></a><span class="lineno"> 2245</span>&#160;class Buzzer {</div><div class="line"><a name="l02246"></a><span class="lineno"> 2246</span>&#160; public:</div><div class="line"><a name="l02247"></a><span class="lineno"> 2247</span>&#160;  virtual ~Buzzer() {}</div><div class="line"><a name="l02248"></a><span class="lineno"> 2248</span>&#160;  virtual std::unique_ptr&lt;Buzz&gt; MakeBuzz(const std::string&amp; text) = 0;</div><div class="line"><a name="l02249"></a><span class="lineno"> 2249</span>&#160;  virtual bool ShareBuzz(std::unique_ptr&lt;Buzz&gt; buzz, Time timestamp) = 0;</div><div class="line"><a name="l02250"></a><span class="lineno"> 2250</span>&#160;  ...</div><div class="line"><a name="l02251"></a><span class="lineno"> 2251</span>&#160;};</div><div class="line"><a name="l02252"></a><span class="lineno"> 2252</span>&#160;```</div><div class="line"><a name="l02253"></a><span class="lineno"> 2253</span>&#160;</div><div class="line"><a name="l02254"></a><span class="lineno"> 2254</span>&#160;A `Buzz` object represents a snippet being posted.  A class that implements the `Buzzer` interface is capable of creating and sharing `Buzz`.  Methods in `Buzzer` may return a `unique_ptr&lt;Buzz&gt;` or take a `unique_ptr&lt;Buzz&gt;`.  Now we need to mock `Buzzer` in our tests.</div><div class="line"><a name="l02255"></a><span class="lineno"> 2255</span>&#160;</div><div class="line"><a name="l02256"></a><span class="lineno"> 2256</span>&#160;To mock a method that returns a move-only type, you just use the familiar `MOCK_METHOD` syntax as usual:</div><div class="line"><a name="l02257"></a><span class="lineno"> 2257</span>&#160;</div><div class="line"><a name="l02258"></a><span class="lineno"> 2258</span>&#160;```</div><div class="line"><a name="l02259"></a><span class="lineno"> 2259</span>&#160;class MockBuzzer : public Buzzer {</div><div class="line"><a name="l02260"></a><span class="lineno"> 2260</span>&#160; public:</div><div class="line"><a name="l02261"></a><span class="lineno"> 2261</span>&#160;  MOCK_METHOD1(MakeBuzz, std::unique_ptr&lt;Buzz&gt;(const std::string&amp; text));</div><div class="line"><a name="l02262"></a><span class="lineno"> 2262</span>&#160;  …</div><div class="line"><a name="l02263"></a><span class="lineno"> 2263</span>&#160;};</div><div class="line"><a name="l02264"></a><span class="lineno"> 2264</span>&#160;```</div><div class="line"><a name="l02265"></a><span class="lineno"> 2265</span>&#160;</div><div class="line"><a name="l02266"></a><span class="lineno"> 2266</span>&#160;However, if you attempt to use the same `MOCK_METHOD` pattern to mock a method that takes a move-only parameter, you’ll get a compiler error currently:</div><div class="line"><a name="l02267"></a><span class="lineno"> 2267</span>&#160;</div><div class="line"><a name="l02268"></a><span class="lineno"> 2268</span>&#160;```</div><div class="line"><a name="l02269"></a><span class="lineno"> 2269</span>&#160;  // Does NOT compile!</div><div class="line"><a name="l02270"></a><span class="lineno"> 2270</span>&#160;  MOCK_METHOD2(ShareBuzz, bool(std::unique_ptr&lt;Buzz&gt; buzz, Time timestamp));</div><div class="line"><a name="l02271"></a><span class="lineno"> 2271</span>&#160;```</div><div class="line"><a name="l02272"></a><span class="lineno"> 2272</span>&#160;</div><div class="line"><a name="l02273"></a><span class="lineno"> 2273</span>&#160;While it’s highly desirable to make this syntax just work, it’s not trivial and the work hasn’t been done yet.  Fortunately, there is a trick you can apply today to get something that works nearly as well as this.</div><div class="line"><a name="l02274"></a><span class="lineno"> 2274</span>&#160;</div><div class="line"><a name="l02275"></a><span class="lineno"> 2275</span>&#160;The trick, is to delegate the `ShareBuzz()` method to a mock method (let’s call it `DoShareBuzz()`) that does not take move-only parameters:</div><div class="line"><a name="l02276"></a><span class="lineno"> 2276</span>&#160;</div><div class="line"><a name="l02277"></a><span class="lineno"> 2277</span>&#160;```</div><div class="line"><a name="l02278"></a><span class="lineno"> 2278</span>&#160;class MockBuzzer : public Buzzer {</div><div class="line"><a name="l02279"></a><span class="lineno"> 2279</span>&#160; public:</div><div class="line"><a name="l02280"></a><span class="lineno"> 2280</span>&#160;  MOCK_METHOD1(MakeBuzz, std::unique_ptr&lt;Buzz&gt;(const std::string&amp; text));</div><div class="line"><a name="l02281"></a><span class="lineno"> 2281</span>&#160;  MOCK_METHOD2(DoShareBuzz, bool(Buzz* buzz, Time timestamp));</div><div class="line"><a name="l02282"></a><span class="lineno"> 2282</span>&#160;  bool ShareBuzz(std::unique_ptr&lt;Buzz&gt; buzz, Time timestamp) {</div><div class="line"><a name="l02283"></a><span class="lineno"> 2283</span>&#160;    return DoShareBuzz(buzz.get(), timestamp);</div><div class="line"><a name="l02284"></a><span class="lineno"> 2284</span>&#160;  }</div><div class="line"><a name="l02285"></a><span class="lineno"> 2285</span>&#160;};</div><div class="line"><a name="l02286"></a><span class="lineno"> 2286</span>&#160;```</div><div class="line"><a name="l02287"></a><span class="lineno"> 2287</span>&#160;</div><div class="line"><a name="l02288"></a><span class="lineno"> 2288</span>&#160;Note that there&#39;s no need to define or declare `DoShareBuzz()` in a base class.  You only need to define it as a `MOCK_METHOD` in the mock class.</div><div class="line"><a name="l02289"></a><span class="lineno"> 2289</span>&#160;</div><div class="line"><a name="l02290"></a><span class="lineno"> 2290</span>&#160;Now that we have the mock class defined, we can use it in tests.  In the following code examples, we assume that we have defined a `MockBuzzer` object named `mock_buzzer_`:</div><div class="line"><a name="l02291"></a><span class="lineno"> 2291</span>&#160;</div><div class="line"><a name="l02292"></a><span class="lineno"> 2292</span>&#160;```</div><div class="line"><a name="l02293"></a><span class="lineno"> 2293</span>&#160;  MockBuzzer mock_buzzer_;</div><div class="line"><a name="l02294"></a><span class="lineno"> 2294</span>&#160;```</div><div class="line"><a name="l02295"></a><span class="lineno"> 2295</span>&#160;</div><div class="line"><a name="l02296"></a><span class="lineno"> 2296</span>&#160;First let’s see how we can set expectations on the `MakeBuzz()` method, which returns a `unique_ptr&lt;Buzz&gt;`.</div><div class="line"><a name="l02297"></a><span class="lineno"> 2297</span>&#160;</div><div class="line"><a name="l02298"></a><span class="lineno"> 2298</span>&#160;As usual, if you set an expectation without an action (i.e. the `.WillOnce()` or `.WillRepeated()` clause), when that expectation fires, the default action for that method will be taken.  Since `unique_ptr&lt;&gt;` has a default constructor that returns a null `unique_ptr`, that’s what you’ll get if you don’t specify an action:</div><div class="line"><a name="l02299"></a><span class="lineno"> 2299</span>&#160;</div><div class="line"><a name="l02300"></a><span class="lineno"> 2300</span>&#160;```</div><div class="line"><a name="l02301"></a><span class="lineno"> 2301</span>&#160;  // Use the default action.</div><div class="line"><a name="l02302"></a><span class="lineno"> 2302</span>&#160;  EXPECT_CALL(mock_buzzer_, MakeBuzz(&quot;hello&quot;));</div><div class="line"><a name="l02303"></a><span class="lineno"> 2303</span>&#160;</div><div class="line"><a name="l02304"></a><span class="lineno"> 2304</span>&#160;  // Triggers the previous EXPECT_CALL.</div><div class="line"><a name="l02305"></a><span class="lineno"> 2305</span>&#160;  EXPECT_EQ(nullptr, mock_buzzer_.MakeBuzz(&quot;hello&quot;));</div><div class="line"><a name="l02306"></a><span class="lineno"> 2306</span>&#160;```</div><div class="line"><a name="l02307"></a><span class="lineno"> 2307</span>&#160;</div><div class="line"><a name="l02308"></a><span class="lineno"> 2308</span>&#160;If you are not happy with the default action, you can tweak it.  Depending on what you need, you may either tweak the default action for a specific (mock object, mock method) combination using `ON_CALL()`, or you may tweak the default action for all mock methods that return a specific type.  The usage of `ON_CALL()` is similar to `EXPECT_CALL()`, so we’ll skip it and just explain how to do the latter (tweaking the default action for a specific return type).  You do this via the `DefaultValue&lt;&gt;::SetFactory()` and `DefaultValue&lt;&gt;::Clear()` API:</div><div class="line"><a name="l02309"></a><span class="lineno"> 2309</span>&#160;</div><div class="line"><a name="l02310"></a><span class="lineno"> 2310</span>&#160;```</div><div class="line"><a name="l02311"></a><span class="lineno"> 2311</span>&#160;  // Sets the default action for return type std::unique_ptr&lt;Buzz&gt; to</div><div class="line"><a name="l02312"></a><span class="lineno"> 2312</span>&#160;  // creating a new Buzz every time.</div><div class="line"><a name="l02313"></a><span class="lineno"> 2313</span>&#160;  DefaultValue&lt;std::unique_ptr&lt;Buzz&gt;&gt;::SetFactory(</div><div class="line"><a name="l02314"></a><span class="lineno"> 2314</span>&#160;      [] { return MakeUnique&lt;Buzz&gt;(AccessLevel::kInternal); });</div><div class="line"><a name="l02315"></a><span class="lineno"> 2315</span>&#160;</div><div class="line"><a name="l02316"></a><span class="lineno"> 2316</span>&#160;  // When this fires, the default action of MakeBuzz() will run, which</div><div class="line"><a name="l02317"></a><span class="lineno"> 2317</span>&#160;  // will return a new Buzz object.</div><div class="line"><a name="l02318"></a><span class="lineno"> 2318</span>&#160;  EXPECT_CALL(mock_buzzer_, MakeBuzz(&quot;hello&quot;)).Times(AnyNumber());</div><div class="line"><a name="l02319"></a><span class="lineno"> 2319</span>&#160;</div><div class="line"><a name="l02320"></a><span class="lineno"> 2320</span>&#160;  auto buzz1 = mock_buzzer_.MakeBuzz(&quot;hello&quot;);</div><div class="line"><a name="l02321"></a><span class="lineno"> 2321</span>&#160;  auto buzz2 = mock_buzzer_.MakeBuzz(&quot;hello&quot;);</div><div class="line"><a name="l02322"></a><span class="lineno"> 2322</span>&#160;  EXPECT_NE(nullptr, buzz1);</div><div class="line"><a name="l02323"></a><span class="lineno"> 2323</span>&#160;  EXPECT_NE(nullptr, buzz2);</div><div class="line"><a name="l02324"></a><span class="lineno"> 2324</span>&#160;  EXPECT_NE(buzz1, buzz2);</div><div class="line"><a name="l02325"></a><span class="lineno"> 2325</span>&#160;</div><div class="line"><a name="l02326"></a><span class="lineno"> 2326</span>&#160;  // Resets the default action for return type std::unique_ptr&lt;Buzz&gt;,</div><div class="line"><a name="l02327"></a><span class="lineno"> 2327</span>&#160;  // to avoid interfere with other tests.</div><div class="line"><a name="l02328"></a><span class="lineno"> 2328</span>&#160;  DefaultValue&lt;std::unique_ptr&lt;Buzz&gt;&gt;::Clear();</div><div class="line"><a name="l02329"></a><span class="lineno"> 2329</span>&#160;```</div><div class="line"><a name="l02330"></a><span class="lineno"> 2330</span>&#160;</div><div class="line"><a name="l02331"></a><span class="lineno"> 2331</span>&#160;What if you want the method to do something other than the default action?  If you just need to return a pre-defined move-only value, you can use the `Return(ByMove(...))` action:</div><div class="line"><a name="l02332"></a><span class="lineno"> 2332</span>&#160;</div><div class="line"><a name="l02333"></a><span class="lineno"> 2333</span>&#160;```</div><div class="line"><a name="l02334"></a><span class="lineno"> 2334</span>&#160;  // When this fires, the unique_ptr&lt;&gt; specified by ByMove(...) will</div><div class="line"><a name="l02335"></a><span class="lineno"> 2335</span>&#160;  // be returned.</div><div class="line"><a name="l02336"></a><span class="lineno"> 2336</span>&#160;  EXPECT_CALL(mock_buzzer_, MakeBuzz(&quot;world&quot;))</div><div class="line"><a name="l02337"></a><span class="lineno"> 2337</span>&#160;      .WillOnce(Return(ByMove(MakeUnique&lt;Buzz&gt;(AccessLevel::kInternal))));</div><div class="line"><a name="l02338"></a><span class="lineno"> 2338</span>&#160;</div><div class="line"><a name="l02339"></a><span class="lineno"> 2339</span>&#160;  EXPECT_NE(nullptr, mock_buzzer_.MakeBuzz(&quot;world&quot;));</div><div class="line"><a name="l02340"></a><span class="lineno"> 2340</span>&#160;```</div><div class="line"><a name="l02341"></a><span class="lineno"> 2341</span>&#160;</div><div class="line"><a name="l02342"></a><span class="lineno"> 2342</span>&#160;Note that `ByMove()` is essential here - if you drop it, the code won’t compile.</div><div class="line"><a name="l02343"></a><span class="lineno"> 2343</span>&#160;</div><div class="line"><a name="l02344"></a><span class="lineno"> 2344</span>&#160;Quiz time!  What do you think will happen if a `Return(ByMove(...))` action is performed more than once (e.g. you write `….WillRepeatedly(Return(ByMove(...)));`)?  Come think of it, after the first time the action runs, the source value will be consumed (since it’s a move-only value), so the next time around, there’s no value to move from -- you’ll get a run-time error that `Return(ByMove(...))` can only be run once.</div><div class="line"><a name="l02345"></a><span class="lineno"> 2345</span>&#160;</div><div class="line"><a name="l02346"></a><span class="lineno"> 2346</span>&#160;If you need your mock method to do more than just moving a pre-defined value, remember that you can always use `Invoke()` to call a lambda or a callable object, which can do pretty much anything you want:</div><div class="line"><a name="l02347"></a><span class="lineno"> 2347</span>&#160;</div><div class="line"><a name="l02348"></a><span class="lineno"> 2348</span>&#160;```</div><div class="line"><a name="l02349"></a><span class="lineno"> 2349</span>&#160;  EXPECT_CALL(mock_buzzer_, MakeBuzz(&quot;x&quot;))</div><div class="line"><a name="l02350"></a><span class="lineno"> 2350</span>&#160;      .WillRepeatedly(Invoke([](const std::string&amp; text) {</div><div class="line"><a name="l02351"></a><span class="lineno"> 2351</span>&#160;        return std::make_unique&lt;Buzz&gt;(AccessLevel::kInternal);</div><div class="line"><a name="l02352"></a><span class="lineno"> 2352</span>&#160;      }));</div><div class="line"><a name="l02353"></a><span class="lineno"> 2353</span>&#160;</div><div class="line"><a name="l02354"></a><span class="lineno"> 2354</span>&#160;  EXPECT_NE(nullptr, mock_buzzer_.MakeBuzz(&quot;x&quot;));</div><div class="line"><a name="l02355"></a><span class="lineno"> 2355</span>&#160;  EXPECT_NE(nullptr, mock_buzzer_.MakeBuzz(&quot;x&quot;));</div><div class="line"><a name="l02356"></a><span class="lineno"> 2356</span>&#160;```</div><div class="line"><a name="l02357"></a><span class="lineno"> 2357</span>&#160;</div><div class="line"><a name="l02358"></a><span class="lineno"> 2358</span>&#160;Every time this `EXPECT_CALL` fires, a new `unique_ptr&lt;Buzz&gt;` will be created and returned.  You cannot do this with `Return(ByMove(...))`.</div><div class="line"><a name="l02359"></a><span class="lineno"> 2359</span>&#160;</div><div class="line"><a name="l02360"></a><span class="lineno"> 2360</span>&#160;Now there’s one topic we haven’t covered: how do you set expectations on `ShareBuzz()`, which takes a move-only-typed parameter?  The answer is you don’t.  Instead, you set expectations on the `DoShareBuzz()` mock method (remember that we defined a `MOCK_METHOD` for `DoShareBuzz()`, not `ShareBuzz()`):</div><div class="line"><a name="l02361"></a><span class="lineno"> 2361</span>&#160;</div><div class="line"><a name="l02362"></a><span class="lineno"> 2362</span>&#160;```</div><div class="line"><a name="l02363"></a><span class="lineno"> 2363</span>&#160;  EXPECT_CALL(mock_buzzer_, DoShareBuzz(NotNull(), _));</div><div class="line"><a name="l02364"></a><span class="lineno"> 2364</span>&#160;</div><div class="line"><a name="l02365"></a><span class="lineno"> 2365</span>&#160;  // When one calls ShareBuzz() on the MockBuzzer like this, the call is</div><div class="line"><a name="l02366"></a><span class="lineno"> 2366</span>&#160;  // forwarded to DoShareBuzz(), which is mocked.  Therefore this statement</div><div class="line"><a name="l02367"></a><span class="lineno"> 2367</span>&#160;  // will trigger the above EXPECT_CALL.</div><div class="line"><a name="l02368"></a><span class="lineno"> 2368</span>&#160;  mock_buzzer_.ShareBuzz(MakeUnique&amp;lt;Buzz&amp;gt;(AccessLevel::kInternal),</div><div class="line"><a name="l02369"></a><span class="lineno"> 2369</span>&#160;                         ::base::Now());</div><div class="line"><a name="l02370"></a><span class="lineno"> 2370</span>&#160;```</div><div class="line"><a name="l02371"></a><span class="lineno"> 2371</span>&#160;</div><div class="line"><a name="l02372"></a><span class="lineno"> 2372</span>&#160;Some of you may have spotted one problem with this approach: the `DoShareBuzz()` mock method differs from the real `ShareBuzz()` method in that it cannot take ownership of the buzz parameter - `ShareBuzz()` will always delete buzz after `DoShareBuzz()` returns.  What if you need to save the buzz object somewhere for later use when `ShareBuzz()` is called?  Indeed, you&#39;d be stuck.</div><div class="line"><a name="l02373"></a><span class="lineno"> 2373</span>&#160;</div><div class="line"><a name="l02374"></a><span class="lineno"> 2374</span>&#160;Another problem with the `DoShareBuzz()` we had is that it can surprise people reading or maintaining the test, as one would expect that `DoShareBuzz()` has (logically) the same contract as `ShareBuzz()`.</div><div class="line"><a name="l02375"></a><span class="lineno"> 2375</span>&#160;</div><div class="line"><a name="l02376"></a><span class="lineno"> 2376</span>&#160;Fortunately, these problems can be fixed with a bit more code.  Let&#39;s try to get it right this time:</div><div class="line"><a name="l02377"></a><span class="lineno"> 2377</span>&#160;</div><div class="line"><a name="l02378"></a><span class="lineno"> 2378</span>&#160;```</div><div class="line"><a name="l02379"></a><span class="lineno"> 2379</span>&#160;class MockBuzzer : public Buzzer {</div><div class="line"><a name="l02380"></a><span class="lineno"> 2380</span>&#160; public:</div><div class="line"><a name="l02381"></a><span class="lineno"> 2381</span>&#160;  MockBuzzer() {</div><div class="line"><a name="l02382"></a><span class="lineno"> 2382</span>&#160;    // Since DoShareBuzz(buzz, time) is supposed to take ownership of</div><div class="line"><a name="l02383"></a><span class="lineno"> 2383</span>&#160;    // buzz, define a default behavior for DoShareBuzz(buzz, time) to</div><div class="line"><a name="l02384"></a><span class="lineno"> 2384</span>&#160;    // delete buzz.</div><div class="line"><a name="l02385"></a><span class="lineno"> 2385</span>&#160;    ON_CALL(*this, DoShareBuzz(_, _))</div><div class="line"><a name="l02386"></a><span class="lineno"> 2386</span>&#160;        .WillByDefault(Invoke([](Buzz* buzz, Time timestamp) {</div><div class="line"><a name="l02387"></a><span class="lineno"> 2387</span>&#160;          delete buzz;</div><div class="line"><a name="l02388"></a><span class="lineno"> 2388</span>&#160;          return true;</div><div class="line"><a name="l02389"></a><span class="lineno"> 2389</span>&#160;        }));</div><div class="line"><a name="l02390"></a><span class="lineno"> 2390</span>&#160;  }</div><div class="line"><a name="l02391"></a><span class="lineno"> 2391</span>&#160;</div><div class="line"><a name="l02392"></a><span class="lineno"> 2392</span>&#160;  MOCK_METHOD1(MakeBuzz, std::unique_ptr&lt;Buzz&gt;(const std::string&amp; text));</div><div class="line"><a name="l02393"></a><span class="lineno"> 2393</span>&#160;</div><div class="line"><a name="l02394"></a><span class="lineno"> 2394</span>&#160;  // Takes ownership of buzz.</div><div class="line"><a name="l02395"></a><span class="lineno"> 2395</span>&#160;  MOCK_METHOD2(DoShareBuzz, bool(Buzz* buzz, Time timestamp));</div><div class="line"><a name="l02396"></a><span class="lineno"> 2396</span>&#160;  bool ShareBuzz(std::unique_ptr&lt;Buzz&gt; buzz, Time timestamp) {</div><div class="line"><a name="l02397"></a><span class="lineno"> 2397</span>&#160;    return DoShareBuzz(buzz.release(), timestamp);</div><div class="line"><a name="l02398"></a><span class="lineno"> 2398</span>&#160;  }</div><div class="line"><a name="l02399"></a><span class="lineno"> 2399</span>&#160;};</div><div class="line"><a name="l02400"></a><span class="lineno"> 2400</span>&#160;```</div><div class="line"><a name="l02401"></a><span class="lineno"> 2401</span>&#160;</div><div class="line"><a name="l02402"></a><span class="lineno"> 2402</span>&#160;Now, the mock `DoShareBuzz()` method is free to save the buzz argument for later use if this is what you want:</div><div class="line"><a name="l02403"></a><span class="lineno"> 2403</span>&#160;</div><div class="line"><a name="l02404"></a><span class="lineno"> 2404</span>&#160;```</div><div class="line"><a name="l02405"></a><span class="lineno"> 2405</span>&#160;  std::unique_ptr&lt;Buzz&gt; intercepted_buzz;</div><div class="line"><a name="l02406"></a><span class="lineno"> 2406</span>&#160;  EXPECT_CALL(mock_buzzer_, DoShareBuzz(NotNull(), _))</div><div class="line"><a name="l02407"></a><span class="lineno"> 2407</span>&#160;      .WillOnce(Invoke([&amp;amp;intercepted_buzz](Buzz* buzz, Time timestamp) {</div><div class="line"><a name="l02408"></a><span class="lineno"> 2408</span>&#160;        // Save buzz in intercepted_buzz for analysis later.</div><div class="line"><a name="l02409"></a><span class="lineno"> 2409</span>&#160;        intercepted_buzz.reset(buzz);</div><div class="line"><a name="l02410"></a><span class="lineno"> 2410</span>&#160;        return false;</div><div class="line"><a name="l02411"></a><span class="lineno"> 2411</span>&#160;      }));</div><div class="line"><a name="l02412"></a><span class="lineno"> 2412</span>&#160;</div><div class="line"><a name="l02413"></a><span class="lineno"> 2413</span>&#160;  mock_buzzer_.ShareBuzz(std::make_unique&lt;Buzz&gt;(AccessLevel::kInternal),</div><div class="line"><a name="l02414"></a><span class="lineno"> 2414</span>&#160;                         Now());</div><div class="line"><a name="l02415"></a><span class="lineno"> 2415</span>&#160;  EXPECT_NE(nullptr, intercepted_buzz);</div><div class="line"><a name="l02416"></a><span class="lineno"> 2416</span>&#160;```</div><div class="line"><a name="l02417"></a><span class="lineno"> 2417</span>&#160;</div><div class="line"><a name="l02418"></a><span class="lineno"> 2418</span>&#160;Using the tricks covered in this recipe, you are now able to mock methods that take and/or return move-only types.  Put your newly-acquired power to good use - when you design a new API, you can now feel comfortable using `unique_ptrs` as appropriate, without fearing that doing so will compromise your tests.</div><div class="line"><a name="l02419"></a><span class="lineno"> 2419</span>&#160;</div><div class="line"><a name="l02420"></a><span class="lineno"> 2420</span>&#160;## Making the Compilation Faster ##</div><div class="line"><a name="l02421"></a><span class="lineno"> 2421</span>&#160;</div><div class="line"><a name="l02422"></a><span class="lineno"> 2422</span>&#160;Believe it or not, the _vast majority_ of the time spent on compiling</div><div class="line"><a name="l02423"></a><span class="lineno"> 2423</span>&#160;a mock class is in generating its constructor and destructor, as they</div><div class="line"><a name="l02424"></a><span class="lineno"> 2424</span>&#160;perform non-trivial tasks (e.g. verification of the</div><div class="line"><a name="l02425"></a><span class="lineno"> 2425</span>&#160;expectations). What&#39;s more, mock methods with different signatures</div><div class="line"><a name="l02426"></a><span class="lineno"> 2426</span>&#160;have different types and thus their constructors/destructors need to</div><div class="line"><a name="l02427"></a><span class="lineno"> 2427</span>&#160;be generated by the compiler separately. As a result, if you mock many</div><div class="line"><a name="l02428"></a><span class="lineno"> 2428</span>&#160;different types of methods, compiling your mock class can get really</div><div class="line"><a name="l02429"></a><span class="lineno"> 2429</span>&#160;slow.</div><div class="line"><a name="l02430"></a><span class="lineno"> 2430</span>&#160;</div><div class="line"><a name="l02431"></a><span class="lineno"> 2431</span>&#160;If you are experiencing slow compilation, you can move the definition</div><div class="line"><a name="l02432"></a><span class="lineno"> 2432</span>&#160;of your mock class&#39; constructor and destructor out of the class body</div><div class="line"><a name="l02433"></a><span class="lineno"> 2433</span>&#160;and into a `.cpp` file. This way, even if you `#include` your mock</div><div class="line"><a name="l02434"></a><span class="lineno"> 2434</span>&#160;class in N files, the compiler only needs to generate its constructor</div><div class="line"><a name="l02435"></a><span class="lineno"> 2435</span>&#160;and destructor once, resulting in a much faster compilation.</div><div class="line"><a name="l02436"></a><span class="lineno"> 2436</span>&#160;</div><div class="line"><a name="l02437"></a><span class="lineno"> 2437</span>&#160;Let&#39;s illustrate the idea using an example. Here&#39;s the definition of a</div><div class="line"><a name="l02438"></a><span class="lineno"> 2438</span>&#160;mock class before applying this recipe:</div><div class="line"><a name="l02439"></a><span class="lineno"> 2439</span>&#160;</div><div class="line"><a name="l02440"></a><span class="lineno"> 2440</span>&#160;```</div><div class="line"><a name="l02441"></a><span class="lineno"> 2441</span>&#160;// File mock_foo.h.</div><div class="line"><a name="l02442"></a><span class="lineno"> 2442</span>&#160;...</div><div class="line"><a name="l02443"></a><span class="lineno"> 2443</span>&#160;class MockFoo : public Foo {</div><div class="line"><a name="l02444"></a><span class="lineno"> 2444</span>&#160; public:</div><div class="line"><a name="l02445"></a><span class="lineno"> 2445</span>&#160;  // Since we don&#39;t declare the constructor or the destructor,</div><div class="line"><a name="l02446"></a><span class="lineno"> 2446</span>&#160;  // the compiler will generate them in every translation unit</div><div class="line"><a name="l02447"></a><span class="lineno"> 2447</span>&#160;  // where this mock class is used.</div><div class="line"><a name="l02448"></a><span class="lineno"> 2448</span>&#160;</div><div class="line"><a name="l02449"></a><span class="lineno"> 2449</span>&#160;  MOCK_METHOD0(DoThis, int());</div><div class="line"><a name="l02450"></a><span class="lineno"> 2450</span>&#160;  MOCK_METHOD1(DoThat, bool(const char* str));</div><div class="line"><a name="l02451"></a><span class="lineno"> 2451</span>&#160;  ... more mock methods ...</div><div class="line"><a name="l02452"></a><span class="lineno"> 2452</span>&#160;};</div><div class="line"><a name="l02453"></a><span class="lineno"> 2453</span>&#160;```</div><div class="line"><a name="l02454"></a><span class="lineno"> 2454</span>&#160;</div><div class="line"><a name="l02455"></a><span class="lineno"> 2455</span>&#160;After the change, it would look like:</div><div class="line"><a name="l02456"></a><span class="lineno"> 2456</span>&#160;</div><div class="line"><a name="l02457"></a><span class="lineno"> 2457</span>&#160;```</div><div class="line"><a name="l02458"></a><span class="lineno"> 2458</span>&#160;// File mock_foo.h.</div><div class="line"><a name="l02459"></a><span class="lineno"> 2459</span>&#160;...</div><div class="line"><a name="l02460"></a><span class="lineno"> 2460</span>&#160;class MockFoo : public Foo {</div><div class="line"><a name="l02461"></a><span class="lineno"> 2461</span>&#160; public:</div><div class="line"><a name="l02462"></a><span class="lineno"> 2462</span>&#160;  // The constructor and destructor are declared, but not defined, here.</div><div class="line"><a name="l02463"></a><span class="lineno"> 2463</span>&#160;  MockFoo();</div><div class="line"><a name="l02464"></a><span class="lineno"> 2464</span>&#160;  virtual ~MockFoo();</div><div class="line"><a name="l02465"></a><span class="lineno"> 2465</span>&#160;</div><div class="line"><a name="l02466"></a><span class="lineno"> 2466</span>&#160;  MOCK_METHOD0(DoThis, int());</div><div class="line"><a name="l02467"></a><span class="lineno"> 2467</span>&#160;  MOCK_METHOD1(DoThat, bool(const char* str));</div><div class="line"><a name="l02468"></a><span class="lineno"> 2468</span>&#160;  ... more mock methods ...</div><div class="line"><a name="l02469"></a><span class="lineno"> 2469</span>&#160;};</div><div class="line"><a name="l02470"></a><span class="lineno"> 2470</span>&#160;```</div><div class="line"><a name="l02471"></a><span class="lineno"> 2471</span>&#160;and</div><div class="line"><a name="l02472"></a><span class="lineno"> 2472</span>&#160;```</div><div class="line"><a name="l02473"></a><span class="lineno"> 2473</span>&#160;// File mock_foo.cpp.</div><div class="line"><a name="l02474"></a><span class="lineno"> 2474</span>&#160;#include &quot;path/to/mock_foo.h&quot;</div><div class="line"><a name="l02475"></a><span class="lineno"> 2475</span>&#160;</div><div class="line"><a name="l02476"></a><span class="lineno"> 2476</span>&#160;// The definitions may appear trivial, but the functions actually do a</div><div class="line"><a name="l02477"></a><span class="lineno"> 2477</span>&#160;// lot of things through the constructors/destructors of the member</div><div class="line"><a name="l02478"></a><span class="lineno"> 2478</span>&#160;// variables used to implement the mock methods.</div><div class="line"><a name="l02479"></a><span class="lineno"> 2479</span>&#160;MockFoo::MockFoo() {}</div><div class="line"><a name="l02480"></a><span class="lineno"> 2480</span>&#160;MockFoo::~MockFoo() {}</div><div class="line"><a name="l02481"></a><span class="lineno"> 2481</span>&#160;```</div><div class="line"><a name="l02482"></a><span class="lineno"> 2482</span>&#160;</div><div class="line"><a name="l02483"></a><span class="lineno"> 2483</span>&#160;## Forcing a Verification ##</div><div class="line"><a name="l02484"></a><span class="lineno"> 2484</span>&#160;</div><div class="line"><a name="l02485"></a><span class="lineno"> 2485</span>&#160;When it&#39;s being destoyed, your friendly mock object will automatically</div><div class="line"><a name="l02486"></a><span class="lineno"> 2486</span>&#160;verify that all expectations on it have been satisfied, and will</div><div class="line"><a name="l02487"></a><span class="lineno"> 2487</span>&#160;generate [Google Test](../../googletest/) failures</div><div class="line"><a name="l02488"></a><span class="lineno"> 2488</span>&#160;if not. This is convenient as it leaves you with one less thing to</div><div class="line"><a name="l02489"></a><span class="lineno"> 2489</span>&#160;worry about. That is, unless you are not sure if your mock object will</div><div class="line"><a name="l02490"></a><span class="lineno"> 2490</span>&#160;be destoyed.</div><div class="line"><a name="l02491"></a><span class="lineno"> 2491</span>&#160;</div><div class="line"><a name="l02492"></a><span class="lineno"> 2492</span>&#160;How could it be that your mock object won&#39;t eventually be destroyed?</div><div class="line"><a name="l02493"></a><span class="lineno"> 2493</span>&#160;Well, it might be created on the heap and owned by the code you are</div><div class="line"><a name="l02494"></a><span class="lineno"> 2494</span>&#160;testing. Suppose there&#39;s a bug in that code and it doesn&#39;t delete the</div><div class="line"><a name="l02495"></a><span class="lineno"> 2495</span>&#160;mock object properly - you could end up with a passing test when</div><div class="line"><a name="l02496"></a><span class="lineno"> 2496</span>&#160;there&#39;s actually a bug.</div><div class="line"><a name="l02497"></a><span class="lineno"> 2497</span>&#160;</div><div class="line"><a name="l02498"></a><span class="lineno"> 2498</span>&#160;Using a heap checker is a good idea and can alleviate the concern, but</div><div class="line"><a name="l02499"></a><span class="lineno"> 2499</span>&#160;its implementation may not be 100% reliable. So, sometimes you do want</div><div class="line"><a name="l02500"></a><span class="lineno"> 2500</span>&#160;to _force_ Google Mock to verify a mock object before it is</div><div class="line"><a name="l02501"></a><span class="lineno"> 2501</span>&#160;(hopefully) destructed. You can do this with</div><div class="line"><a name="l02502"></a><span class="lineno"> 2502</span>&#160;`Mock::VerifyAndClearExpectations(&amp;mock_object)`:</div><div class="line"><a name="l02503"></a><span class="lineno"> 2503</span>&#160;</div><div class="line"><a name="l02504"></a><span class="lineno"> 2504</span>&#160;```</div><div class="line"><a name="l02505"></a><span class="lineno"> 2505</span>&#160;TEST(MyServerTest, ProcessesRequest) {</div><div class="line"><a name="l02506"></a><span class="lineno"> 2506</span>&#160;  using ::testing::Mock;</div><div class="line"><a name="l02507"></a><span class="lineno"> 2507</span>&#160;</div><div class="line"><a name="l02508"></a><span class="lineno"> 2508</span>&#160;  MockFoo* const foo = new MockFoo;</div><div class="line"><a name="l02509"></a><span class="lineno"> 2509</span>&#160;  EXPECT_CALL(*foo, ...)...;</div><div class="line"><a name="l02510"></a><span class="lineno"> 2510</span>&#160;  // ... other expectations ...</div><div class="line"><a name="l02511"></a><span class="lineno"> 2511</span>&#160;</div><div class="line"><a name="l02512"></a><span class="lineno"> 2512</span>&#160;  // server now owns foo.</div><div class="line"><a name="l02513"></a><span class="lineno"> 2513</span>&#160;  MyServer server(foo);</div><div class="line"><a name="l02514"></a><span class="lineno"> 2514</span>&#160;  server.ProcessRequest(...);</div><div class="line"><a name="l02515"></a><span class="lineno"> 2515</span>&#160;</div><div class="line"><a name="l02516"></a><span class="lineno"> 2516</span>&#160;  // In case that server&#39;s destructor will forget to delete foo,</div><div class="line"><a name="l02517"></a><span class="lineno"> 2517</span>&#160;  // this will verify the expectations anyway.</div><div class="line"><a name="l02518"></a><span class="lineno"> 2518</span>&#160;  Mock::VerifyAndClearExpectations(foo);</div><div class="line"><a name="l02519"></a><span class="lineno"> 2519</span>&#160;}  // server is destroyed when it goes out of scope here.</div><div class="line"><a name="l02520"></a><span class="lineno"> 2520</span>&#160;```</div><div class="line"><a name="l02521"></a><span class="lineno"> 2521</span>&#160;</div><div class="line"><a name="l02522"></a><span class="lineno"> 2522</span>&#160;**Tip:** The `Mock::VerifyAndClearExpectations()` function returns a</div><div class="line"><a name="l02523"></a><span class="lineno"> 2523</span>&#160;`bool` to indicate whether the verification was successful (`true` for</div><div class="line"><a name="l02524"></a><span class="lineno"> 2524</span>&#160;yes), so you can wrap that function call inside a `ASSERT_TRUE()` if</div><div class="line"><a name="l02525"></a><span class="lineno"> 2525</span>&#160;there is no point going further when the verification has failed.</div><div class="line"><a name="l02526"></a><span class="lineno"> 2526</span>&#160;</div><div class="line"><a name="l02527"></a><span class="lineno"> 2527</span>&#160;## Using Check Points ##</div><div class="line"><a name="l02528"></a><span class="lineno"> 2528</span>&#160;</div><div class="line"><a name="l02529"></a><span class="lineno"> 2529</span>&#160;Sometimes you may want to &quot;reset&quot; a mock object at various check</div><div class="line"><a name="l02530"></a><span class="lineno"> 2530</span>&#160;points in your test: at each check point, you verify that all existing</div><div class="line"><a name="l02531"></a><span class="lineno"> 2531</span>&#160;expectations on the mock object have been satisfied, and then you set</div><div class="line"><a name="l02532"></a><span class="lineno"> 2532</span>&#160;some new expectations on it as if it&#39;s newly created. This allows you</div><div class="line"><a name="l02533"></a><span class="lineno"> 2533</span>&#160;to work with a mock object in &quot;phases&quot; whose sizes are each</div><div class="line"><a name="l02534"></a><span class="lineno"> 2534</span>&#160;manageable.</div><div class="line"><a name="l02535"></a><span class="lineno"> 2535</span>&#160;</div><div class="line"><a name="l02536"></a><span class="lineno"> 2536</span>&#160;One such scenario is that in your test&#39;s `SetUp()` function, you may</div><div class="line"><a name="l02537"></a><span class="lineno"> 2537</span>&#160;want to put the object you are testing into a certain state, with the</div><div class="line"><a name="l02538"></a><span class="lineno"> 2538</span>&#160;help from a mock object. Once in the desired state, you want to clear</div><div class="line"><a name="l02539"></a><span class="lineno"> 2539</span>&#160;all expectations on the mock, such that in the `TEST_F` body you can</div><div class="line"><a name="l02540"></a><span class="lineno"> 2540</span>&#160;set fresh expectations on it.</div><div class="line"><a name="l02541"></a><span class="lineno"> 2541</span>&#160;</div><div class="line"><a name="l02542"></a><span class="lineno"> 2542</span>&#160;As you may have figured out, the `Mock::VerifyAndClearExpectations()`</div><div class="line"><a name="l02543"></a><span class="lineno"> 2543</span>&#160;function we saw in the previous recipe can help you here. Or, if you</div><div class="line"><a name="l02544"></a><span class="lineno"> 2544</span>&#160;are using `ON_CALL()` to set default actions on the mock object and</div><div class="line"><a name="l02545"></a><span class="lineno"> 2545</span>&#160;want to clear the default actions as well, use</div><div class="line"><a name="l02546"></a><span class="lineno"> 2546</span>&#160;`Mock::VerifyAndClear(&amp;mock_object)` instead. This function does what</div><div class="line"><a name="l02547"></a><span class="lineno"> 2547</span>&#160;`Mock::VerifyAndClearExpectations(&amp;mock_object)` does and returns the</div><div class="line"><a name="l02548"></a><span class="lineno"> 2548</span>&#160;same `bool`, **plus** it clears the `ON_CALL()` statements on</div><div class="line"><a name="l02549"></a><span class="lineno"> 2549</span>&#160;`mock_object` too.</div><div class="line"><a name="l02550"></a><span class="lineno"> 2550</span>&#160;</div><div class="line"><a name="l02551"></a><span class="lineno"> 2551</span>&#160;Another trick you can use to achieve the same effect is to put the</div><div class="line"><a name="l02552"></a><span class="lineno"> 2552</span>&#160;expectations in sequences and insert calls to a dummy &quot;check-point&quot;</div><div class="line"><a name="l02553"></a><span class="lineno"> 2553</span>&#160;function at specific places. Then you can verify that the mock</div><div class="line"><a name="l02554"></a><span class="lineno"> 2554</span>&#160;function calls do happen at the right time. For example, if you are</div><div class="line"><a name="l02555"></a><span class="lineno"> 2555</span>&#160;exercising code:</div><div class="line"><a name="l02556"></a><span class="lineno"> 2556</span>&#160;</div><div class="line"><a name="l02557"></a><span class="lineno"> 2557</span>&#160;```</div><div class="line"><a name="l02558"></a><span class="lineno"> 2558</span>&#160;Foo(1);</div><div class="line"><a name="l02559"></a><span class="lineno"> 2559</span>&#160;Foo(2);</div><div class="line"><a name="l02560"></a><span class="lineno"> 2560</span>&#160;Foo(3);</div><div class="line"><a name="l02561"></a><span class="lineno"> 2561</span>&#160;```</div><div class="line"><a name="l02562"></a><span class="lineno"> 2562</span>&#160;</div><div class="line"><a name="l02563"></a><span class="lineno"> 2563</span>&#160;and want to verify that `Foo(1)` and `Foo(3)` both invoke</div><div class="line"><a name="l02564"></a><span class="lineno"> 2564</span>&#160;`mock.Bar(&quot;a&quot;)`, but `Foo(2)` doesn&#39;t invoke anything. You can write:</div><div class="line"><a name="l02565"></a><span class="lineno"> 2565</span>&#160;</div><div class="line"><a name="l02566"></a><span class="lineno"> 2566</span>&#160;```</div><div class="line"><a name="l02567"></a><span class="lineno"> 2567</span>&#160;using ::testing::MockFunction;</div><div class="line"><a name="l02568"></a><span class="lineno"> 2568</span>&#160;</div><div class="line"><a name="l02569"></a><span class="lineno"> 2569</span>&#160;TEST(FooTest, InvokesBarCorrectly) {</div><div class="line"><a name="l02570"></a><span class="lineno"> 2570</span>&#160;  MyMock mock;</div><div class="line"><a name="l02571"></a><span class="lineno"> 2571</span>&#160;  // Class MockFunction&lt;F&gt; has exactly one mock method.  It is named</div><div class="line"><a name="l02572"></a><span class="lineno"> 2572</span>&#160;  // Call() and has type F.</div><div class="line"><a name="l02573"></a><span class="lineno"> 2573</span>&#160;  MockFunction&lt;void(string check_point_name)&gt; check;</div><div class="line"><a name="l02574"></a><span class="lineno"> 2574</span>&#160;  {</div><div class="line"><a name="l02575"></a><span class="lineno"> 2575</span>&#160;    InSequence s;</div><div class="line"><a name="l02576"></a><span class="lineno"> 2576</span>&#160;</div><div class="line"><a name="l02577"></a><span class="lineno"> 2577</span>&#160;    EXPECT_CALL(mock, Bar(&quot;a&quot;));</div><div class="line"><a name="l02578"></a><span class="lineno"> 2578</span>&#160;    EXPECT_CALL(check, Call(&quot;1&quot;));</div><div class="line"><a name="l02579"></a><span class="lineno"> 2579</span>&#160;    EXPECT_CALL(check, Call(&quot;2&quot;));</div><div class="line"><a name="l02580"></a><span class="lineno"> 2580</span>&#160;    EXPECT_CALL(mock, Bar(&quot;a&quot;));</div><div class="line"><a name="l02581"></a><span class="lineno"> 2581</span>&#160;  }</div><div class="line"><a name="l02582"></a><span class="lineno"> 2582</span>&#160;  Foo(1);</div><div class="line"><a name="l02583"></a><span class="lineno"> 2583</span>&#160;  check.Call(&quot;1&quot;);</div><div class="line"><a name="l02584"></a><span class="lineno"> 2584</span>&#160;  Foo(2);</div><div class="line"><a name="l02585"></a><span class="lineno"> 2585</span>&#160;  check.Call(&quot;2&quot;);</div><div class="line"><a name="l02586"></a><span class="lineno"> 2586</span>&#160;  Foo(3);</div><div class="line"><a name="l02587"></a><span class="lineno"> 2587</span>&#160;}</div><div class="line"><a name="l02588"></a><span class="lineno"> 2588</span>&#160;```</div><div class="line"><a name="l02589"></a><span class="lineno"> 2589</span>&#160;</div><div class="line"><a name="l02590"></a><span class="lineno"> 2590</span>&#160;The expectation spec says that the first `Bar(&quot;a&quot;)` must happen before</div><div class="line"><a name="l02591"></a><span class="lineno"> 2591</span>&#160;check point &quot;1&quot;, the second `Bar(&quot;a&quot;)` must happen after check point &quot;2&quot;,</div><div class="line"><a name="l02592"></a><span class="lineno"> 2592</span>&#160;and nothing should happen between the two check points. The explicit</div><div class="line"><a name="l02593"></a><span class="lineno"> 2593</span>&#160;check points make it easy to tell which `Bar(&quot;a&quot;)` is called by which</div><div class="line"><a name="l02594"></a><span class="lineno"> 2594</span>&#160;call to `Foo()`.</div><div class="line"><a name="l02595"></a><span class="lineno"> 2595</span>&#160;</div><div class="line"><a name="l02596"></a><span class="lineno"> 2596</span>&#160;## Mocking Destructors ##</div><div class="line"><a name="l02597"></a><span class="lineno"> 2597</span>&#160;</div><div class="line"><a name="l02598"></a><span class="lineno"> 2598</span>&#160;Sometimes you want to make sure a mock object is destructed at the</div><div class="line"><a name="l02599"></a><span class="lineno"> 2599</span>&#160;right time, e.g. after `bar-&gt;A()` is called but before `bar-&gt;B()` is</div><div class="line"><a name="l02600"></a><span class="lineno"> 2600</span>&#160;called. We already know that you can specify constraints on the order</div><div class="line"><a name="l02601"></a><span class="lineno"> 2601</span>&#160;of mock function calls, so all we need to do is to mock the destructor</div><div class="line"><a name="l02602"></a><span class="lineno"> 2602</span>&#160;of the mock function.</div><div class="line"><a name="l02603"></a><span class="lineno"> 2603</span>&#160;</div><div class="line"><a name="l02604"></a><span class="lineno"> 2604</span>&#160;This sounds simple, except for one problem: a destructor is a special</div><div class="line"><a name="l02605"></a><span class="lineno"> 2605</span>&#160;function with special syntax and special semantics, and the</div><div class="line"><a name="l02606"></a><span class="lineno"> 2606</span>&#160;`MOCK_METHOD0` macro doesn&#39;t work for it:</div><div class="line"><a name="l02607"></a><span class="lineno"> 2607</span>&#160;</div><div class="line"><a name="l02608"></a><span class="lineno"> 2608</span>&#160;```</div><div class="line"><a name="l02609"></a><span class="lineno"> 2609</span>&#160;  MOCK_METHOD0(~MockFoo, void());  // Won&#39;t compile!</div><div class="line"><a name="l02610"></a><span class="lineno"> 2610</span>&#160;```</div><div class="line"><a name="l02611"></a><span class="lineno"> 2611</span>&#160;</div><div class="line"><a name="l02612"></a><span class="lineno"> 2612</span>&#160;The good news is that you can use a simple pattern to achieve the same</div><div class="line"><a name="l02613"></a><span class="lineno"> 2613</span>&#160;effect. First, add a mock function `Die()` to your mock class and call</div><div class="line"><a name="l02614"></a><span class="lineno"> 2614</span>&#160;it in the destructor, like this:</div><div class="line"><a name="l02615"></a><span class="lineno"> 2615</span>&#160;</div><div class="line"><a name="l02616"></a><span class="lineno"> 2616</span>&#160;```</div><div class="line"><a name="l02617"></a><span class="lineno"> 2617</span>&#160;class MockFoo : public Foo {</div><div class="line"><a name="l02618"></a><span class="lineno"> 2618</span>&#160;  ...</div><div class="line"><a name="l02619"></a><span class="lineno"> 2619</span>&#160;  // Add the following two lines to the mock class.</div><div class="line"><a name="l02620"></a><span class="lineno"> 2620</span>&#160;  MOCK_METHOD0(Die, void());</div><div class="line"><a name="l02621"></a><span class="lineno"> 2621</span>&#160;  virtual ~MockFoo() { Die(); }</div><div class="line"><a name="l02622"></a><span class="lineno"> 2622</span>&#160;};</div><div class="line"><a name="l02623"></a><span class="lineno"> 2623</span>&#160;```</div><div class="line"><a name="l02624"></a><span class="lineno"> 2624</span>&#160;</div><div class="line"><a name="l02625"></a><span class="lineno"> 2625</span>&#160;(If the name `Die()` clashes with an existing symbol, choose another</div><div class="line"><a name="l02626"></a><span class="lineno"> 2626</span>&#160;name.) Now, we have translated the problem of testing when a `MockFoo`</div><div class="line"><a name="l02627"></a><span class="lineno"> 2627</span>&#160;object dies to testing when its `Die()` method is called:</div><div class="line"><a name="l02628"></a><span class="lineno"> 2628</span>&#160;</div><div class="line"><a name="l02629"></a><span class="lineno"> 2629</span>&#160;```</div><div class="line"><a name="l02630"></a><span class="lineno"> 2630</span>&#160;  MockFoo* foo = new MockFoo;</div><div class="line"><a name="l02631"></a><span class="lineno"> 2631</span>&#160;  MockBar* bar = new MockBar;</div><div class="line"><a name="l02632"></a><span class="lineno"> 2632</span>&#160;  ...</div><div class="line"><a name="l02633"></a><span class="lineno"> 2633</span>&#160;  {</div><div class="line"><a name="l02634"></a><span class="lineno"> 2634</span>&#160;    InSequence s;</div><div class="line"><a name="l02635"></a><span class="lineno"> 2635</span>&#160;</div><div class="line"><a name="l02636"></a><span class="lineno"> 2636</span>&#160;    // Expects *foo to die after bar-&gt;A() and before bar-&gt;B().</div><div class="line"><a name="l02637"></a><span class="lineno"> 2637</span>&#160;    EXPECT_CALL(*bar, A());</div><div class="line"><a name="l02638"></a><span class="lineno"> 2638</span>&#160;    EXPECT_CALL(*foo, Die());</div><div class="line"><a name="l02639"></a><span class="lineno"> 2639</span>&#160;    EXPECT_CALL(*bar, B());</div><div class="line"><a name="l02640"></a><span class="lineno"> 2640</span>&#160;  }</div><div class="line"><a name="l02641"></a><span class="lineno"> 2641</span>&#160;```</div><div class="line"><a name="l02642"></a><span class="lineno"> 2642</span>&#160;</div><div class="line"><a name="l02643"></a><span class="lineno"> 2643</span>&#160;And that&#39;s that.</div><div class="line"><a name="l02644"></a><span class="lineno"> 2644</span>&#160;</div><div class="line"><a name="l02645"></a><span class="lineno"> 2645</span>&#160;## Using Google Mock and Threads ##</div><div class="line"><a name="l02646"></a><span class="lineno"> 2646</span>&#160;</div><div class="line"><a name="l02647"></a><span class="lineno"> 2647</span>&#160;**IMPORTANT NOTE:** What we describe in this recipe is **ONLY** true on</div><div class="line"><a name="l02648"></a><span class="lineno"> 2648</span>&#160;platforms where Google Mock is thread-safe. Currently these are only</div><div class="line"><a name="l02649"></a><span class="lineno"> 2649</span>&#160;platforms that support the pthreads library (this includes Linux and Mac).</div><div class="line"><a name="l02650"></a><span class="lineno"> 2650</span>&#160;To make it thread-safe on other platforms we only need to implement</div><div class="line"><a name="l02651"></a><span class="lineno"> 2651</span>&#160;some synchronization operations in `&quot;gtest/internal/gtest-port.h&quot;`.</div><div class="line"><a name="l02652"></a><span class="lineno"> 2652</span>&#160;</div><div class="line"><a name="l02653"></a><span class="lineno"> 2653</span>&#160;In a **unit** test, it&#39;s best if you could isolate and test a piece of</div><div class="line"><a name="l02654"></a><span class="lineno"> 2654</span>&#160;code in a single-threaded context. That avoids race conditions and</div><div class="line"><a name="l02655"></a><span class="lineno"> 2655</span>&#160;dead locks, and makes debugging your test much easier.</div><div class="line"><a name="l02656"></a><span class="lineno"> 2656</span>&#160;</div><div class="line"><a name="l02657"></a><span class="lineno"> 2657</span>&#160;Yet many programs are multi-threaded, and sometimes to test something</div><div class="line"><a name="l02658"></a><span class="lineno"> 2658</span>&#160;we need to pound on it from more than one thread. Google Mock works</div><div class="line"><a name="l02659"></a><span class="lineno"> 2659</span>&#160;for this purpose too.</div><div class="line"><a name="l02660"></a><span class="lineno"> 2660</span>&#160;</div><div class="line"><a name="l02661"></a><span class="lineno"> 2661</span>&#160;Remember the steps for using a mock:</div><div class="line"><a name="l02662"></a><span class="lineno"> 2662</span>&#160;</div><div class="line"><a name="l02663"></a><span class="lineno"> 2663</span>&#160;  1. Create a mock object `foo`.</div><div class="line"><a name="l02664"></a><span class="lineno"> 2664</span>&#160;  1. Set its default actions and expectations using `ON_CALL()` and `EXPECT_CALL()`.</div><div class="line"><a name="l02665"></a><span class="lineno"> 2665</span>&#160;  1. The code under test calls methods of `foo`.</div><div class="line"><a name="l02666"></a><span class="lineno"> 2666</span>&#160;  1. Optionally, verify and reset the mock.</div><div class="line"><a name="l02667"></a><span class="lineno"> 2667</span>&#160;  1. Destroy the mock yourself, or let the code under test destroy it. The destructor will automatically verify it.</div><div class="line"><a name="l02668"></a><span class="lineno"> 2668</span>&#160;</div><div class="line"><a name="l02669"></a><span class="lineno"> 2669</span>&#160;If you follow the following simple rules, your mocks and threads can</div><div class="line"><a name="l02670"></a><span class="lineno"> 2670</span>&#160;live happily together:</div><div class="line"><a name="l02671"></a><span class="lineno"> 2671</span>&#160;</div><div class="line"><a name="l02672"></a><span class="lineno"> 2672</span>&#160;  * Execute your _test code_ (as opposed to the code being tested) in _one_ thread. This makes your test easy to follow.</div><div class="line"><a name="l02673"></a><span class="lineno"> 2673</span>&#160;  * Obviously, you can do step #1 without locking.</div><div class="line"><a name="l02674"></a><span class="lineno"> 2674</span>&#160;  * When doing step #2 and #5, make sure no other thread is accessing `foo`. Obvious too, huh?</div><div class="line"><a name="l02675"></a><span class="lineno"> 2675</span>&#160;  * #3 and #4 can be done either in one thread or in multiple threads - anyway you want. Google Mock takes care of the locking, so you don&#39;t have to do any - unless required by your test logic.</div><div class="line"><a name="l02676"></a><span class="lineno"> 2676</span>&#160;</div><div class="line"><a name="l02677"></a><span class="lineno"> 2677</span>&#160;If you violate the rules (for example, if you set expectations on a</div><div class="line"><a name="l02678"></a><span class="lineno"> 2678</span>&#160;mock while another thread is calling its methods), you get undefined</div><div class="line"><a name="l02679"></a><span class="lineno"> 2679</span>&#160;behavior. That&#39;s not fun, so don&#39;t do it.</div><div class="line"><a name="l02680"></a><span class="lineno"> 2680</span>&#160;</div><div class="line"><a name="l02681"></a><span class="lineno"> 2681</span>&#160;Google Mock guarantees that the action for a mock function is done in</div><div class="line"><a name="l02682"></a><span class="lineno"> 2682</span>&#160;the same thread that called the mock function. For example, in</div><div class="line"><a name="l02683"></a><span class="lineno"> 2683</span>&#160;</div><div class="line"><a name="l02684"></a><span class="lineno"> 2684</span>&#160;```</div><div class="line"><a name="l02685"></a><span class="lineno"> 2685</span>&#160;  EXPECT_CALL(mock, Foo(1))</div><div class="line"><a name="l02686"></a><span class="lineno"> 2686</span>&#160;      .WillOnce(action1);</div><div class="line"><a name="l02687"></a><span class="lineno"> 2687</span>&#160;  EXPECT_CALL(mock, Foo(2))</div><div class="line"><a name="l02688"></a><span class="lineno"> 2688</span>&#160;      .WillOnce(action2);</div><div class="line"><a name="l02689"></a><span class="lineno"> 2689</span>&#160;```</div><div class="line"><a name="l02690"></a><span class="lineno"> 2690</span>&#160;</div><div class="line"><a name="l02691"></a><span class="lineno"> 2691</span>&#160;if `Foo(1)` is called in thread 1 and `Foo(2)` is called in thread 2,</div><div class="line"><a name="l02692"></a><span class="lineno"> 2692</span>&#160;Google Mock will execute `action1` in thread 1 and `action2` in thread</div><div class="line"><a name="l02693"></a><span class="lineno"> 2693</span>&#160;2.</div><div class="line"><a name="l02694"></a><span class="lineno"> 2694</span>&#160;</div><div class="line"><a name="l02695"></a><span class="lineno"> 2695</span>&#160;Google Mock does _not_ impose a sequence on actions performed in</div><div class="line"><a name="l02696"></a><span class="lineno"> 2696</span>&#160;different threads (doing so may create deadlocks as the actions may</div><div class="line"><a name="l02697"></a><span class="lineno"> 2697</span>&#160;need to cooperate). This means that the execution of `action1` and</div><div class="line"><a name="l02698"></a><span class="lineno"> 2698</span>&#160;`action2` in the above example _may_ interleave. If this is a problem,</div><div class="line"><a name="l02699"></a><span class="lineno"> 2699</span>&#160;you should add proper synchronization logic to `action1` and `action2`</div><div class="line"><a name="l02700"></a><span class="lineno"> 2700</span>&#160;to make the test thread-safe.</div><div class="line"><a name="l02701"></a><span class="lineno"> 2701</span>&#160;</div><div class="line"><a name="l02702"></a><span class="lineno"> 2702</span>&#160;</div><div class="line"><a name="l02703"></a><span class="lineno"> 2703</span>&#160;Also, remember that `DefaultValue&lt;T&gt;` is a global resource that</div><div class="line"><a name="l02704"></a><span class="lineno"> 2704</span>&#160;potentially affects _all_ living mock objects in your</div><div class="line"><a name="l02705"></a><span class="lineno"> 2705</span>&#160;program. Naturally, you won&#39;t want to mess with it from multiple</div><div class="line"><a name="l02706"></a><span class="lineno"> 2706</span>&#160;threads or when there still are mocks in action.</div><div class="line"><a name="l02707"></a><span class="lineno"> 2707</span>&#160;</div><div class="line"><a name="l02708"></a><span class="lineno"> 2708</span>&#160;## Controlling How Much Information Google Mock Prints ##</div><div class="line"><a name="l02709"></a><span class="lineno"> 2709</span>&#160;</div><div class="line"><a name="l02710"></a><span class="lineno"> 2710</span>&#160;When Google Mock sees something that has the potential of being an</div><div class="line"><a name="l02711"></a><span class="lineno"> 2711</span>&#160;error (e.g. a mock function with no expectation is called, a.k.a. an</div><div class="line"><a name="l02712"></a><span class="lineno"> 2712</span>&#160;uninteresting call, which is allowed but perhaps you forgot to</div><div class="line"><a name="l02713"></a><span class="lineno"> 2713</span>&#160;explicitly ban the call), it prints some warning messages, including</div><div class="line"><a name="l02714"></a><span class="lineno"> 2714</span>&#160;the arguments of the function and the return value. Hopefully this</div><div class="line"><a name="l02715"></a><span class="lineno"> 2715</span>&#160;will remind you to take a look and see if there is indeed a problem.</div><div class="line"><a name="l02716"></a><span class="lineno"> 2716</span>&#160;</div><div class="line"><a name="l02717"></a><span class="lineno"> 2717</span>&#160;Sometimes you are confident that your tests are correct and may not</div><div class="line"><a name="l02718"></a><span class="lineno"> 2718</span>&#160;appreciate such friendly messages. Some other times, you are debugging</div><div class="line"><a name="l02719"></a><span class="lineno"> 2719</span>&#160;your tests or learning about the behavior of the code you are testing,</div><div class="line"><a name="l02720"></a><span class="lineno"> 2720</span>&#160;and wish you could observe every mock call that happens (including</div><div class="line"><a name="l02721"></a><span class="lineno"> 2721</span>&#160;argument values and the return value). Clearly, one size doesn&#39;t fit</div><div class="line"><a name="l02722"></a><span class="lineno"> 2722</span>&#160;all.</div><div class="line"><a name="l02723"></a><span class="lineno"> 2723</span>&#160;</div><div class="line"><a name="l02724"></a><span class="lineno"> 2724</span>&#160;You can control how much Google Mock tells you using the</div><div class="line"><a name="l02725"></a><span class="lineno"> 2725</span>&#160;`--gmock_verbose=LEVEL` command-line flag, where `LEVEL` is a string</div><div class="line"><a name="l02726"></a><span class="lineno"> 2726</span>&#160;with three possible values:</div><div class="line"><a name="l02727"></a><span class="lineno"> 2727</span>&#160;</div><div class="line"><a name="l02728"></a><span class="lineno"> 2728</span>&#160;  * `info`: Google Mock will print all informational messages, warnings, and errors (most verbose). At this setting, Google Mock will also log any calls to the `ON_CALL/EXPECT_CALL` macros.</div><div class="line"><a name="l02729"></a><span class="lineno"> 2729</span>&#160;  * `warning`: Google Mock will print both warnings and errors (less verbose). This is the default.</div><div class="line"><a name="l02730"></a><span class="lineno"> 2730</span>&#160;  * `error`: Google Mock will print errors only (least verbose).</div><div class="line"><a name="l02731"></a><span class="lineno"> 2731</span>&#160;</div><div class="line"><a name="l02732"></a><span class="lineno"> 2732</span>&#160;Alternatively, you can adjust the value of that flag from within your</div><div class="line"><a name="l02733"></a><span class="lineno"> 2733</span>&#160;tests like so:</div><div class="line"><a name="l02734"></a><span class="lineno"> 2734</span>&#160;</div><div class="line"><a name="l02735"></a><span class="lineno"> 2735</span>&#160;```</div><div class="line"><a name="l02736"></a><span class="lineno"> 2736</span>&#160;  ::testing::FLAGS_gmock_verbose = &quot;error&quot;;</div><div class="line"><a name="l02737"></a><span class="lineno"> 2737</span>&#160;```</div><div class="line"><a name="l02738"></a><span class="lineno"> 2738</span>&#160;</div><div class="line"><a name="l02739"></a><span class="lineno"> 2739</span>&#160;Now, judiciously use the right flag to enable Google Mock serve you better!</div><div class="line"><a name="l02740"></a><span class="lineno"> 2740</span>&#160;</div><div class="line"><a name="l02741"></a><span class="lineno"> 2741</span>&#160;## Gaining Super Vision into Mock Calls ##</div><div class="line"><a name="l02742"></a><span class="lineno"> 2742</span>&#160;</div><div class="line"><a name="l02743"></a><span class="lineno"> 2743</span>&#160;You have a test using Google Mock. It fails: Google Mock tells you</div><div class="line"><a name="l02744"></a><span class="lineno"> 2744</span>&#160;that some expectations aren&#39;t satisfied. However, you aren&#39;t sure why:</div><div class="line"><a name="l02745"></a><span class="lineno"> 2745</span>&#160;Is there a typo somewhere in the matchers? Did you mess up the order</div><div class="line"><a name="l02746"></a><span class="lineno"> 2746</span>&#160;of the `EXPECT_CALL`s? Or is the code under test doing something</div><div class="line"><a name="l02747"></a><span class="lineno"> 2747</span>&#160;wrong?  How can you find out the cause?</div><div class="line"><a name="l02748"></a><span class="lineno"> 2748</span>&#160;</div><div class="line"><a name="l02749"></a><span class="lineno"> 2749</span>&#160;Won&#39;t it be nice if you have X-ray vision and can actually see the</div><div class="line"><a name="l02750"></a><span class="lineno"> 2750</span>&#160;trace of all `EXPECT_CALL`s and mock method calls as they are made?</div><div class="line"><a name="l02751"></a><span class="lineno"> 2751</span>&#160;For each call, would you like to see its actual argument values and</div><div class="line"><a name="l02752"></a><span class="lineno"> 2752</span>&#160;which `EXPECT_CALL` Google Mock thinks it matches?</div><div class="line"><a name="l02753"></a><span class="lineno"> 2753</span>&#160;</div><div class="line"><a name="l02754"></a><span class="lineno"> 2754</span>&#160;You can unlock this power by running your test with the</div><div class="line"><a name="l02755"></a><span class="lineno"> 2755</span>&#160;`--gmock_verbose=info` flag. For example, given the test program:</div><div class="line"><a name="l02756"></a><span class="lineno"> 2756</span>&#160;</div><div class="line"><a name="l02757"></a><span class="lineno"> 2757</span>&#160;```</div><div class="line"><a name="l02758"></a><span class="lineno"> 2758</span>&#160;using testing::_;</div><div class="line"><a name="l02759"></a><span class="lineno"> 2759</span>&#160;using testing::HasSubstr;</div><div class="line"><a name="l02760"></a><span class="lineno"> 2760</span>&#160;using testing::Return;</div><div class="line"><a name="l02761"></a><span class="lineno"> 2761</span>&#160;</div><div class="line"><a name="l02762"></a><span class="lineno"> 2762</span>&#160;class MockFoo {</div><div class="line"><a name="l02763"></a><span class="lineno"> 2763</span>&#160; public:</div><div class="line"><a name="l02764"></a><span class="lineno"> 2764</span>&#160;  MOCK_METHOD2(F, void(const string&amp; x, const string&amp; y));</div><div class="line"><a name="l02765"></a><span class="lineno"> 2765</span>&#160;};</div><div class="line"><a name="l02766"></a><span class="lineno"> 2766</span>&#160;</div><div class="line"><a name="l02767"></a><span class="lineno"> 2767</span>&#160;TEST(Foo, Bar) {</div><div class="line"><a name="l02768"></a><span class="lineno"> 2768</span>&#160;  MockFoo mock;</div><div class="line"><a name="l02769"></a><span class="lineno"> 2769</span>&#160;  EXPECT_CALL(mock, F(_, _)).WillRepeatedly(Return());</div><div class="line"><a name="l02770"></a><span class="lineno"> 2770</span>&#160;  EXPECT_CALL(mock, F(&quot;a&quot;, &quot;b&quot;));</div><div class="line"><a name="l02771"></a><span class="lineno"> 2771</span>&#160;  EXPECT_CALL(mock, F(&quot;c&quot;, HasSubstr(&quot;d&quot;)));</div><div class="line"><a name="l02772"></a><span class="lineno"> 2772</span>&#160;</div><div class="line"><a name="l02773"></a><span class="lineno"> 2773</span>&#160;  mock.F(&quot;a&quot;, &quot;good&quot;);</div><div class="line"><a name="l02774"></a><span class="lineno"> 2774</span>&#160;  mock.F(&quot;a&quot;, &quot;b&quot;);</div><div class="line"><a name="l02775"></a><span class="lineno"> 2775</span>&#160;}</div><div class="line"><a name="l02776"></a><span class="lineno"> 2776</span>&#160;```</div><div class="line"><a name="l02777"></a><span class="lineno"> 2777</span>&#160;</div><div class="line"><a name="l02778"></a><span class="lineno"> 2778</span>&#160;if you run it with `--gmock_verbose=info`, you will see this output:</div><div class="line"><a name="l02779"></a><span class="lineno"> 2779</span>&#160;</div><div class="line"><a name="l02780"></a><span class="lineno"> 2780</span>&#160;```</div><div class="line"><a name="l02781"></a><span class="lineno"> 2781</span>&#160;[ RUN      ] Foo.Bar</div><div class="line"><a name="l02782"></a><span class="lineno"> 2782</span>&#160;</div><div class="line"><a name="l02783"></a><span class="lineno"> 2783</span>&#160;foo_test.cc:14: EXPECT_CALL(mock, F(_, _)) invoked</div><div class="line"><a name="l02784"></a><span class="lineno"> 2784</span>&#160;foo_test.cc:15: EXPECT_CALL(mock, F(&quot;a&quot;, &quot;b&quot;)) invoked</div><div class="line"><a name="l02785"></a><span class="lineno"> 2785</span>&#160;foo_test.cc:16: EXPECT_CALL(mock, F(&quot;c&quot;, HasSubstr(&quot;d&quot;))) invoked</div><div class="line"><a name="l02786"></a><span class="lineno"> 2786</span>&#160;foo_test.cc:14: Mock function call matches EXPECT_CALL(mock, F(_, _))...</div><div class="line"><a name="l02787"></a><span class="lineno"> 2787</span>&#160;    Function call: F(@0x7fff7c8dad40&quot;a&quot;, @0x7fff7c8dad10&quot;good&quot;)</div><div class="line"><a name="l02788"></a><span class="lineno"> 2788</span>&#160;foo_test.cc:15: Mock function call matches EXPECT_CALL(mock, F(&quot;a&quot;, &quot;b&quot;))...</div><div class="line"><a name="l02789"></a><span class="lineno"> 2789</span>&#160;    Function call: F(@0x7fff7c8dada0&quot;a&quot;, @0x7fff7c8dad70&quot;b&quot;)</div><div class="line"><a name="l02790"></a><span class="lineno"> 2790</span>&#160;foo_test.cc:16: Failure</div><div class="line"><a name="l02791"></a><span class="lineno"> 2791</span>&#160;Actual function call count doesn&#39;t match EXPECT_CALL(mock, F(&quot;c&quot;, HasSubstr(&quot;d&quot;)))...</div><div class="line"><a name="l02792"></a><span class="lineno"> 2792</span>&#160;         Expected: to be called once</div><div class="line"><a name="l02793"></a><span class="lineno"> 2793</span>&#160;           Actual: never called - unsatisfied and active</div><div class="line"><a name="l02794"></a><span class="lineno"> 2794</span>&#160;[  FAILED  ] Foo.Bar</div><div class="line"><a name="l02795"></a><span class="lineno"> 2795</span>&#160;```</div><div class="line"><a name="l02796"></a><span class="lineno"> 2796</span>&#160;</div><div class="line"><a name="l02797"></a><span class="lineno"> 2797</span>&#160;Suppose the bug is that the `&quot;c&quot;` in the third `EXPECT_CALL` is a typo</div><div class="line"><a name="l02798"></a><span class="lineno"> 2798</span>&#160;and should actually be `&quot;a&quot;`. With the above message, you should see</div><div class="line"><a name="l02799"></a><span class="lineno"> 2799</span>&#160;that the actual `F(&quot;a&quot;, &quot;good&quot;)` call is matched by the first</div><div class="line"><a name="l02800"></a><span class="lineno"> 2800</span>&#160;`EXPECT_CALL`, not the third as you thought. From that it should be</div><div class="line"><a name="l02801"></a><span class="lineno"> 2801</span>&#160;obvious that the third `EXPECT_CALL` is written wrong. Case solved.</div><div class="line"><a name="l02802"></a><span class="lineno"> 2802</span>&#160;</div><div class="line"><a name="l02803"></a><span class="lineno"> 2803</span>&#160;## Running Tests in Emacs ##</div><div class="line"><a name="l02804"></a><span class="lineno"> 2804</span>&#160;</div><div class="line"><a name="l02805"></a><span class="lineno"> 2805</span>&#160;If you build and run your tests in Emacs, the source file locations of</div><div class="line"><a name="l02806"></a><span class="lineno"> 2806</span>&#160;Google Mock and [Google Test](../../googletest/)</div><div class="line"><a name="l02807"></a><span class="lineno"> 2807</span>&#160;errors will be highlighted. Just press `&lt;Enter&gt;` on one of them and</div><div class="line"><a name="l02808"></a><span class="lineno"> 2808</span>&#160;you&#39;ll be taken to the offending line. Or, you can just type `C-x ``</div><div class="line"><a name="l02809"></a><span class="lineno"> 2809</span>&#160;to jump to the next error.</div><div class="line"><a name="l02810"></a><span class="lineno"> 2810</span>&#160;</div><div class="line"><a name="l02811"></a><span class="lineno"> 2811</span>&#160;To make it even easier, you can add the following lines to your</div><div class="line"><a name="l02812"></a><span class="lineno"> 2812</span>&#160;`~/.emacs` file:</div><div class="line"><a name="l02813"></a><span class="lineno"> 2813</span>&#160;</div><div class="line"><a name="l02814"></a><span class="lineno"> 2814</span>&#160;```</div><div class="line"><a name="l02815"></a><span class="lineno"> 2815</span>&#160;(global-set-key &quot;\M-m&quot;   &#39;compile)  ; m is for make</div><div class="line"><a name="l02816"></a><span class="lineno"> 2816</span>&#160;(global-set-key [M-down] &#39;next-error)</div><div class="line"><a name="l02817"></a><span class="lineno"> 2817</span>&#160;(global-set-key [M-up]   &#39;(lambda () (interactive) (next-error -1)))</div><div class="line"><a name="l02818"></a><span class="lineno"> 2818</span>&#160;```</div><div class="line"><a name="l02819"></a><span class="lineno"> 2819</span>&#160;</div><div class="line"><a name="l02820"></a><span class="lineno"> 2820</span>&#160;Then you can type `M-m` to start a build, or `M-up`/`M-down` to move</div><div class="line"><a name="l02821"></a><span class="lineno"> 2821</span>&#160;back and forth between errors.</div><div class="line"><a name="l02822"></a><span class="lineno"> 2822</span>&#160;</div><div class="line"><a name="l02823"></a><span class="lineno"> 2823</span>&#160;## Fusing Google Mock Source Files ##</div><div class="line"><a name="l02824"></a><span class="lineno"> 2824</span>&#160;</div><div class="line"><a name="l02825"></a><span class="lineno"> 2825</span>&#160;Google Mock&#39;s implementation consists of dozens of files (excluding</div><div class="line"><a name="l02826"></a><span class="lineno"> 2826</span>&#160;its own tests).  Sometimes you may want them to be packaged up in</div><div class="line"><a name="l02827"></a><span class="lineno"> 2827</span>&#160;fewer files instead, such that you can easily copy them to a new</div><div class="line"><a name="l02828"></a><span class="lineno"> 2828</span>&#160;machine and start hacking there.  For this we provide an experimental</div><div class="line"><a name="l02829"></a><span class="lineno"> 2829</span>&#160;Python script `fuse_gmock_files.py` in the `scripts/` directory</div><div class="line"><a name="l02830"></a><span class="lineno"> 2830</span>&#160;(starting with release 1.2.0).  Assuming you have Python 2.4 or above</div><div class="line"><a name="l02831"></a><span class="lineno"> 2831</span>&#160;installed on your machine, just go to that directory and run</div><div class="line"><a name="l02832"></a><span class="lineno"> 2832</span>&#160;```</div><div class="line"><a name="l02833"></a><span class="lineno"> 2833</span>&#160;python fuse_gmock_files.py OUTPUT_DIR</div><div class="line"><a name="l02834"></a><span class="lineno"> 2834</span>&#160;```</div><div class="line"><a name="l02835"></a><span class="lineno"> 2835</span>&#160;</div><div class="line"><a name="l02836"></a><span class="lineno"> 2836</span>&#160;and you should see an `OUTPUT_DIR` directory being created with files</div><div class="line"><a name="l02837"></a><span class="lineno"> 2837</span>&#160;`gtest/gtest.h`, `gmock/gmock.h`, and `gmock-gtest-all.cc` in it.</div><div class="line"><a name="l02838"></a><span class="lineno"> 2838</span>&#160;These three files contain everything you need to use Google Mock (and</div><div class="line"><a name="l02839"></a><span class="lineno"> 2839</span>&#160;Google Test).  Just copy them to anywhere you want and you are ready</div><div class="line"><a name="l02840"></a><span class="lineno"> 2840</span>&#160;to write tests and use mocks.  You can use the</div><div class="line"><a name="l02841"></a><span class="lineno"> 2841</span>&#160;[scrpts/test/Makefile](../scripts/test/Makefile) file as an example on how to compile your tests</div><div class="line"><a name="l02842"></a><span class="lineno"> 2842</span>&#160;against them.</div><div class="line"><a name="l02843"></a><span class="lineno"> 2843</span>&#160;</div><div class="line"><a name="l02844"></a><span class="lineno"> 2844</span>&#160;# Extending Google Mock #</div><div class="line"><a name="l02845"></a><span class="lineno"> 2845</span>&#160;</div><div class="line"><a name="l02846"></a><span class="lineno"> 2846</span>&#160;## Writing New Matchers Quickly ##</div><div class="line"><a name="l02847"></a><span class="lineno"> 2847</span>&#160;</div><div class="line"><a name="l02848"></a><span class="lineno"> 2848</span>&#160;The `MATCHER*` family of macros can be used to define custom matchers</div><div class="line"><a name="l02849"></a><span class="lineno"> 2849</span>&#160;easily.  The syntax:</div><div class="line"><a name="l02850"></a><span class="lineno"> 2850</span>&#160;</div><div class="line"><a name="l02851"></a><span class="lineno"> 2851</span>&#160;```</div><div class="line"><a name="l02852"></a><span class="lineno"> 2852</span>&#160;MATCHER(name, description_string_expression) { statements; }</div><div class="line"><a name="l02853"></a><span class="lineno"> 2853</span>&#160;```</div><div class="line"><a name="l02854"></a><span class="lineno"> 2854</span>&#160;</div><div class="line"><a name="l02855"></a><span class="lineno"> 2855</span>&#160;will define a matcher with the given name that executes the</div><div class="line"><a name="l02856"></a><span class="lineno"> 2856</span>&#160;statements, which must return a `bool` to indicate if the match</div><div class="line"><a name="l02857"></a><span class="lineno"> 2857</span>&#160;succeeds.  Inside the statements, you can refer to the value being</div><div class="line"><a name="l02858"></a><span class="lineno"> 2858</span>&#160;matched by `arg`, and refer to its type by `arg_type`.</div><div class="line"><a name="l02859"></a><span class="lineno"> 2859</span>&#160;</div><div class="line"><a name="l02860"></a><span class="lineno"> 2860</span>&#160;The description string is a `string`-typed expression that documents</div><div class="line"><a name="l02861"></a><span class="lineno"> 2861</span>&#160;what the matcher does, and is used to generate the failure message</div><div class="line"><a name="l02862"></a><span class="lineno"> 2862</span>&#160;when the match fails.  It can (and should) reference the special</div><div class="line"><a name="l02863"></a><span class="lineno"> 2863</span>&#160;`bool` variable `negation`, and should evaluate to the description of</div><div class="line"><a name="l02864"></a><span class="lineno"> 2864</span>&#160;the matcher when `negation` is `false`, or that of the matcher&#39;s</div><div class="line"><a name="l02865"></a><span class="lineno"> 2865</span>&#160;negation when `negation` is `true`.</div><div class="line"><a name="l02866"></a><span class="lineno"> 2866</span>&#160;</div><div class="line"><a name="l02867"></a><span class="lineno"> 2867</span>&#160;For convenience, we allow the description string to be empty (`&quot;&quot;`),</div><div class="line"><a name="l02868"></a><span class="lineno"> 2868</span>&#160;in which case Google Mock will use the sequence of words in the</div><div class="line"><a name="l02869"></a><span class="lineno"> 2869</span>&#160;matcher name as the description.</div><div class="line"><a name="l02870"></a><span class="lineno"> 2870</span>&#160;</div><div class="line"><a name="l02871"></a><span class="lineno"> 2871</span>&#160;For example:</div><div class="line"><a name="l02872"></a><span class="lineno"> 2872</span>&#160;```</div><div class="line"><a name="l02873"></a><span class="lineno"> 2873</span>&#160;MATCHER(IsDivisibleBy7, &quot;&quot;) { return (arg % 7) == 0; }</div><div class="line"><a name="l02874"></a><span class="lineno"> 2874</span>&#160;```</div><div class="line"><a name="l02875"></a><span class="lineno"> 2875</span>&#160;allows you to write</div><div class="line"><a name="l02876"></a><span class="lineno"> 2876</span>&#160;```</div><div class="line"><a name="l02877"></a><span class="lineno"> 2877</span>&#160;  // Expects mock_foo.Bar(n) to be called where n is divisible by 7.</div><div class="line"><a name="l02878"></a><span class="lineno"> 2878</span>&#160;  EXPECT_CALL(mock_foo, Bar(IsDivisibleBy7()));</div><div class="line"><a name="l02879"></a><span class="lineno"> 2879</span>&#160;```</div><div class="line"><a name="l02880"></a><span class="lineno"> 2880</span>&#160;or,</div><div class="line"><a name="l02881"></a><span class="lineno"> 2881</span>&#160;```</div><div class="line"><a name="l02882"></a><span class="lineno"> 2882</span>&#160;using ::testing::Not;</div><div class="line"><a name="l02883"></a><span class="lineno"> 2883</span>&#160;...</div><div class="line"><a name="l02884"></a><span class="lineno"> 2884</span>&#160;  EXPECT_THAT(some_expression, IsDivisibleBy7());</div><div class="line"><a name="l02885"></a><span class="lineno"> 2885</span>&#160;  EXPECT_THAT(some_other_expression, Not(IsDivisibleBy7()));</div><div class="line"><a name="l02886"></a><span class="lineno"> 2886</span>&#160;```</div><div class="line"><a name="l02887"></a><span class="lineno"> 2887</span>&#160;If the above assertions fail, they will print something like:</div><div class="line"><a name="l02888"></a><span class="lineno"> 2888</span>&#160;```</div><div class="line"><a name="l02889"></a><span class="lineno"> 2889</span>&#160;  Value of: some_expression</div><div class="line"><a name="l02890"></a><span class="lineno"> 2890</span>&#160;  Expected: is divisible by 7</div><div class="line"><a name="l02891"></a><span class="lineno"> 2891</span>&#160;    Actual: 27</div><div class="line"><a name="l02892"></a><span class="lineno"> 2892</span>&#160;...</div><div class="line"><a name="l02893"></a><span class="lineno"> 2893</span>&#160;  Value of: some_other_expression</div><div class="line"><a name="l02894"></a><span class="lineno"> 2894</span>&#160;  Expected: not (is divisible by 7)</div><div class="line"><a name="l02895"></a><span class="lineno"> 2895</span>&#160;    Actual: 21</div><div class="line"><a name="l02896"></a><span class="lineno"> 2896</span>&#160;```</div><div class="line"><a name="l02897"></a><span class="lineno"> 2897</span>&#160;where the descriptions `&quot;is divisible by 7&quot;` and `&quot;not (is divisible</div><div class="line"><a name="l02898"></a><span class="lineno"> 2898</span>&#160;by 7)&quot;` are automatically calculated from the matcher name</div><div class="line"><a name="l02899"></a><span class="lineno"> 2899</span>&#160;`IsDivisibleBy7`.</div><div class="line"><a name="l02900"></a><span class="lineno"> 2900</span>&#160;</div><div class="line"><a name="l02901"></a><span class="lineno"> 2901</span>&#160;As you may have noticed, the auto-generated descriptions (especially</div><div class="line"><a name="l02902"></a><span class="lineno"> 2902</span>&#160;those for the negation) may not be so great. You can always override</div><div class="line"><a name="l02903"></a><span class="lineno"> 2903</span>&#160;them with a string expression of your own:</div><div class="line"><a name="l02904"></a><span class="lineno"> 2904</span>&#160;```</div><div class="line"><a name="l02905"></a><span class="lineno"> 2905</span>&#160;MATCHER(IsDivisibleBy7, std::string(negation ? &quot;isn&#39;t&quot; : &quot;is&quot;) +</div><div class="line"><a name="l02906"></a><span class="lineno"> 2906</span>&#160;                        &quot; divisible by 7&quot;) {</div><div class="line"><a name="l02907"></a><span class="lineno"> 2907</span>&#160;  return (arg % 7) == 0;</div><div class="line"><a name="l02908"></a><span class="lineno"> 2908</span>&#160;}</div><div class="line"><a name="l02909"></a><span class="lineno"> 2909</span>&#160;```</div><div class="line"><a name="l02910"></a><span class="lineno"> 2910</span>&#160;</div><div class="line"><a name="l02911"></a><span class="lineno"> 2911</span>&#160;Optionally, you can stream additional information to a hidden argument</div><div class="line"><a name="l02912"></a><span class="lineno"> 2912</span>&#160;named `result_listener` to explain the match result. For example, a</div><div class="line"><a name="l02913"></a><span class="lineno"> 2913</span>&#160;better definition of `IsDivisibleBy7` is:</div><div class="line"><a name="l02914"></a><span class="lineno"> 2914</span>&#160;```</div><div class="line"><a name="l02915"></a><span class="lineno"> 2915</span>&#160;MATCHER(IsDivisibleBy7, &quot;&quot;) {</div><div class="line"><a name="l02916"></a><span class="lineno"> 2916</span>&#160;  if ((arg % 7) == 0)</div><div class="line"><a name="l02917"></a><span class="lineno"> 2917</span>&#160;    return true;</div><div class="line"><a name="l02918"></a><span class="lineno"> 2918</span>&#160;</div><div class="line"><a name="l02919"></a><span class="lineno"> 2919</span>&#160;  *result_listener &lt;&lt; &quot;the remainder is &quot; &lt;&lt; (arg % 7);</div><div class="line"><a name="l02920"></a><span class="lineno"> 2920</span>&#160;  return false;</div><div class="line"><a name="l02921"></a><span class="lineno"> 2921</span>&#160;}</div><div class="line"><a name="l02922"></a><span class="lineno"> 2922</span>&#160;```</div><div class="line"><a name="l02923"></a><span class="lineno"> 2923</span>&#160;</div><div class="line"><a name="l02924"></a><span class="lineno"> 2924</span>&#160;With this definition, the above assertion will give a better message:</div><div class="line"><a name="l02925"></a><span class="lineno"> 2925</span>&#160;```</div><div class="line"><a name="l02926"></a><span class="lineno"> 2926</span>&#160;  Value of: some_expression</div><div class="line"><a name="l02927"></a><span class="lineno"> 2927</span>&#160;  Expected: is divisible by 7</div><div class="line"><a name="l02928"></a><span class="lineno"> 2928</span>&#160;    Actual: 27 (the remainder is 6)</div><div class="line"><a name="l02929"></a><span class="lineno"> 2929</span>&#160;```</div><div class="line"><a name="l02930"></a><span class="lineno"> 2930</span>&#160;</div><div class="line"><a name="l02931"></a><span class="lineno"> 2931</span>&#160;You should let `MatchAndExplain()` print _any additional information_</div><div class="line"><a name="l02932"></a><span class="lineno"> 2932</span>&#160;that can help a user understand the match result. Note that it should</div><div class="line"><a name="l02933"></a><span class="lineno"> 2933</span>&#160;explain why the match succeeds in case of a success (unless it&#39;s</div><div class="line"><a name="l02934"></a><span class="lineno"> 2934</span>&#160;obvious) - this is useful when the matcher is used inside</div><div class="line"><a name="l02935"></a><span class="lineno"> 2935</span>&#160;`Not()`. There is no need to print the argument value itself, as</div><div class="line"><a name="l02936"></a><span class="lineno"> 2936</span>&#160;Google Mock already prints it for you.</div><div class="line"><a name="l02937"></a><span class="lineno"> 2937</span>&#160;</div><div class="line"><a name="l02938"></a><span class="lineno"> 2938</span>&#160;**Notes:**</div><div class="line"><a name="l02939"></a><span class="lineno"> 2939</span>&#160;</div><div class="line"><a name="l02940"></a><span class="lineno"> 2940</span>&#160;  1. The type of the value being matched (`arg_type`) is determined by the context in which you use the matcher and is supplied to you by the compiler, so you don&#39;t need to worry about declaring it (nor can you).  This allows the matcher to be polymorphic.  For example, `IsDivisibleBy7()` can be used to match any type where the value of `(arg % 7) == 0` can be implicitly converted to a `bool`.  In the `Bar(IsDivisibleBy7())` example above, if method `Bar()` takes an `int`, `arg_type` will be `int`; if it takes an `unsigned long`, `arg_type` will be `unsigned long`; and so on.</div><div class="line"><a name="l02941"></a><span class="lineno"> 2941</span>&#160;  1. Google Mock doesn&#39;t guarantee when or how many times a matcher will be invoked. Therefore the matcher logic must be _purely functional_ (i.e. it cannot have any side effect, and the result must not depend on anything other than the value being matched and the matcher parameters). This requirement must be satisfied no matter how you define the matcher (e.g. using one of the methods described in the following recipes). In particular, a matcher can never call a mock function, as that will affect the state of the mock object and Google Mock.</div><div class="line"><a name="l02942"></a><span class="lineno"> 2942</span>&#160;</div><div class="line"><a name="l02943"></a><span class="lineno"> 2943</span>&#160;## Writing New Parameterized Matchers Quickly ##</div><div class="line"><a name="l02944"></a><span class="lineno"> 2944</span>&#160;</div><div class="line"><a name="l02945"></a><span class="lineno"> 2945</span>&#160;Sometimes you&#39;ll want to define a matcher that has parameters.  For that you</div><div class="line"><a name="l02946"></a><span class="lineno"> 2946</span>&#160;can use the macro:</div><div class="line"><a name="l02947"></a><span class="lineno"> 2947</span>&#160;```</div><div class="line"><a name="l02948"></a><span class="lineno"> 2948</span>&#160;MATCHER_P(name, param_name, description_string) { statements; }</div><div class="line"><a name="l02949"></a><span class="lineno"> 2949</span>&#160;```</div><div class="line"><a name="l02950"></a><span class="lineno"> 2950</span>&#160;where the description string can be either `&quot;&quot;` or a string expression</div><div class="line"><a name="l02951"></a><span class="lineno"> 2951</span>&#160;that references `negation` and `param_name`.</div><div class="line"><a name="l02952"></a><span class="lineno"> 2952</span>&#160;</div><div class="line"><a name="l02953"></a><span class="lineno"> 2953</span>&#160;For example:</div><div class="line"><a name="l02954"></a><span class="lineno"> 2954</span>&#160;```</div><div class="line"><a name="l02955"></a><span class="lineno"> 2955</span>&#160;MATCHER_P(HasAbsoluteValue, value, &quot;&quot;) { return abs(arg) == value; }</div><div class="line"><a name="l02956"></a><span class="lineno"> 2956</span>&#160;```</div><div class="line"><a name="l02957"></a><span class="lineno"> 2957</span>&#160;will allow you to write:</div><div class="line"><a name="l02958"></a><span class="lineno"> 2958</span>&#160;```</div><div class="line"><a name="l02959"></a><span class="lineno"> 2959</span>&#160;  EXPECT_THAT(Blah(&quot;a&quot;), HasAbsoluteValue(n));</div><div class="line"><a name="l02960"></a><span class="lineno"> 2960</span>&#160;```</div><div class="line"><a name="l02961"></a><span class="lineno"> 2961</span>&#160;which may lead to this message (assuming `n` is 10):</div><div class="line"><a name="l02962"></a><span class="lineno"> 2962</span>&#160;```</div><div class="line"><a name="l02963"></a><span class="lineno"> 2963</span>&#160;  Value of: Blah(&quot;a&quot;)</div><div class="line"><a name="l02964"></a><span class="lineno"> 2964</span>&#160;  Expected: has absolute value 10</div><div class="line"><a name="l02965"></a><span class="lineno"> 2965</span>&#160;    Actual: -9</div><div class="line"><a name="l02966"></a><span class="lineno"> 2966</span>&#160;```</div><div class="line"><a name="l02967"></a><span class="lineno"> 2967</span>&#160;</div><div class="line"><a name="l02968"></a><span class="lineno"> 2968</span>&#160;Note that both the matcher description and its parameter are</div><div class="line"><a name="l02969"></a><span class="lineno"> 2969</span>&#160;printed, making the message human-friendly.</div><div class="line"><a name="l02970"></a><span class="lineno"> 2970</span>&#160;</div><div class="line"><a name="l02971"></a><span class="lineno"> 2971</span>&#160;In the matcher definition body, you can write `foo_type` to</div><div class="line"><a name="l02972"></a><span class="lineno"> 2972</span>&#160;reference the type of a parameter named `foo`.  For example, in the</div><div class="line"><a name="l02973"></a><span class="lineno"> 2973</span>&#160;body of `MATCHER_P(HasAbsoluteValue, value)` above, you can write</div><div class="line"><a name="l02974"></a><span class="lineno"> 2974</span>&#160;`value_type` to refer to the type of `value`.</div><div class="line"><a name="l02975"></a><span class="lineno"> 2975</span>&#160;</div><div class="line"><a name="l02976"></a><span class="lineno"> 2976</span>&#160;Google Mock also provides `MATCHER_P2`, `MATCHER_P3`, ..., up to</div><div class="line"><a name="l02977"></a><span class="lineno"> 2977</span>&#160;`MATCHER_P10` to support multi-parameter matchers:</div><div class="line"><a name="l02978"></a><span class="lineno"> 2978</span>&#160;```</div><div class="line"><a name="l02979"></a><span class="lineno"> 2979</span>&#160;MATCHER_Pk(name, param_1, ..., param_k, description_string) { statements; }</div><div class="line"><a name="l02980"></a><span class="lineno"> 2980</span>&#160;```</div><div class="line"><a name="l02981"></a><span class="lineno"> 2981</span>&#160;</div><div class="line"><a name="l02982"></a><span class="lineno"> 2982</span>&#160;Please note that the custom description string is for a particular</div><div class="line"><a name="l02983"></a><span class="lineno"> 2983</span>&#160;**instance** of the matcher, where the parameters have been bound to</div><div class="line"><a name="l02984"></a><span class="lineno"> 2984</span>&#160;actual values.  Therefore usually you&#39;ll want the parameter values to</div><div class="line"><a name="l02985"></a><span class="lineno"> 2985</span>&#160;be part of the description.  Google Mock lets you do that by</div><div class="line"><a name="l02986"></a><span class="lineno"> 2986</span>&#160;referencing the matcher parameters in the description string</div><div class="line"><a name="l02987"></a><span class="lineno"> 2987</span>&#160;expression.</div><div class="line"><a name="l02988"></a><span class="lineno"> 2988</span>&#160;</div><div class="line"><a name="l02989"></a><span class="lineno"> 2989</span>&#160;For example,</div><div class="line"><a name="l02990"></a><span class="lineno"> 2990</span>&#160;```</div><div class="line"><a name="l02991"></a><span class="lineno"> 2991</span>&#160;  using ::testing::PrintToString;</div><div class="line"><a name="l02992"></a><span class="lineno"> 2992</span>&#160;  MATCHER_P2(InClosedRange, low, hi,</div><div class="line"><a name="l02993"></a><span class="lineno"> 2993</span>&#160;             std::string(negation ? &quot;isn&#39;t&quot; : &quot;is&quot;) + &quot; in range [&quot; +</div><div class="line"><a name="l02994"></a><span class="lineno"> 2994</span>&#160;             PrintToString(low) + &quot;, &quot; + PrintToString(hi) + &quot;]&quot;) {</div><div class="line"><a name="l02995"></a><span class="lineno"> 2995</span>&#160;    return low &lt;= arg &amp;&amp; arg &lt;= hi;</div><div class="line"><a name="l02996"></a><span class="lineno"> 2996</span>&#160;  }</div><div class="line"><a name="l02997"></a><span class="lineno"> 2997</span>&#160;  ...</div><div class="line"><a name="l02998"></a><span class="lineno"> 2998</span>&#160;  EXPECT_THAT(3, InClosedRange(4, 6));</div><div class="line"><a name="l02999"></a><span class="lineno"> 2999</span>&#160;```</div><div class="line"><a name="l03000"></a><span class="lineno"> 3000</span>&#160;would generate a failure that contains the message:</div><div class="line"><a name="l03001"></a><span class="lineno"> 3001</span>&#160;```</div><div class="line"><a name="l03002"></a><span class="lineno"> 3002</span>&#160;  Expected: is in range [4, 6]</div><div class="line"><a name="l03003"></a><span class="lineno"> 3003</span>&#160;```</div><div class="line"><a name="l03004"></a><span class="lineno"> 3004</span>&#160;</div><div class="line"><a name="l03005"></a><span class="lineno"> 3005</span>&#160;If you specify `&quot;&quot;` as the description, the failure message will</div><div class="line"><a name="l03006"></a><span class="lineno"> 3006</span>&#160;contain the sequence of words in the matcher name followed by the</div><div class="line"><a name="l03007"></a><span class="lineno"> 3007</span>&#160;parameter values printed as a tuple.  For example,</div><div class="line"><a name="l03008"></a><span class="lineno"> 3008</span>&#160;```</div><div class="line"><a name="l03009"></a><span class="lineno"> 3009</span>&#160;  MATCHER_P2(InClosedRange, low, hi, &quot;&quot;) { ... }</div><div class="line"><a name="l03010"></a><span class="lineno"> 3010</span>&#160;  ...</div><div class="line"><a name="l03011"></a><span class="lineno"> 3011</span>&#160;  EXPECT_THAT(3, InClosedRange(4, 6));</div><div class="line"><a name="l03012"></a><span class="lineno"> 3012</span>&#160;```</div><div class="line"><a name="l03013"></a><span class="lineno"> 3013</span>&#160;would generate a failure that contains the text:</div><div class="line"><a name="l03014"></a><span class="lineno"> 3014</span>&#160;```</div><div class="line"><a name="l03015"></a><span class="lineno"> 3015</span>&#160;  Expected: in closed range (4, 6)</div><div class="line"><a name="l03016"></a><span class="lineno"> 3016</span>&#160;```</div><div class="line"><a name="l03017"></a><span class="lineno"> 3017</span>&#160;</div><div class="line"><a name="l03018"></a><span class="lineno"> 3018</span>&#160;For the purpose of typing, you can view</div><div class="line"><a name="l03019"></a><span class="lineno"> 3019</span>&#160;```</div><div class="line"><a name="l03020"></a><span class="lineno"> 3020</span>&#160;MATCHER_Pk(Foo, p1, ..., pk, description_string) { ... }</div><div class="line"><a name="l03021"></a><span class="lineno"> 3021</span>&#160;```</div><div class="line"><a name="l03022"></a><span class="lineno"> 3022</span>&#160;as shorthand for</div><div class="line"><a name="l03023"></a><span class="lineno"> 3023</span>&#160;```</div><div class="line"><a name="l03024"></a><span class="lineno"> 3024</span>&#160;template &lt;typename p1_type, ..., typename pk_type&gt;</div><div class="line"><a name="l03025"></a><span class="lineno"> 3025</span>&#160;FooMatcherPk&lt;p1_type, ..., pk_type&gt;</div><div class="line"><a name="l03026"></a><span class="lineno"> 3026</span>&#160;Foo(p1_type p1, ..., pk_type pk) { ... }</div><div class="line"><a name="l03027"></a><span class="lineno"> 3027</span>&#160;```</div><div class="line"><a name="l03028"></a><span class="lineno"> 3028</span>&#160;</div><div class="line"><a name="l03029"></a><span class="lineno"> 3029</span>&#160;When you write `Foo(v1, ..., vk)`, the compiler infers the types of</div><div class="line"><a name="l03030"></a><span class="lineno"> 3030</span>&#160;the parameters `v1`, ..., and `vk` for you.  If you are not happy with</div><div class="line"><a name="l03031"></a><span class="lineno"> 3031</span>&#160;the result of the type inference, you can specify the types by</div><div class="line"><a name="l03032"></a><span class="lineno"> 3032</span>&#160;explicitly instantiating the template, as in `Foo&lt;long, bool&gt;(5, false)`.</div><div class="line"><a name="l03033"></a><span class="lineno"> 3033</span>&#160;As said earlier, you don&#39;t get to (or need to) specify</div><div class="line"><a name="l03034"></a><span class="lineno"> 3034</span>&#160;`arg_type` as that&#39;s determined by the context in which the matcher</div><div class="line"><a name="l03035"></a><span class="lineno"> 3035</span>&#160;is used.</div><div class="line"><a name="l03036"></a><span class="lineno"> 3036</span>&#160;</div><div class="line"><a name="l03037"></a><span class="lineno"> 3037</span>&#160;You can assign the result of expression `Foo(p1, ..., pk)` to a</div><div class="line"><a name="l03038"></a><span class="lineno"> 3038</span>&#160;variable of type `FooMatcherPk&lt;p1_type, ..., pk_type&gt;`.  This can be</div><div class="line"><a name="l03039"></a><span class="lineno"> 3039</span>&#160;useful when composing matchers.  Matchers that don&#39;t have a parameter</div><div class="line"><a name="l03040"></a><span class="lineno"> 3040</span>&#160;or have only one parameter have special types: you can assign `Foo()`</div><div class="line"><a name="l03041"></a><span class="lineno"> 3041</span>&#160;to a `FooMatcher`-typed variable, and assign `Foo(p)` to a</div><div class="line"><a name="l03042"></a><span class="lineno"> 3042</span>&#160;`FooMatcherP&lt;p_type&gt;`-typed variable.</div><div class="line"><a name="l03043"></a><span class="lineno"> 3043</span>&#160;</div><div class="line"><a name="l03044"></a><span class="lineno"> 3044</span>&#160;While you can instantiate a matcher template with reference types,</div><div class="line"><a name="l03045"></a><span class="lineno"> 3045</span>&#160;passing the parameters by pointer usually makes your code more</div><div class="line"><a name="l03046"></a><span class="lineno"> 3046</span>&#160;readable.  If, however, you still want to pass a parameter by</div><div class="line"><a name="l03047"></a><span class="lineno"> 3047</span>&#160;reference, be aware that in the failure message generated by the</div><div class="line"><a name="l03048"></a><span class="lineno"> 3048</span>&#160;matcher you will see the value of the referenced object but not its</div><div class="line"><a name="l03049"></a><span class="lineno"> 3049</span>&#160;address.</div><div class="line"><a name="l03050"></a><span class="lineno"> 3050</span>&#160;</div><div class="line"><a name="l03051"></a><span class="lineno"> 3051</span>&#160;You can overload matchers with different numbers of parameters:</div><div class="line"><a name="l03052"></a><span class="lineno"> 3052</span>&#160;```</div><div class="line"><a name="l03053"></a><span class="lineno"> 3053</span>&#160;MATCHER_P(Blah, a, description_string_1) { ... }</div><div class="line"><a name="l03054"></a><span class="lineno"> 3054</span>&#160;MATCHER_P2(Blah, a, b, description_string_2) { ... }</div><div class="line"><a name="l03055"></a><span class="lineno"> 3055</span>&#160;```</div><div class="line"><a name="l03056"></a><span class="lineno"> 3056</span>&#160;</div><div class="line"><a name="l03057"></a><span class="lineno"> 3057</span>&#160;While it&#39;s tempting to always use the `MATCHER*` macros when defining</div><div class="line"><a name="l03058"></a><span class="lineno"> 3058</span>&#160;a new matcher, you should also consider implementing</div><div class="line"><a name="l03059"></a><span class="lineno"> 3059</span>&#160;`MatcherInterface` or using `MakePolymorphicMatcher()` instead (see</div><div class="line"><a name="l03060"></a><span class="lineno"> 3060</span>&#160;the recipes that follow), especially if you need to use the matcher a</div><div class="line"><a name="l03061"></a><span class="lineno"> 3061</span>&#160;lot.  While these approaches require more work, they give you more</div><div class="line"><a name="l03062"></a><span class="lineno"> 3062</span>&#160;control on the types of the value being matched and the matcher</div><div class="line"><a name="l03063"></a><span class="lineno"> 3063</span>&#160;parameters, which in general leads to better compiler error messages</div><div class="line"><a name="l03064"></a><span class="lineno"> 3064</span>&#160;that pay off in the long run.  They also allow overloading matchers</div><div class="line"><a name="l03065"></a><span class="lineno"> 3065</span>&#160;based on parameter types (as opposed to just based on the number of</div><div class="line"><a name="l03066"></a><span class="lineno"> 3066</span>&#160;parameters).</div><div class="line"><a name="l03067"></a><span class="lineno"> 3067</span>&#160;</div><div class="line"><a name="l03068"></a><span class="lineno"> 3068</span>&#160;## Writing New Monomorphic Matchers ##</div><div class="line"><a name="l03069"></a><span class="lineno"> 3069</span>&#160;</div><div class="line"><a name="l03070"></a><span class="lineno"> 3070</span>&#160;A matcher of argument type `T` implements</div><div class="line"><a name="l03071"></a><span class="lineno"> 3071</span>&#160;`::testing::MatcherInterface&lt;T&gt;` and does two things: it tests whether a</div><div class="line"><a name="l03072"></a><span class="lineno"> 3072</span>&#160;value of type `T` matches the matcher, and can describe what kind of</div><div class="line"><a name="l03073"></a><span class="lineno"> 3073</span>&#160;values it matches. The latter ability is used for generating readable</div><div class="line"><a name="l03074"></a><span class="lineno"> 3074</span>&#160;error messages when expectations are violated.</div><div class="line"><a name="l03075"></a><span class="lineno"> 3075</span>&#160;</div><div class="line"><a name="l03076"></a><span class="lineno"> 3076</span>&#160;The interface looks like this:</div><div class="line"><a name="l03077"></a><span class="lineno"> 3077</span>&#160;</div><div class="line"><a name="l03078"></a><span class="lineno"> 3078</span>&#160;```</div><div class="line"><a name="l03079"></a><span class="lineno"> 3079</span>&#160;class MatchResultListener {</div><div class="line"><a name="l03080"></a><span class="lineno"> 3080</span>&#160; public:</div><div class="line"><a name="l03081"></a><span class="lineno"> 3081</span>&#160;  ...</div><div class="line"><a name="l03082"></a><span class="lineno"> 3082</span>&#160;  // Streams x to the underlying ostream; does nothing if the ostream</div><div class="line"><a name="l03083"></a><span class="lineno"> 3083</span>&#160;  // is NULL.</div><div class="line"><a name="l03084"></a><span class="lineno"> 3084</span>&#160;  template &lt;typename T&gt;</div><div class="line"><a name="l03085"></a><span class="lineno"> 3085</span>&#160;  MatchResultListener&amp; operator&lt;&lt;(const T&amp; x);</div><div class="line"><a name="l03086"></a><span class="lineno"> 3086</span>&#160;</div><div class="line"><a name="l03087"></a><span class="lineno"> 3087</span>&#160;  // Returns the underlying ostream.</div><div class="line"><a name="l03088"></a><span class="lineno"> 3088</span>&#160;  ::std::ostream* stream();</div><div class="line"><a name="l03089"></a><span class="lineno"> 3089</span>&#160;};</div><div class="line"><a name="l03090"></a><span class="lineno"> 3090</span>&#160;</div><div class="line"><a name="l03091"></a><span class="lineno"> 3091</span>&#160;template &lt;typename T&gt;</div><div class="line"><a name="l03092"></a><span class="lineno"> 3092</span>&#160;class MatcherInterface {</div><div class="line"><a name="l03093"></a><span class="lineno"> 3093</span>&#160; public:</div><div class="line"><a name="l03094"></a><span class="lineno"> 3094</span>&#160;  virtual ~MatcherInterface();</div><div class="line"><a name="l03095"></a><span class="lineno"> 3095</span>&#160;</div><div class="line"><a name="l03096"></a><span class="lineno"> 3096</span>&#160;  // Returns true iff the matcher matches x; also explains the match</div><div class="line"><a name="l03097"></a><span class="lineno"> 3097</span>&#160;  // result to &#39;listener&#39;.</div><div class="line"><a name="l03098"></a><span class="lineno"> 3098</span>&#160;  virtual bool MatchAndExplain(T x, MatchResultListener* listener) const = 0;</div><div class="line"><a name="l03099"></a><span class="lineno"> 3099</span>&#160;</div><div class="line"><a name="l03100"></a><span class="lineno"> 3100</span>&#160;  // Describes this matcher to an ostream.</div><div class="line"><a name="l03101"></a><span class="lineno"> 3101</span>&#160;  virtual void DescribeTo(::std::ostream* os) const = 0;</div><div class="line"><a name="l03102"></a><span class="lineno"> 3102</span>&#160;</div><div class="line"><a name="l03103"></a><span class="lineno"> 3103</span>&#160;  // Describes the negation of this matcher to an ostream.</div><div class="line"><a name="l03104"></a><span class="lineno"> 3104</span>&#160;  virtual void DescribeNegationTo(::std::ostream* os) const;</div><div class="line"><a name="l03105"></a><span class="lineno"> 3105</span>&#160;};</div><div class="line"><a name="l03106"></a><span class="lineno"> 3106</span>&#160;```</div><div class="line"><a name="l03107"></a><span class="lineno"> 3107</span>&#160;</div><div class="line"><a name="l03108"></a><span class="lineno"> 3108</span>&#160;If you need a custom matcher but `Truly()` is not a good option (for</div><div class="line"><a name="l03109"></a><span class="lineno"> 3109</span>&#160;example, you may not be happy with the way `Truly(predicate)`</div><div class="line"><a name="l03110"></a><span class="lineno"> 3110</span>&#160;describes itself, or you may want your matcher to be polymorphic as</div><div class="line"><a name="l03111"></a><span class="lineno"> 3111</span>&#160;`Eq(value)` is), you can define a matcher to do whatever you want in</div><div class="line"><a name="l03112"></a><span class="lineno"> 3112</span>&#160;two steps: first implement the matcher interface, and then define a</div><div class="line"><a name="l03113"></a><span class="lineno"> 3113</span>&#160;factory function to create a matcher instance. The second step is not</div><div class="line"><a name="l03114"></a><span class="lineno"> 3114</span>&#160;strictly needed but it makes the syntax of using the matcher nicer.</div><div class="line"><a name="l03115"></a><span class="lineno"> 3115</span>&#160;</div><div class="line"><a name="l03116"></a><span class="lineno"> 3116</span>&#160;For example, you can define a matcher to test whether an `int` is</div><div class="line"><a name="l03117"></a><span class="lineno"> 3117</span>&#160;divisible by 7 and then use it like this:</div><div class="line"><a name="l03118"></a><span class="lineno"> 3118</span>&#160;```</div><div class="line"><a name="l03119"></a><span class="lineno"> 3119</span>&#160;using ::testing::MakeMatcher;</div><div class="line"><a name="l03120"></a><span class="lineno"> 3120</span>&#160;using ::testing::Matcher;</div><div class="line"><a name="l03121"></a><span class="lineno"> 3121</span>&#160;using ::testing::MatcherInterface;</div><div class="line"><a name="l03122"></a><span class="lineno"> 3122</span>&#160;using ::testing::MatchResultListener;</div><div class="line"><a name="l03123"></a><span class="lineno"> 3123</span>&#160;</div><div class="line"><a name="l03124"></a><span class="lineno"> 3124</span>&#160;class DivisibleBy7Matcher : public MatcherInterface&lt;int&gt; {</div><div class="line"><a name="l03125"></a><span class="lineno"> 3125</span>&#160; public:</div><div class="line"><a name="l03126"></a><span class="lineno"> 3126</span>&#160;  virtual bool MatchAndExplain(int n, MatchResultListener* listener) const {</div><div class="line"><a name="l03127"></a><span class="lineno"> 3127</span>&#160;    return (n % 7) == 0;</div><div class="line"><a name="l03128"></a><span class="lineno"> 3128</span>&#160;  }</div><div class="line"><a name="l03129"></a><span class="lineno"> 3129</span>&#160;</div><div class="line"><a name="l03130"></a><span class="lineno"> 3130</span>&#160;  virtual void DescribeTo(::std::ostream* os) const {</div><div class="line"><a name="l03131"></a><span class="lineno"> 3131</span>&#160;    *os &lt;&lt; &quot;is divisible by 7&quot;;</div><div class="line"><a name="l03132"></a><span class="lineno"> 3132</span>&#160;  }</div><div class="line"><a name="l03133"></a><span class="lineno"> 3133</span>&#160;</div><div class="line"><a name="l03134"></a><span class="lineno"> 3134</span>&#160;  virtual void DescribeNegationTo(::std::ostream* os) const {</div><div class="line"><a name="l03135"></a><span class="lineno"> 3135</span>&#160;    *os &lt;&lt; &quot;is not divisible by 7&quot;;</div><div class="line"><a name="l03136"></a><span class="lineno"> 3136</span>&#160;  }</div><div class="line"><a name="l03137"></a><span class="lineno"> 3137</span>&#160;};</div><div class="line"><a name="l03138"></a><span class="lineno"> 3138</span>&#160;</div><div class="line"><a name="l03139"></a><span class="lineno"> 3139</span>&#160;inline Matcher&lt;int&gt; DivisibleBy7() {</div><div class="line"><a name="l03140"></a><span class="lineno"> 3140</span>&#160;  return MakeMatcher(new DivisibleBy7Matcher);</div><div class="line"><a name="l03141"></a><span class="lineno"> 3141</span>&#160;}</div><div class="line"><a name="l03142"></a><span class="lineno"> 3142</span>&#160;...</div><div class="line"><a name="l03143"></a><span class="lineno"> 3143</span>&#160;</div><div class="line"><a name="l03144"></a><span class="lineno"> 3144</span>&#160;  EXPECT_CALL(foo, Bar(DivisibleBy7()));</div><div class="line"><a name="l03145"></a><span class="lineno"> 3145</span>&#160;```</div><div class="line"><a name="l03146"></a><span class="lineno"> 3146</span>&#160;</div><div class="line"><a name="l03147"></a><span class="lineno"> 3147</span>&#160;You may improve the matcher message by streaming additional</div><div class="line"><a name="l03148"></a><span class="lineno"> 3148</span>&#160;information to the `listener` argument in `MatchAndExplain()`:</div><div class="line"><a name="l03149"></a><span class="lineno"> 3149</span>&#160;</div><div class="line"><a name="l03150"></a><span class="lineno"> 3150</span>&#160;```</div><div class="line"><a name="l03151"></a><span class="lineno"> 3151</span>&#160;class DivisibleBy7Matcher : public MatcherInterface&lt;int&gt; {</div><div class="line"><a name="l03152"></a><span class="lineno"> 3152</span>&#160; public:</div><div class="line"><a name="l03153"></a><span class="lineno"> 3153</span>&#160;  virtual bool MatchAndExplain(int n,</div><div class="line"><a name="l03154"></a><span class="lineno"> 3154</span>&#160;                               MatchResultListener* listener) const {</div><div class="line"><a name="l03155"></a><span class="lineno"> 3155</span>&#160;    const int remainder = n % 7;</div><div class="line"><a name="l03156"></a><span class="lineno"> 3156</span>&#160;    if (remainder != 0) {</div><div class="line"><a name="l03157"></a><span class="lineno"> 3157</span>&#160;      *listener &lt;&lt; &quot;the remainder is &quot; &lt;&lt; remainder;</div><div class="line"><a name="l03158"></a><span class="lineno"> 3158</span>&#160;    }</div><div class="line"><a name="l03159"></a><span class="lineno"> 3159</span>&#160;    return remainder == 0;</div><div class="line"><a name="l03160"></a><span class="lineno"> 3160</span>&#160;  }</div><div class="line"><a name="l03161"></a><span class="lineno"> 3161</span>&#160;  ...</div><div class="line"><a name="l03162"></a><span class="lineno"> 3162</span>&#160;};</div><div class="line"><a name="l03163"></a><span class="lineno"> 3163</span>&#160;```</div><div class="line"><a name="l03164"></a><span class="lineno"> 3164</span>&#160;</div><div class="line"><a name="l03165"></a><span class="lineno"> 3165</span>&#160;Then, `EXPECT_THAT(x, DivisibleBy7());` may general a message like this:</div><div class="line"><a name="l03166"></a><span class="lineno"> 3166</span>&#160;```</div><div class="line"><a name="l03167"></a><span class="lineno"> 3167</span>&#160;Value of: x</div><div class="line"><a name="l03168"></a><span class="lineno"> 3168</span>&#160;Expected: is divisible by 7</div><div class="line"><a name="l03169"></a><span class="lineno"> 3169</span>&#160;  Actual: 23 (the remainder is 2)</div><div class="line"><a name="l03170"></a><span class="lineno"> 3170</span>&#160;```</div><div class="line"><a name="l03171"></a><span class="lineno"> 3171</span>&#160;</div><div class="line"><a name="l03172"></a><span class="lineno"> 3172</span>&#160;## Writing New Polymorphic Matchers ##</div><div class="line"><a name="l03173"></a><span class="lineno"> 3173</span>&#160;</div><div class="line"><a name="l03174"></a><span class="lineno"> 3174</span>&#160;You&#39;ve learned how to write your own matchers in the previous</div><div class="line"><a name="l03175"></a><span class="lineno"> 3175</span>&#160;recipe. Just one problem: a matcher created using `MakeMatcher()` only</div><div class="line"><a name="l03176"></a><span class="lineno"> 3176</span>&#160;works for one particular type of arguments. If you want a</div><div class="line"><a name="l03177"></a><span class="lineno"> 3177</span>&#160;_polymorphic_ matcher that works with arguments of several types (for</div><div class="line"><a name="l03178"></a><span class="lineno"> 3178</span>&#160;instance, `Eq(x)` can be used to match a `value` as long as `value` ==</div><div class="line"><a name="l03179"></a><span class="lineno"> 3179</span>&#160;`x` compiles -- `value` and `x` don&#39;t have to share the same type),</div><div class="line"><a name="l03180"></a><span class="lineno"> 3180</span>&#160;you can learn the trick from `&quot;gmock/gmock-matchers.h&quot;` but it&#39;s a bit</div><div class="line"><a name="l03181"></a><span class="lineno"> 3181</span>&#160;involved.</div><div class="line"><a name="l03182"></a><span class="lineno"> 3182</span>&#160;</div><div class="line"><a name="l03183"></a><span class="lineno"> 3183</span>&#160;Fortunately, most of the time you can define a polymorphic matcher</div><div class="line"><a name="l03184"></a><span class="lineno"> 3184</span>&#160;easily with the help of `MakePolymorphicMatcher()`. Here&#39;s how you can</div><div class="line"><a name="l03185"></a><span class="lineno"> 3185</span>&#160;define `NotNull()` as an example:</div><div class="line"><a name="l03186"></a><span class="lineno"> 3186</span>&#160;</div><div class="line"><a name="l03187"></a><span class="lineno"> 3187</span>&#160;```</div><div class="line"><a name="l03188"></a><span class="lineno"> 3188</span>&#160;using ::testing::MakePolymorphicMatcher;</div><div class="line"><a name="l03189"></a><span class="lineno"> 3189</span>&#160;using ::testing::MatchResultListener;</div><div class="line"><a name="l03190"></a><span class="lineno"> 3190</span>&#160;using ::testing::NotNull;</div><div class="line"><a name="l03191"></a><span class="lineno"> 3191</span>&#160;using ::testing::PolymorphicMatcher;</div><div class="line"><a name="l03192"></a><span class="lineno"> 3192</span>&#160;</div><div class="line"><a name="l03193"></a><span class="lineno"> 3193</span>&#160;class NotNullMatcher {</div><div class="line"><a name="l03194"></a><span class="lineno"> 3194</span>&#160; public:</div><div class="line"><a name="l03195"></a><span class="lineno"> 3195</span>&#160;  // To implement a polymorphic matcher, first define a COPYABLE class</div><div class="line"><a name="l03196"></a><span class="lineno"> 3196</span>&#160;  // that has three members MatchAndExplain(), DescribeTo(), and</div><div class="line"><a name="l03197"></a><span class="lineno"> 3197</span>&#160;  // DescribeNegationTo(), like the following.</div><div class="line"><a name="l03198"></a><span class="lineno"> 3198</span>&#160;</div><div class="line"><a name="l03199"></a><span class="lineno"> 3199</span>&#160;  // In this example, we want to use NotNull() with any pointer, so</div><div class="line"><a name="l03200"></a><span class="lineno"> 3200</span>&#160;  // MatchAndExplain() accepts a pointer of any type as its first argument.</div><div class="line"><a name="l03201"></a><span class="lineno"> 3201</span>&#160;  // In general, you can define MatchAndExplain() as an ordinary method or</div><div class="line"><a name="l03202"></a><span class="lineno"> 3202</span>&#160;  // a method template, or even overload it.</div><div class="line"><a name="l03203"></a><span class="lineno"> 3203</span>&#160;  template &lt;typename T&gt;</div><div class="line"><a name="l03204"></a><span class="lineno"> 3204</span>&#160;  bool MatchAndExplain(T* p,</div><div class="line"><a name="l03205"></a><span class="lineno"> 3205</span>&#160;                       MatchResultListener* /* listener */) const {</div><div class="line"><a name="l03206"></a><span class="lineno"> 3206</span>&#160;    return p != NULL;</div><div class="line"><a name="l03207"></a><span class="lineno"> 3207</span>&#160;  }</div><div class="line"><a name="l03208"></a><span class="lineno"> 3208</span>&#160;</div><div class="line"><a name="l03209"></a><span class="lineno"> 3209</span>&#160;  // Describes the property of a value matching this matcher.</div><div class="line"><a name="l03210"></a><span class="lineno"> 3210</span>&#160;  void DescribeTo(::std::ostream* os) const { *os &lt;&lt; &quot;is not NULL&quot;; }</div><div class="line"><a name="l03211"></a><span class="lineno"> 3211</span>&#160;</div><div class="line"><a name="l03212"></a><span class="lineno"> 3212</span>&#160;  // Describes the property of a value NOT matching this matcher.</div><div class="line"><a name="l03213"></a><span class="lineno"> 3213</span>&#160;  void DescribeNegationTo(::std::ostream* os) const { *os &lt;&lt; &quot;is NULL&quot;; }</div><div class="line"><a name="l03214"></a><span class="lineno"> 3214</span>&#160;};</div><div class="line"><a name="l03215"></a><span class="lineno"> 3215</span>&#160;</div><div class="line"><a name="l03216"></a><span class="lineno"> 3216</span>&#160;// To construct a polymorphic matcher, pass an instance of the class</div><div class="line"><a name="l03217"></a><span class="lineno"> 3217</span>&#160;// to MakePolymorphicMatcher().  Note the return type.</div><div class="line"><a name="l03218"></a><span class="lineno"> 3218</span>&#160;inline PolymorphicMatcher&lt;NotNullMatcher&gt; NotNull() {</div><div class="line"><a name="l03219"></a><span class="lineno"> 3219</span>&#160;  return MakePolymorphicMatcher(NotNullMatcher());</div><div class="line"><a name="l03220"></a><span class="lineno"> 3220</span>&#160;}</div><div class="line"><a name="l03221"></a><span class="lineno"> 3221</span>&#160;...</div><div class="line"><a name="l03222"></a><span class="lineno"> 3222</span>&#160;</div><div class="line"><a name="l03223"></a><span class="lineno"> 3223</span>&#160;  EXPECT_CALL(foo, Bar(NotNull()));  // The argument must be a non-NULL pointer.</div><div class="line"><a name="l03224"></a><span class="lineno"> 3224</span>&#160;```</div><div class="line"><a name="l03225"></a><span class="lineno"> 3225</span>&#160;</div><div class="line"><a name="l03226"></a><span class="lineno"> 3226</span>&#160;**Note:** Your polymorphic matcher class does **not** need to inherit from</div><div class="line"><a name="l03227"></a><span class="lineno"> 3227</span>&#160;`MatcherInterface` or any other class, and its methods do **not** need</div><div class="line"><a name="l03228"></a><span class="lineno"> 3228</span>&#160;to be virtual.</div><div class="line"><a name="l03229"></a><span class="lineno"> 3229</span>&#160;</div><div class="line"><a name="l03230"></a><span class="lineno"> 3230</span>&#160;Like in a monomorphic matcher, you may explain the match result by</div><div class="line"><a name="l03231"></a><span class="lineno"> 3231</span>&#160;streaming additional information to the `listener` argument in</div><div class="line"><a name="l03232"></a><span class="lineno"> 3232</span>&#160;`MatchAndExplain()`.</div><div class="line"><a name="l03233"></a><span class="lineno"> 3233</span>&#160;</div><div class="line"><a name="l03234"></a><span class="lineno"> 3234</span>&#160;## Writing New Cardinalities ##</div><div class="line"><a name="l03235"></a><span class="lineno"> 3235</span>&#160;</div><div class="line"><a name="l03236"></a><span class="lineno"> 3236</span>&#160;A cardinality is used in `Times()` to tell Google Mock how many times</div><div class="line"><a name="l03237"></a><span class="lineno"> 3237</span>&#160;you expect a call to occur. It doesn&#39;t have to be exact. For example,</div><div class="line"><a name="l03238"></a><span class="lineno"> 3238</span>&#160;you can say `AtLeast(5)` or `Between(2, 4)`.</div><div class="line"><a name="l03239"></a><span class="lineno"> 3239</span>&#160;</div><div class="line"><a name="l03240"></a><span class="lineno"> 3240</span>&#160;If the built-in set of cardinalities doesn&#39;t suit you, you are free to</div><div class="line"><a name="l03241"></a><span class="lineno"> 3241</span>&#160;define your own by implementing the following interface (in namespace</div><div class="line"><a name="l03242"></a><span class="lineno"> 3242</span>&#160;`testing`):</div><div class="line"><a name="l03243"></a><span class="lineno"> 3243</span>&#160;</div><div class="line"><a name="l03244"></a><span class="lineno"> 3244</span>&#160;```</div><div class="line"><a name="l03245"></a><span class="lineno"> 3245</span>&#160;class CardinalityInterface {</div><div class="line"><a name="l03246"></a><span class="lineno"> 3246</span>&#160; public:</div><div class="line"><a name="l03247"></a><span class="lineno"> 3247</span>&#160;  virtual ~CardinalityInterface();</div><div class="line"><a name="l03248"></a><span class="lineno"> 3248</span>&#160;</div><div class="line"><a name="l03249"></a><span class="lineno"> 3249</span>&#160;  // Returns true iff call_count calls will satisfy this cardinality.</div><div class="line"><a name="l03250"></a><span class="lineno"> 3250</span>&#160;  virtual bool IsSatisfiedByCallCount(int call_count) const = 0;</div><div class="line"><a name="l03251"></a><span class="lineno"> 3251</span>&#160;</div><div class="line"><a name="l03252"></a><span class="lineno"> 3252</span>&#160;  // Returns true iff call_count calls will saturate this cardinality.</div><div class="line"><a name="l03253"></a><span class="lineno"> 3253</span>&#160;  virtual bool IsSaturatedByCallCount(int call_count) const = 0;</div><div class="line"><a name="l03254"></a><span class="lineno"> 3254</span>&#160;</div><div class="line"><a name="l03255"></a><span class="lineno"> 3255</span>&#160;  // Describes self to an ostream.</div><div class="line"><a name="l03256"></a><span class="lineno"> 3256</span>&#160;  virtual void DescribeTo(::std::ostream* os) const = 0;</div><div class="line"><a name="l03257"></a><span class="lineno"> 3257</span>&#160;};</div><div class="line"><a name="l03258"></a><span class="lineno"> 3258</span>&#160;```</div><div class="line"><a name="l03259"></a><span class="lineno"> 3259</span>&#160;</div><div class="line"><a name="l03260"></a><span class="lineno"> 3260</span>&#160;For example, to specify that a call must occur even number of times,</div><div class="line"><a name="l03261"></a><span class="lineno"> 3261</span>&#160;you can write</div><div class="line"><a name="l03262"></a><span class="lineno"> 3262</span>&#160;</div><div class="line"><a name="l03263"></a><span class="lineno"> 3263</span>&#160;```</div><div class="line"><a name="l03264"></a><span class="lineno"> 3264</span>&#160;using ::testing::Cardinality;</div><div class="line"><a name="l03265"></a><span class="lineno"> 3265</span>&#160;using ::testing::CardinalityInterface;</div><div class="line"><a name="l03266"></a><span class="lineno"> 3266</span>&#160;using ::testing::MakeCardinality;</div><div class="line"><a name="l03267"></a><span class="lineno"> 3267</span>&#160;</div><div class="line"><a name="l03268"></a><span class="lineno"> 3268</span>&#160;class EvenNumberCardinality : public CardinalityInterface {</div><div class="line"><a name="l03269"></a><span class="lineno"> 3269</span>&#160; public:</div><div class="line"><a name="l03270"></a><span class="lineno"> 3270</span>&#160;  virtual bool IsSatisfiedByCallCount(int call_count) const {</div><div class="line"><a name="l03271"></a><span class="lineno"> 3271</span>&#160;    return (call_count % 2) == 0;</div><div class="line"><a name="l03272"></a><span class="lineno"> 3272</span>&#160;  }</div><div class="line"><a name="l03273"></a><span class="lineno"> 3273</span>&#160;</div><div class="line"><a name="l03274"></a><span class="lineno"> 3274</span>&#160;  virtual bool IsSaturatedByCallCount(int call_count) const {</div><div class="line"><a name="l03275"></a><span class="lineno"> 3275</span>&#160;    return false;</div><div class="line"><a name="l03276"></a><span class="lineno"> 3276</span>&#160;  }</div><div class="line"><a name="l03277"></a><span class="lineno"> 3277</span>&#160;</div><div class="line"><a name="l03278"></a><span class="lineno"> 3278</span>&#160;  virtual void DescribeTo(::std::ostream* os) const {</div><div class="line"><a name="l03279"></a><span class="lineno"> 3279</span>&#160;    *os &lt;&lt; &quot;called even number of times&quot;;</div><div class="line"><a name="l03280"></a><span class="lineno"> 3280</span>&#160;  }</div><div class="line"><a name="l03281"></a><span class="lineno"> 3281</span>&#160;};</div><div class="line"><a name="l03282"></a><span class="lineno"> 3282</span>&#160;</div><div class="line"><a name="l03283"></a><span class="lineno"> 3283</span>&#160;Cardinality EvenNumber() {</div><div class="line"><a name="l03284"></a><span class="lineno"> 3284</span>&#160;  return MakeCardinality(new EvenNumberCardinality);</div><div class="line"><a name="l03285"></a><span class="lineno"> 3285</span>&#160;}</div><div class="line"><a name="l03286"></a><span class="lineno"> 3286</span>&#160;...</div><div class="line"><a name="l03287"></a><span class="lineno"> 3287</span>&#160;</div><div class="line"><a name="l03288"></a><span class="lineno"> 3288</span>&#160;  EXPECT_CALL(foo, Bar(3))</div><div class="line"><a name="l03289"></a><span class="lineno"> 3289</span>&#160;      .Times(EvenNumber());</div><div class="line"><a name="l03290"></a><span class="lineno"> 3290</span>&#160;```</div><div class="line"><a name="l03291"></a><span class="lineno"> 3291</span>&#160;</div><div class="line"><a name="l03292"></a><span class="lineno"> 3292</span>&#160;## Writing New Actions Quickly ##</div><div class="line"><a name="l03293"></a><span class="lineno"> 3293</span>&#160;</div><div class="line"><a name="l03294"></a><span class="lineno"> 3294</span>&#160;If the built-in actions don&#39;t work for you, and you find it</div><div class="line"><a name="l03295"></a><span class="lineno"> 3295</span>&#160;inconvenient to use `Invoke()`, you can use a macro from the `ACTION*`</div><div class="line"><a name="l03296"></a><span class="lineno"> 3296</span>&#160;family to quickly define a new action that can be used in your code as</div><div class="line"><a name="l03297"></a><span class="lineno"> 3297</span>&#160;if it&#39;s a built-in action.</div><div class="line"><a name="l03298"></a><span class="lineno"> 3298</span>&#160;</div><div class="line"><a name="l03299"></a><span class="lineno"> 3299</span>&#160;By writing</div><div class="line"><a name="l03300"></a><span class="lineno"> 3300</span>&#160;```</div><div class="line"><a name="l03301"></a><span class="lineno"> 3301</span>&#160;ACTION(name) { statements; }</div><div class="line"><a name="l03302"></a><span class="lineno"> 3302</span>&#160;```</div><div class="line"><a name="l03303"></a><span class="lineno"> 3303</span>&#160;in a namespace scope (i.e. not inside a class or function), you will</div><div class="line"><a name="l03304"></a><span class="lineno"> 3304</span>&#160;define an action with the given name that executes the statements.</div><div class="line"><a name="l03305"></a><span class="lineno"> 3305</span>&#160;The value returned by `statements` will be used as the return value of</div><div class="line"><a name="l03306"></a><span class="lineno"> 3306</span>&#160;the action.  Inside the statements, you can refer to the K-th</div><div class="line"><a name="l03307"></a><span class="lineno"> 3307</span>&#160;(0-based) argument of the mock function as `argK`.  For example:</div><div class="line"><a name="l03308"></a><span class="lineno"> 3308</span>&#160;```</div><div class="line"><a name="l03309"></a><span class="lineno"> 3309</span>&#160;ACTION(IncrementArg1) { return ++(*arg1); }</div><div class="line"><a name="l03310"></a><span class="lineno"> 3310</span>&#160;```</div><div class="line"><a name="l03311"></a><span class="lineno"> 3311</span>&#160;allows you to write</div><div class="line"><a name="l03312"></a><span class="lineno"> 3312</span>&#160;```</div><div class="line"><a name="l03313"></a><span class="lineno"> 3313</span>&#160;... WillOnce(IncrementArg1());</div><div class="line"><a name="l03314"></a><span class="lineno"> 3314</span>&#160;```</div><div class="line"><a name="l03315"></a><span class="lineno"> 3315</span>&#160;</div><div class="line"><a name="l03316"></a><span class="lineno"> 3316</span>&#160;Note that you don&#39;t need to specify the types of the mock function</div><div class="line"><a name="l03317"></a><span class="lineno"> 3317</span>&#160;arguments.  Rest assured that your code is type-safe though:</div><div class="line"><a name="l03318"></a><span class="lineno"> 3318</span>&#160;you&#39;ll get a compiler error if `*arg1` doesn&#39;t support the `++`</div><div class="line"><a name="l03319"></a><span class="lineno"> 3319</span>&#160;operator, or if the type of `++(*arg1)` isn&#39;t compatible with the mock</div><div class="line"><a name="l03320"></a><span class="lineno"> 3320</span>&#160;function&#39;s return type.</div><div class="line"><a name="l03321"></a><span class="lineno"> 3321</span>&#160;</div><div class="line"><a name="l03322"></a><span class="lineno"> 3322</span>&#160;Another example:</div><div class="line"><a name="l03323"></a><span class="lineno"> 3323</span>&#160;```</div><div class="line"><a name="l03324"></a><span class="lineno"> 3324</span>&#160;ACTION(Foo) {</div><div class="line"><a name="l03325"></a><span class="lineno"> 3325</span>&#160;  (*arg2)(5);</div><div class="line"><a name="l03326"></a><span class="lineno"> 3326</span>&#160;  Blah();</div><div class="line"><a name="l03327"></a><span class="lineno"> 3327</span>&#160;  *arg1 = 0;</div><div class="line"><a name="l03328"></a><span class="lineno"> 3328</span>&#160;  return arg0;</div><div class="line"><a name="l03329"></a><span class="lineno"> 3329</span>&#160;}</div><div class="line"><a name="l03330"></a><span class="lineno"> 3330</span>&#160;```</div><div class="line"><a name="l03331"></a><span class="lineno"> 3331</span>&#160;defines an action `Foo()` that invokes argument #2 (a function pointer)</div><div class="line"><a name="l03332"></a><span class="lineno"> 3332</span>&#160;with 5, calls function `Blah()`, sets the value pointed to by argument</div><div class="line"><a name="l03333"></a><span class="lineno"> 3333</span>&#160;#1 to 0, and returns argument #0.</div><div class="line"><a name="l03334"></a><span class="lineno"> 3334</span>&#160;</div><div class="line"><a name="l03335"></a><span class="lineno"> 3335</span>&#160;For more convenience and flexibility, you can also use the following</div><div class="line"><a name="l03336"></a><span class="lineno"> 3336</span>&#160;pre-defined symbols in the body of `ACTION`:</div><div class="line"><a name="l03337"></a><span class="lineno"> 3337</span>&#160;</div><div class="line"><a name="l03338"></a><span class="lineno"> 3338</span>&#160;| `argK_type` | The type of the K-th (0-based) argument of the mock function |</div><div class="line"><a name="l03339"></a><span class="lineno"> 3339</span>&#160;|:------------|:-------------------------------------------------------------|</div><div class="line"><a name="l03340"></a><span class="lineno"> 3340</span>&#160;| `args`      | All arguments of the mock function as a tuple                |</div><div class="line"><a name="l03341"></a><span class="lineno"> 3341</span>&#160;| `args_type` | The type of all arguments of the mock function as a tuple    |</div><div class="line"><a name="l03342"></a><span class="lineno"> 3342</span>&#160;| `return_type` | The return type of the mock function                         |</div><div class="line"><a name="l03343"></a><span class="lineno"> 3343</span>&#160;| `function_type` | The type of the mock function                                |</div><div class="line"><a name="l03344"></a><span class="lineno"> 3344</span>&#160;</div><div class="line"><a name="l03345"></a><span class="lineno"> 3345</span>&#160;For example, when using an `ACTION` as a stub action for mock function:</div><div class="line"><a name="l03346"></a><span class="lineno"> 3346</span>&#160;```</div><div class="line"><a name="l03347"></a><span class="lineno"> 3347</span>&#160;int DoSomething(bool flag, int* ptr);</div><div class="line"><a name="l03348"></a><span class="lineno"> 3348</span>&#160;```</div><div class="line"><a name="l03349"></a><span class="lineno"> 3349</span>&#160;we have:</div><div class="line"><a name="l03350"></a><span class="lineno"> 3350</span>&#160;| **Pre-defined Symbol** | **Is Bound To** |</div><div class="line"><a name="l03351"></a><span class="lineno"> 3351</span>&#160;|:-----------------------|:----------------|</div><div class="line"><a name="l03352"></a><span class="lineno"> 3352</span>&#160;| `arg0`                 | the value of `flag` |</div><div class="line"><a name="l03353"></a><span class="lineno"> 3353</span>&#160;| `arg0_type`            | the type `bool` |</div><div class="line"><a name="l03354"></a><span class="lineno"> 3354</span>&#160;| `arg1`                 | the value of `ptr` |</div><div class="line"><a name="l03355"></a><span class="lineno"> 3355</span>&#160;| `arg1_type`            | the type `int*` |</div><div class="line"><a name="l03356"></a><span class="lineno"> 3356</span>&#160;| `args`                 | the tuple `(flag, ptr)` |</div><div class="line"><a name="l03357"></a><span class="lineno"> 3357</span>&#160;| `args_type`            | the type `::testing::tuple&lt;bool, int*&gt;` |</div><div class="line"><a name="l03358"></a><span class="lineno"> 3358</span>&#160;| `return_type`          | the type `int`  |</div><div class="line"><a name="l03359"></a><span class="lineno"> 3359</span>&#160;| `function_type`        | the type `int(bool, int*)` |</div><div class="line"><a name="l03360"></a><span class="lineno"> 3360</span>&#160;</div><div class="line"><a name="l03361"></a><span class="lineno"> 3361</span>&#160;## Writing New Parameterized Actions Quickly ##</div><div class="line"><a name="l03362"></a><span class="lineno"> 3362</span>&#160;</div><div class="line"><a name="l03363"></a><span class="lineno"> 3363</span>&#160;Sometimes you&#39;ll want to parameterize an action you define.  For that</div><div class="line"><a name="l03364"></a><span class="lineno"> 3364</span>&#160;we have another macro</div><div class="line"><a name="l03365"></a><span class="lineno"> 3365</span>&#160;```</div><div class="line"><a name="l03366"></a><span class="lineno"> 3366</span>&#160;ACTION_P(name, param) { statements; }</div><div class="line"><a name="l03367"></a><span class="lineno"> 3367</span>&#160;```</div><div class="line"><a name="l03368"></a><span class="lineno"> 3368</span>&#160;</div><div class="line"><a name="l03369"></a><span class="lineno"> 3369</span>&#160;For example,</div><div class="line"><a name="l03370"></a><span class="lineno"> 3370</span>&#160;```</div><div class="line"><a name="l03371"></a><span class="lineno"> 3371</span>&#160;ACTION_P(Add, n) { return arg0 + n; }</div><div class="line"><a name="l03372"></a><span class="lineno"> 3372</span>&#160;```</div><div class="line"><a name="l03373"></a><span class="lineno"> 3373</span>&#160;will allow you to write</div><div class="line"><a name="l03374"></a><span class="lineno"> 3374</span>&#160;```</div><div class="line"><a name="l03375"></a><span class="lineno"> 3375</span>&#160;// Returns argument #0 + 5.</div><div class="line"><a name="l03376"></a><span class="lineno"> 3376</span>&#160;... WillOnce(Add(5));</div><div class="line"><a name="l03377"></a><span class="lineno"> 3377</span>&#160;```</div><div class="line"><a name="l03378"></a><span class="lineno"> 3378</span>&#160;</div><div class="line"><a name="l03379"></a><span class="lineno"> 3379</span>&#160;For convenience, we use the term _arguments_ for the values used to</div><div class="line"><a name="l03380"></a><span class="lineno"> 3380</span>&#160;invoke the mock function, and the term _parameters_ for the values</div><div class="line"><a name="l03381"></a><span class="lineno"> 3381</span>&#160;used to instantiate an action.</div><div class="line"><a name="l03382"></a><span class="lineno"> 3382</span>&#160;</div><div class="line"><a name="l03383"></a><span class="lineno"> 3383</span>&#160;Note that you don&#39;t need to provide the type of the parameter either.</div><div class="line"><a name="l03384"></a><span class="lineno"> 3384</span>&#160;Suppose the parameter is named `param`, you can also use the</div><div class="line"><a name="l03385"></a><span class="lineno"> 3385</span>&#160;Google-Mock-defined symbol `param_type` to refer to the type of the</div><div class="line"><a name="l03386"></a><span class="lineno"> 3386</span>&#160;parameter as inferred by the compiler.  For example, in the body of</div><div class="line"><a name="l03387"></a><span class="lineno"> 3387</span>&#160;`ACTION_P(Add, n)` above, you can write `n_type` for the type of `n`.</div><div class="line"><a name="l03388"></a><span class="lineno"> 3388</span>&#160;</div><div class="line"><a name="l03389"></a><span class="lineno"> 3389</span>&#160;Google Mock also provides `ACTION_P2`, `ACTION_P3`, and etc to support</div><div class="line"><a name="l03390"></a><span class="lineno"> 3390</span>&#160;multi-parameter actions.  For example,</div><div class="line"><a name="l03391"></a><span class="lineno"> 3391</span>&#160;```</div><div class="line"><a name="l03392"></a><span class="lineno"> 3392</span>&#160;ACTION_P2(ReturnDistanceTo, x, y) {</div><div class="line"><a name="l03393"></a><span class="lineno"> 3393</span>&#160;  double dx = arg0 - x;</div><div class="line"><a name="l03394"></a><span class="lineno"> 3394</span>&#160;  double dy = arg1 - y;</div><div class="line"><a name="l03395"></a><span class="lineno"> 3395</span>&#160;  return sqrt(dx*dx + dy*dy);</div><div class="line"><a name="l03396"></a><span class="lineno"> 3396</span>&#160;}</div><div class="line"><a name="l03397"></a><span class="lineno"> 3397</span>&#160;```</div><div class="line"><a name="l03398"></a><span class="lineno"> 3398</span>&#160;lets you write</div><div class="line"><a name="l03399"></a><span class="lineno"> 3399</span>&#160;```</div><div class="line"><a name="l03400"></a><span class="lineno"> 3400</span>&#160;... WillOnce(ReturnDistanceTo(5.0, 26.5));</div><div class="line"><a name="l03401"></a><span class="lineno"> 3401</span>&#160;```</div><div class="line"><a name="l03402"></a><span class="lineno"> 3402</span>&#160;</div><div class="line"><a name="l03403"></a><span class="lineno"> 3403</span>&#160;You can view `ACTION` as a degenerated parameterized action where the</div><div class="line"><a name="l03404"></a><span class="lineno"> 3404</span>&#160;number of parameters is 0.</div><div class="line"><a name="l03405"></a><span class="lineno"> 3405</span>&#160;</div><div class="line"><a name="l03406"></a><span class="lineno"> 3406</span>&#160;You can also easily define actions overloaded on the number of parameters:</div><div class="line"><a name="l03407"></a><span class="lineno"> 3407</span>&#160;```</div><div class="line"><a name="l03408"></a><span class="lineno"> 3408</span>&#160;ACTION_P(Plus, a) { ... }</div><div class="line"><a name="l03409"></a><span class="lineno"> 3409</span>&#160;ACTION_P2(Plus, a, b) { ... }</div><div class="line"><a name="l03410"></a><span class="lineno"> 3410</span>&#160;```</div><div class="line"><a name="l03411"></a><span class="lineno"> 3411</span>&#160;</div><div class="line"><a name="l03412"></a><span class="lineno"> 3412</span>&#160;## Restricting the Type of an Argument or Parameter in an ACTION ##</div><div class="line"><a name="l03413"></a><span class="lineno"> 3413</span>&#160;</div><div class="line"><a name="l03414"></a><span class="lineno"> 3414</span>&#160;For maximum brevity and reusability, the `ACTION*` macros don&#39;t ask</div><div class="line"><a name="l03415"></a><span class="lineno"> 3415</span>&#160;you to provide the types of the mock function arguments and the action</div><div class="line"><a name="l03416"></a><span class="lineno"> 3416</span>&#160;parameters.  Instead, we let the compiler infer the types for us.</div><div class="line"><a name="l03417"></a><span class="lineno"> 3417</span>&#160;</div><div class="line"><a name="l03418"></a><span class="lineno"> 3418</span>&#160;Sometimes, however, we may want to be more explicit about the types.</div><div class="line"><a name="l03419"></a><span class="lineno"> 3419</span>&#160;There are several tricks to do that.  For example:</div><div class="line"><a name="l03420"></a><span class="lineno"> 3420</span>&#160;```</div><div class="line"><a name="l03421"></a><span class="lineno"> 3421</span>&#160;ACTION(Foo) {</div><div class="line"><a name="l03422"></a><span class="lineno"> 3422</span>&#160;  // Makes sure arg0 can be converted to int.</div><div class="line"><a name="l03423"></a><span class="lineno"> 3423</span>&#160;  int n = arg0;</div><div class="line"><a name="l03424"></a><span class="lineno"> 3424</span>&#160;  ... use n instead of arg0 here ...</div><div class="line"><a name="l03425"></a><span class="lineno"> 3425</span>&#160;}</div><div class="line"><a name="l03426"></a><span class="lineno"> 3426</span>&#160;</div><div class="line"><a name="l03427"></a><span class="lineno"> 3427</span>&#160;ACTION_P(Bar, param) {</div><div class="line"><a name="l03428"></a><span class="lineno"> 3428</span>&#160;  // Makes sure the type of arg1 is const char*.</div><div class="line"><a name="l03429"></a><span class="lineno"> 3429</span>&#160;  ::testing::StaticAssertTypeEq&lt;const char*, arg1_type&gt;();</div><div class="line"><a name="l03430"></a><span class="lineno"> 3430</span>&#160;</div><div class="line"><a name="l03431"></a><span class="lineno"> 3431</span>&#160;  // Makes sure param can be converted to bool.</div><div class="line"><a name="l03432"></a><span class="lineno"> 3432</span>&#160;  bool flag = param;</div><div class="line"><a name="l03433"></a><span class="lineno"> 3433</span>&#160;}</div><div class="line"><a name="l03434"></a><span class="lineno"> 3434</span>&#160;```</div><div class="line"><a name="l03435"></a><span class="lineno"> 3435</span>&#160;where `StaticAssertTypeEq` is a compile-time assertion in Google Test</div><div class="line"><a name="l03436"></a><span class="lineno"> 3436</span>&#160;that verifies two types are the same.</div><div class="line"><a name="l03437"></a><span class="lineno"> 3437</span>&#160;</div><div class="line"><a name="l03438"></a><span class="lineno"> 3438</span>&#160;## Writing New Action Templates Quickly ##</div><div class="line"><a name="l03439"></a><span class="lineno"> 3439</span>&#160;</div><div class="line"><a name="l03440"></a><span class="lineno"> 3440</span>&#160;Sometimes you want to give an action explicit template parameters that</div><div class="line"><a name="l03441"></a><span class="lineno"> 3441</span>&#160;cannot be inferred from its value parameters.  `ACTION_TEMPLATE()`</div><div class="line"><a name="l03442"></a><span class="lineno"> 3442</span>&#160;supports that and can be viewed as an extension to `ACTION()` and</div><div class="line"><a name="l03443"></a><span class="lineno"> 3443</span>&#160;`ACTION_P*()`.</div><div class="line"><a name="l03444"></a><span class="lineno"> 3444</span>&#160;</div><div class="line"><a name="l03445"></a><span class="lineno"> 3445</span>&#160;The syntax:</div><div class="line"><a name="l03446"></a><span class="lineno"> 3446</span>&#160;```</div><div class="line"><a name="l03447"></a><span class="lineno"> 3447</span>&#160;ACTION_TEMPLATE(ActionName,</div><div class="line"><a name="l03448"></a><span class="lineno"> 3448</span>&#160;                HAS_m_TEMPLATE_PARAMS(kind1, name1, ..., kind_m, name_m),</div><div class="line"><a name="l03449"></a><span class="lineno"> 3449</span>&#160;                AND_n_VALUE_PARAMS(p1, ..., p_n)) { statements; }</div><div class="line"><a name="l03450"></a><span class="lineno"> 3450</span>&#160;```</div><div class="line"><a name="l03451"></a><span class="lineno"> 3451</span>&#160;</div><div class="line"><a name="l03452"></a><span class="lineno"> 3452</span>&#160;defines an action template that takes _m_ explicit template parameters</div><div class="line"><a name="l03453"></a><span class="lineno"> 3453</span>&#160;and _n_ value parameters, where _m_ is between 1 and 10, and _n_ is</div><div class="line"><a name="l03454"></a><span class="lineno"> 3454</span>&#160;between 0 and 10.  `name_i` is the name of the i-th template</div><div class="line"><a name="l03455"></a><span class="lineno"> 3455</span>&#160;parameter, and `kind_i` specifies whether it&#39;s a `typename`, an</div><div class="line"><a name="l03456"></a><span class="lineno"> 3456</span>&#160;integral constant, or a template.  `p_i` is the name of the i-th value</div><div class="line"><a name="l03457"></a><span class="lineno"> 3457</span>&#160;parameter.</div><div class="line"><a name="l03458"></a><span class="lineno"> 3458</span>&#160;</div><div class="line"><a name="l03459"></a><span class="lineno"> 3459</span>&#160;Example:</div><div class="line"><a name="l03460"></a><span class="lineno"> 3460</span>&#160;```</div><div class="line"><a name="l03461"></a><span class="lineno"> 3461</span>&#160;// DuplicateArg&lt;k, T&gt;(output) converts the k-th argument of the mock</div><div class="line"><a name="l03462"></a><span class="lineno"> 3462</span>&#160;// function to type T and copies it to *output.</div><div class="line"><a name="l03463"></a><span class="lineno"> 3463</span>&#160;ACTION_TEMPLATE(DuplicateArg,</div><div class="line"><a name="l03464"></a><span class="lineno"> 3464</span>&#160;                // Note the comma between int and k:</div><div class="line"><a name="l03465"></a><span class="lineno"> 3465</span>&#160;                HAS_2_TEMPLATE_PARAMS(int, k, typename, T),</div><div class="line"><a name="l03466"></a><span class="lineno"> 3466</span>&#160;                AND_1_VALUE_PARAMS(output)) {</div><div class="line"><a name="l03467"></a><span class="lineno"> 3467</span>&#160;  *output = T(::testing::get&lt;k&gt;(args));</div><div class="line"><a name="l03468"></a><span class="lineno"> 3468</span>&#160;}</div><div class="line"><a name="l03469"></a><span class="lineno"> 3469</span>&#160;```</div><div class="line"><a name="l03470"></a><span class="lineno"> 3470</span>&#160;</div><div class="line"><a name="l03471"></a><span class="lineno"> 3471</span>&#160;To create an instance of an action template, write:</div><div class="line"><a name="l03472"></a><span class="lineno"> 3472</span>&#160;```</div><div class="line"><a name="l03473"></a><span class="lineno"> 3473</span>&#160;  ActionName&lt;t1, ..., t_m&gt;(v1, ..., v_n)</div><div class="line"><a name="l03474"></a><span class="lineno"> 3474</span>&#160;```</div><div class="line"><a name="l03475"></a><span class="lineno"> 3475</span>&#160;where the `t`s are the template arguments and the</div><div class="line"><a name="l03476"></a><span class="lineno"> 3476</span>&#160;`v`s are the value arguments.  The value argument</div><div class="line"><a name="l03477"></a><span class="lineno"> 3477</span>&#160;types are inferred by the compiler.  For example:</div><div class="line"><a name="l03478"></a><span class="lineno"> 3478</span>&#160;```</div><div class="line"><a name="l03479"></a><span class="lineno"> 3479</span>&#160;using ::testing::_;</div><div class="line"><a name="l03480"></a><span class="lineno"> 3480</span>&#160;...</div><div class="line"><a name="l03481"></a><span class="lineno"> 3481</span>&#160;  int n;</div><div class="line"><a name="l03482"></a><span class="lineno"> 3482</span>&#160;  EXPECT_CALL(mock, Foo(_, _))</div><div class="line"><a name="l03483"></a><span class="lineno"> 3483</span>&#160;      .WillOnce(DuplicateArg&lt;1, unsigned char&gt;(&amp;n));</div><div class="line"><a name="l03484"></a><span class="lineno"> 3484</span>&#160;```</div><div class="line"><a name="l03485"></a><span class="lineno"> 3485</span>&#160;</div><div class="line"><a name="l03486"></a><span class="lineno"> 3486</span>&#160;If you want to explicitly specify the value argument types, you can</div><div class="line"><a name="l03487"></a><span class="lineno"> 3487</span>&#160;provide additional template arguments:</div><div class="line"><a name="l03488"></a><span class="lineno"> 3488</span>&#160;```</div><div class="line"><a name="l03489"></a><span class="lineno"> 3489</span>&#160;  ActionName&lt;t1, ..., t_m, u1, ..., u_k&gt;(v1, ..., v_n)</div><div class="line"><a name="l03490"></a><span class="lineno"> 3490</span>&#160;```</div><div class="line"><a name="l03491"></a><span class="lineno"> 3491</span>&#160;where `u_i` is the desired type of `v_i`.</div><div class="line"><a name="l03492"></a><span class="lineno"> 3492</span>&#160;</div><div class="line"><a name="l03493"></a><span class="lineno"> 3493</span>&#160;`ACTION_TEMPLATE` and `ACTION`/`ACTION_P*` can be overloaded on the</div><div class="line"><a name="l03494"></a><span class="lineno"> 3494</span>&#160;number of value parameters, but not on the number of template</div><div class="line"><a name="l03495"></a><span class="lineno"> 3495</span>&#160;parameters.  Without the restriction, the meaning of the following is</div><div class="line"><a name="l03496"></a><span class="lineno"> 3496</span>&#160;unclear:</div><div class="line"><a name="l03497"></a><span class="lineno"> 3497</span>&#160;</div><div class="line"><a name="l03498"></a><span class="lineno"> 3498</span>&#160;```</div><div class="line"><a name="l03499"></a><span class="lineno"> 3499</span>&#160;  OverloadedAction&lt;int, bool&gt;(x);</div><div class="line"><a name="l03500"></a><span class="lineno"> 3500</span>&#160;```</div><div class="line"><a name="l03501"></a><span class="lineno"> 3501</span>&#160;</div><div class="line"><a name="l03502"></a><span class="lineno"> 3502</span>&#160;Are we using a single-template-parameter action where `bool` refers to</div><div class="line"><a name="l03503"></a><span class="lineno"> 3503</span>&#160;the type of `x`, or a two-template-parameter action where the compiler</div><div class="line"><a name="l03504"></a><span class="lineno"> 3504</span>&#160;is asked to infer the type of `x`?</div><div class="line"><a name="l03505"></a><span class="lineno"> 3505</span>&#160;</div><div class="line"><a name="l03506"></a><span class="lineno"> 3506</span>&#160;## Using the ACTION Object&#39;s Type ##</div><div class="line"><a name="l03507"></a><span class="lineno"> 3507</span>&#160;</div><div class="line"><a name="l03508"></a><span class="lineno"> 3508</span>&#160;If you are writing a function that returns an `ACTION` object, you&#39;ll</div><div class="line"><a name="l03509"></a><span class="lineno"> 3509</span>&#160;need to know its type.  The type depends on the macro used to define</div><div class="line"><a name="l03510"></a><span class="lineno"> 3510</span>&#160;the action and the parameter types.  The rule is relatively simple:</div><div class="line"><a name="l03511"></a><span class="lineno"> 3511</span>&#160;| **Given Definition** | **Expression** | **Has Type** |</div><div class="line"><a name="l03512"></a><span class="lineno"> 3512</span>&#160;|:---------------------|:---------------|:-------------|</div><div class="line"><a name="l03513"></a><span class="lineno"> 3513</span>&#160;| `ACTION(Foo)`        | `Foo()`        | `FooAction`  |</div><div class="line"><a name="l03514"></a><span class="lineno"> 3514</span>&#160;| `ACTION_TEMPLATE(Foo, HAS_m_TEMPLATE_PARAMS(...), AND_0_VALUE_PARAMS())` |   `Foo&lt;t1, ..., t_m&gt;()` | `FooAction&lt;t1, ..., t_m&gt;` |</div><div class="line"><a name="l03515"></a><span class="lineno"> 3515</span>&#160;| `ACTION_P(Bar, param)` | `Bar(int_value)` | `BarActionP&lt;int&gt;` |</div><div class="line"><a name="l03516"></a><span class="lineno"> 3516</span>&#160;| `ACTION_TEMPLATE(Bar, HAS_m_TEMPLATE_PARAMS(...), AND_1_VALUE_PARAMS(p1))` | `Bar&lt;t1, ..., t_m&gt;(int_value)` | `FooActionP&lt;t1, ..., t_m, int&gt;` |</div><div class="line"><a name="l03517"></a><span class="lineno"> 3517</span>&#160;| `ACTION_P2(Baz, p1, p2)` | `Baz(bool_value, int_value)` | `BazActionP2&lt;bool, int&gt;` |</div><div class="line"><a name="l03518"></a><span class="lineno"> 3518</span>&#160;| `ACTION_TEMPLATE(Baz, HAS_m_TEMPLATE_PARAMS(...), AND_2_VALUE_PARAMS(p1, p2))` | `Baz&lt;t1, ..., t_m&gt;(bool_value, int_value)` | `FooActionP2&lt;t1, ..., t_m, bool, int&gt;` |</div><div class="line"><a name="l03519"></a><span class="lineno"> 3519</span>&#160;| ...                  | ...            | ...          |</div><div class="line"><a name="l03520"></a><span class="lineno"> 3520</span>&#160;</div><div class="line"><a name="l03521"></a><span class="lineno"> 3521</span>&#160;Note that we have to pick different suffixes (`Action`, `ActionP`,</div><div class="line"><a name="l03522"></a><span class="lineno"> 3522</span>&#160;`ActionP2`, and etc) for actions with different numbers of value</div><div class="line"><a name="l03523"></a><span class="lineno"> 3523</span>&#160;parameters, or the action definitions cannot be overloaded on the</div><div class="line"><a name="l03524"></a><span class="lineno"> 3524</span>&#160;number of them.</div><div class="line"><a name="l03525"></a><span class="lineno"> 3525</span>&#160;</div><div class="line"><a name="l03526"></a><span class="lineno"> 3526</span>&#160;## Writing New Monomorphic Actions ##</div><div class="line"><a name="l03527"></a><span class="lineno"> 3527</span>&#160;</div><div class="line"><a name="l03528"></a><span class="lineno"> 3528</span>&#160;While the `ACTION*` macros are very convenient, sometimes they are</div><div class="line"><a name="l03529"></a><span class="lineno"> 3529</span>&#160;inappropriate.  For example, despite the tricks shown in the previous</div><div class="line"><a name="l03530"></a><span class="lineno"> 3530</span>&#160;recipes, they don&#39;t let you directly specify the types of the mock</div><div class="line"><a name="l03531"></a><span class="lineno"> 3531</span>&#160;function arguments and the action parameters, which in general leads</div><div class="line"><a name="l03532"></a><span class="lineno"> 3532</span>&#160;to unoptimized compiler error messages that can baffle unfamiliar</div><div class="line"><a name="l03533"></a><span class="lineno"> 3533</span>&#160;users.  They also don&#39;t allow overloading actions based on parameter</div><div class="line"><a name="l03534"></a><span class="lineno"> 3534</span>&#160;types without jumping through some hoops.</div><div class="line"><a name="l03535"></a><span class="lineno"> 3535</span>&#160;</div><div class="line"><a name="l03536"></a><span class="lineno"> 3536</span>&#160;An alternative to the `ACTION*` macros is to implement</div><div class="line"><a name="l03537"></a><span class="lineno"> 3537</span>&#160;`::testing::ActionInterface&lt;F&gt;`, where `F` is the type of the mock</div><div class="line"><a name="l03538"></a><span class="lineno"> 3538</span>&#160;function in which the action will be used. For example:</div><div class="line"><a name="l03539"></a><span class="lineno"> 3539</span>&#160;</div><div class="line"><a name="l03540"></a><span class="lineno"> 3540</span>&#160;```</div><div class="line"><a name="l03541"></a><span class="lineno"> 3541</span>&#160;template &lt;typename F&gt;class ActionInterface {</div><div class="line"><a name="l03542"></a><span class="lineno"> 3542</span>&#160; public:</div><div class="line"><a name="l03543"></a><span class="lineno"> 3543</span>&#160;  virtual ~ActionInterface();</div><div class="line"><a name="l03544"></a><span class="lineno"> 3544</span>&#160;</div><div class="line"><a name="l03545"></a><span class="lineno"> 3545</span>&#160;  // Performs the action.  Result is the return type of function type</div><div class="line"><a name="l03546"></a><span class="lineno"> 3546</span>&#160;  // F, and ArgumentTuple is the tuple of arguments of F.</div><div class="line"><a name="l03547"></a><span class="lineno"> 3547</span>&#160;  //</div><div class="line"><a name="l03548"></a><span class="lineno"> 3548</span>&#160;  // For example, if F is int(bool, const string&amp;), then Result would</div><div class="line"><a name="l03549"></a><span class="lineno"> 3549</span>&#160;  // be int, and ArgumentTuple would be ::testing::tuple&lt;bool, const string&amp;&gt;.</div><div class="line"><a name="l03550"></a><span class="lineno"> 3550</span>&#160;  virtual Result Perform(const ArgumentTuple&amp; args) = 0;</div><div class="line"><a name="l03551"></a><span class="lineno"> 3551</span>&#160;};</div><div class="line"><a name="l03552"></a><span class="lineno"> 3552</span>&#160;</div><div class="line"><a name="l03553"></a><span class="lineno"> 3553</span>&#160;using ::testing::_;</div><div class="line"><a name="l03554"></a><span class="lineno"> 3554</span>&#160;using ::testing::Action;</div><div class="line"><a name="l03555"></a><span class="lineno"> 3555</span>&#160;using ::testing::ActionInterface;</div><div class="line"><a name="l03556"></a><span class="lineno"> 3556</span>&#160;using ::testing::MakeAction;</div><div class="line"><a name="l03557"></a><span class="lineno"> 3557</span>&#160;</div><div class="line"><a name="l03558"></a><span class="lineno"> 3558</span>&#160;typedef int IncrementMethod(int*);</div><div class="line"><a name="l03559"></a><span class="lineno"> 3559</span>&#160;</div><div class="line"><a name="l03560"></a><span class="lineno"> 3560</span>&#160;class IncrementArgumentAction : public ActionInterface&lt;IncrementMethod&gt; {</div><div class="line"><a name="l03561"></a><span class="lineno"> 3561</span>&#160; public:</div><div class="line"><a name="l03562"></a><span class="lineno"> 3562</span>&#160;  virtual int Perform(const ::testing::tuple&lt;int*&gt;&amp; args) {</div><div class="line"><a name="l03563"></a><span class="lineno"> 3563</span>&#160;    int* p = ::testing::get&lt;0&gt;(args);  // Grabs the first argument.</div><div class="line"><a name="l03564"></a><span class="lineno"> 3564</span>&#160;    return *p++;</div><div class="line"><a name="l03565"></a><span class="lineno"> 3565</span>&#160;  }</div><div class="line"><a name="l03566"></a><span class="lineno"> 3566</span>&#160;};</div><div class="line"><a name="l03567"></a><span class="lineno"> 3567</span>&#160;</div><div class="line"><a name="l03568"></a><span class="lineno"> 3568</span>&#160;Action&lt;IncrementMethod&gt; IncrementArgument() {</div><div class="line"><a name="l03569"></a><span class="lineno"> 3569</span>&#160;  return MakeAction(new IncrementArgumentAction);</div><div class="line"><a name="l03570"></a><span class="lineno"> 3570</span>&#160;}</div><div class="line"><a name="l03571"></a><span class="lineno"> 3571</span>&#160;...</div><div class="line"><a name="l03572"></a><span class="lineno"> 3572</span>&#160;</div><div class="line"><a name="l03573"></a><span class="lineno"> 3573</span>&#160;  EXPECT_CALL(foo, Baz(_))</div><div class="line"><a name="l03574"></a><span class="lineno"> 3574</span>&#160;      .WillOnce(IncrementArgument());</div><div class="line"><a name="l03575"></a><span class="lineno"> 3575</span>&#160;</div><div class="line"><a name="l03576"></a><span class="lineno"> 3576</span>&#160;  int n = 5;</div><div class="line"><a name="l03577"></a><span class="lineno"> 3577</span>&#160;  foo.Baz(&amp;n);  // Should return 5 and change n to 6.</div><div class="line"><a name="l03578"></a><span class="lineno"> 3578</span>&#160;```</div><div class="line"><a name="l03579"></a><span class="lineno"> 3579</span>&#160;</div><div class="line"><a name="l03580"></a><span class="lineno"> 3580</span>&#160;## Writing New Polymorphic Actions ##</div><div class="line"><a name="l03581"></a><span class="lineno"> 3581</span>&#160;</div><div class="line"><a name="l03582"></a><span class="lineno"> 3582</span>&#160;The previous recipe showed you how to define your own action. This is</div><div class="line"><a name="l03583"></a><span class="lineno"> 3583</span>&#160;all good, except that you need to know the type of the function in</div><div class="line"><a name="l03584"></a><span class="lineno"> 3584</span>&#160;which the action will be used. Sometimes that can be a problem. For</div><div class="line"><a name="l03585"></a><span class="lineno"> 3585</span>&#160;example, if you want to use the action in functions with _different_</div><div class="line"><a name="l03586"></a><span class="lineno"> 3586</span>&#160;types (e.g. like `Return()` and `SetArgPointee()`).</div><div class="line"><a name="l03587"></a><span class="lineno"> 3587</span>&#160;</div><div class="line"><a name="l03588"></a><span class="lineno"> 3588</span>&#160;If an action can be used in several types of mock functions, we say</div><div class="line"><a name="l03589"></a><span class="lineno"> 3589</span>&#160;it&#39;s _polymorphic_. The `MakePolymorphicAction()` function template</div><div class="line"><a name="l03590"></a><span class="lineno"> 3590</span>&#160;makes it easy to define such an action:</div><div class="line"><a name="l03591"></a><span class="lineno"> 3591</span>&#160;</div><div class="line"><a name="l03592"></a><span class="lineno"> 3592</span>&#160;```</div><div class="line"><a name="l03593"></a><span class="lineno"> 3593</span>&#160;namespace testing {</div><div class="line"><a name="l03594"></a><span class="lineno"> 3594</span>&#160;</div><div class="line"><a name="l03595"></a><span class="lineno"> 3595</span>&#160;template &lt;typename Impl&gt;</div><div class="line"><a name="l03596"></a><span class="lineno"> 3596</span>&#160;PolymorphicAction&lt;Impl&gt; MakePolymorphicAction(const Impl&amp; impl);</div><div class="line"><a name="l03597"></a><span class="lineno"> 3597</span>&#160;</div><div class="line"><a name="l03598"></a><span class="lineno"> 3598</span>&#160;}  // namespace testing</div><div class="line"><a name="l03599"></a><span class="lineno"> 3599</span>&#160;```</div><div class="line"><a name="l03600"></a><span class="lineno"> 3600</span>&#160;</div><div class="line"><a name="l03601"></a><span class="lineno"> 3601</span>&#160;As an example, let&#39;s define an action that returns the second argument</div><div class="line"><a name="l03602"></a><span class="lineno"> 3602</span>&#160;in the mock function&#39;s argument list. The first step is to define an</div><div class="line"><a name="l03603"></a><span class="lineno"> 3603</span>&#160;implementation class:</div><div class="line"><a name="l03604"></a><span class="lineno"> 3604</span>&#160;</div><div class="line"><a name="l03605"></a><span class="lineno"> 3605</span>&#160;```</div><div class="line"><a name="l03606"></a><span class="lineno"> 3606</span>&#160;class ReturnSecondArgumentAction {</div><div class="line"><a name="l03607"></a><span class="lineno"> 3607</span>&#160; public:</div><div class="line"><a name="l03608"></a><span class="lineno"> 3608</span>&#160;  template &lt;typename Result, typename ArgumentTuple&gt;</div><div class="line"><a name="l03609"></a><span class="lineno"> 3609</span>&#160;  Result Perform(const ArgumentTuple&amp; args) const {</div><div class="line"><a name="l03610"></a><span class="lineno"> 3610</span>&#160;    // To get the i-th (0-based) argument, use ::testing::get&lt;i&gt;(args).</div><div class="line"><a name="l03611"></a><span class="lineno"> 3611</span>&#160;    return ::testing::get&lt;1&gt;(args);</div><div class="line"><a name="l03612"></a><span class="lineno"> 3612</span>&#160;  }</div><div class="line"><a name="l03613"></a><span class="lineno"> 3613</span>&#160;};</div><div class="line"><a name="l03614"></a><span class="lineno"> 3614</span>&#160;```</div><div class="line"><a name="l03615"></a><span class="lineno"> 3615</span>&#160;</div><div class="line"><a name="l03616"></a><span class="lineno"> 3616</span>&#160;This implementation class does _not_ need to inherit from any</div><div class="line"><a name="l03617"></a><span class="lineno"> 3617</span>&#160;particular class. What matters is that it must have a `Perform()`</div><div class="line"><a name="l03618"></a><span class="lineno"> 3618</span>&#160;method template. This method template takes the mock function&#39;s</div><div class="line"><a name="l03619"></a><span class="lineno"> 3619</span>&#160;arguments as a tuple in a **single** argument, and returns the result of</div><div class="line"><a name="l03620"></a><span class="lineno"> 3620</span>&#160;the action. It can be either `const` or not, but must be invokable</div><div class="line"><a name="l03621"></a><span class="lineno"> 3621</span>&#160;with exactly one template argument, which is the result type. In other</div><div class="line"><a name="l03622"></a><span class="lineno"> 3622</span>&#160;words, you must be able to call `Perform&lt;R&gt;(args)` where `R` is the</div><div class="line"><a name="l03623"></a><span class="lineno"> 3623</span>&#160;mock function&#39;s return type and `args` is its arguments in a tuple.</div><div class="line"><a name="l03624"></a><span class="lineno"> 3624</span>&#160;</div><div class="line"><a name="l03625"></a><span class="lineno"> 3625</span>&#160;Next, we use `MakePolymorphicAction()` to turn an instance of the</div><div class="line"><a name="l03626"></a><span class="lineno"> 3626</span>&#160;implementation class into the polymorphic action we need. It will be</div><div class="line"><a name="l03627"></a><span class="lineno"> 3627</span>&#160;convenient to have a wrapper for this:</div><div class="line"><a name="l03628"></a><span class="lineno"> 3628</span>&#160;</div><div class="line"><a name="l03629"></a><span class="lineno"> 3629</span>&#160;```</div><div class="line"><a name="l03630"></a><span class="lineno"> 3630</span>&#160;using ::testing::MakePolymorphicAction;</div><div class="line"><a name="l03631"></a><span class="lineno"> 3631</span>&#160;using ::testing::PolymorphicAction;</div><div class="line"><a name="l03632"></a><span class="lineno"> 3632</span>&#160;</div><div class="line"><a name="l03633"></a><span class="lineno"> 3633</span>&#160;PolymorphicAction&lt;ReturnSecondArgumentAction&gt; ReturnSecondArgument() {</div><div class="line"><a name="l03634"></a><span class="lineno"> 3634</span>&#160;  return MakePolymorphicAction(ReturnSecondArgumentAction());</div><div class="line"><a name="l03635"></a><span class="lineno"> 3635</span>&#160;}</div><div class="line"><a name="l03636"></a><span class="lineno"> 3636</span>&#160;```</div><div class="line"><a name="l03637"></a><span class="lineno"> 3637</span>&#160;</div><div class="line"><a name="l03638"></a><span class="lineno"> 3638</span>&#160;Now, you can use this polymorphic action the same way you use the</div><div class="line"><a name="l03639"></a><span class="lineno"> 3639</span>&#160;built-in ones:</div><div class="line"><a name="l03640"></a><span class="lineno"> 3640</span>&#160;</div><div class="line"><a name="l03641"></a><span class="lineno"> 3641</span>&#160;```</div><div class="line"><a name="l03642"></a><span class="lineno"> 3642</span>&#160;using ::testing::_;</div><div class="line"><a name="l03643"></a><span class="lineno"> 3643</span>&#160;</div><div class="line"><a name="l03644"></a><span class="lineno"> 3644</span>&#160;class MockFoo : public Foo {</div><div class="line"><a name="l03645"></a><span class="lineno"> 3645</span>&#160; public:</div><div class="line"><a name="l03646"></a><span class="lineno"> 3646</span>&#160;  MOCK_METHOD2(DoThis, int(bool flag, int n));</div><div class="line"><a name="l03647"></a><span class="lineno"> 3647</span>&#160;  MOCK_METHOD3(DoThat, string(int x, const char* str1, const char* str2));</div><div class="line"><a name="l03648"></a><span class="lineno"> 3648</span>&#160;};</div><div class="line"><a name="l03649"></a><span class="lineno"> 3649</span>&#160;...</div><div class="line"><a name="l03650"></a><span class="lineno"> 3650</span>&#160;</div><div class="line"><a name="l03651"></a><span class="lineno"> 3651</span>&#160;  MockFoo foo;</div><div class="line"><a name="l03652"></a><span class="lineno"> 3652</span>&#160;  EXPECT_CALL(foo, DoThis(_, _))</div><div class="line"><a name="l03653"></a><span class="lineno"> 3653</span>&#160;      .WillOnce(ReturnSecondArgument());</div><div class="line"><a name="l03654"></a><span class="lineno"> 3654</span>&#160;  EXPECT_CALL(foo, DoThat(_, _, _))</div><div class="line"><a name="l03655"></a><span class="lineno"> 3655</span>&#160;      .WillOnce(ReturnSecondArgument());</div><div class="line"><a name="l03656"></a><span class="lineno"> 3656</span>&#160;  ...</div><div class="line"><a name="l03657"></a><span class="lineno"> 3657</span>&#160;  foo.DoThis(true, 5);         // Will return 5.</div><div class="line"><a name="l03658"></a><span class="lineno"> 3658</span>&#160;  foo.DoThat(1, &quot;Hi&quot;, &quot;Bye&quot;);  // Will return &quot;Hi&quot;.</div><div class="line"><a name="l03659"></a><span class="lineno"> 3659</span>&#160;```</div><div class="line"><a name="l03660"></a><span class="lineno"> 3660</span>&#160;</div><div class="line"><a name="l03661"></a><span class="lineno"> 3661</span>&#160;## Teaching Google Mock How to Print Your Values ##</div><div class="line"><a name="l03662"></a><span class="lineno"> 3662</span>&#160;</div><div class="line"><a name="l03663"></a><span class="lineno"> 3663</span>&#160;When an uninteresting or unexpected call occurs, Google Mock prints the</div><div class="line"><a name="l03664"></a><span class="lineno"> 3664</span>&#160;argument values and the stack trace to help you debug.  Assertion</div><div class="line"><a name="l03665"></a><span class="lineno"> 3665</span>&#160;macros like `EXPECT_THAT` and `EXPECT_EQ` also print the values in</div><div class="line"><a name="l03666"></a><span class="lineno"> 3666</span>&#160;question when the assertion fails.  Google Mock and Google Test do this using</div><div class="line"><a name="l03667"></a><span class="lineno"> 3667</span>&#160;Google Test&#39;s user-extensible value printer.</div><div class="line"><a name="l03668"></a><span class="lineno"> 3668</span>&#160;</div><div class="line"><a name="l03669"></a><span class="lineno"> 3669</span>&#160;This printer knows how to print built-in C++ types, native arrays, STL</div><div class="line"><a name="l03670"></a><span class="lineno"> 3670</span>&#160;containers, and any type that supports the `&lt;&lt;` operator.  For other</div><div class="line"><a name="l03671"></a><span class="lineno"> 3671</span>&#160;types, it prints the raw bytes in the value and hopes that you the</div><div class="line"><a name="l03672"></a><span class="lineno"> 3672</span>&#160;user can figure it out.</div><div class="line"><a name="l03673"></a><span class="lineno"> 3673</span>&#160;[Google Test&#39;s advanced guide](../../googletest/docs/AdvancedGuide.md#teaching-google-test-how-to-print-your-values)</div><div class="line"><a name="l03674"></a><span class="lineno"> 3674</span>&#160;explains how to extend the printer to do a better job at</div><div class="line"><a name="l03675"></a><span class="lineno"> 3675</span>&#160;printing your particular type than to dump the bytes.</div></div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d3/d19/_cook_book_8md.html">CookBook.md</a></li>
    <li class="footer">構築:
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
