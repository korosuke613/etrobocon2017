<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ETrobocon2017 - 片山研究所モデルベース開発推進事業部: profiles</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ETrobocon2017 - 片山研究所モデルベース開発推進事業部
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 構築: Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'検索');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','検索');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">profiles </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In the following, we explain how the various Bluetooth profiles are used in BTstack.</p>
<h2>GAP - Generic Access Profile: Classic</h2>
<p>The GAP profile defines how devices find each other and establish a secure connection for other profiles. As mentioned before, the GAP functionality is split between and . Please check both.</p>
<h3>Become discoverable</h3>
<p>A remote unconnected Bluetooth device must be set as “discoverable” in order to be seen by a device performing the inquiry scan. To become discoverable, an application can call <em>hci_discoverable_control</em> with input parameter 1. If you want to provide a helpful name for your device, the application can set its local name by calling $gap_set_local_name$. To save energy, you may set the device as undiscoverable again, once a connection is established. See Listing <a href="../../#lst:Discoverable">below</a> for an example.</p>
<div class="fragment"><div class="line">int main(void){</div><div class="line">    ... </div><div class="line">    // make discoverable</div><div class="line">    hci_discoverable_control(1);</div><div class="line">    run_loop_execute(); </div><div class="line">    return 0;</div><div class="line">}</div><div class="line">void packet_handler (uint8_t packet_type, uint8_t *packet, uint16_t size){</div><div class="line">     ...</div><div class="line">     switch(state){</div><div class="line">          case W4_CHANNEL_COMPLETE:</div><div class="line">              // if connection is successful, make device undiscoverable</div><div class="line">              hci_discoverable_control(0);</div><div class="line">          ...</div><div class="line">     }</div><div class="line"> }</div></div><!-- fragment --><h3>Discover remote devices {#sec:GAPdiscoverRemoteDevices}</h3>
<p>To scan for remote devices, the <em>hci_inquiry</em> command is used. Found remote devices are reported as a part of:</p>
<ul>
<li>HCI_EVENT_INQUIRY_RESULT,</li>
<li>HCI_EVENT-_INQUIRY_RESULT_WITH_RSSI, or</li>
<li>HCI_EVENT_EXTENDED_INQUIRY_RESPONSE events.</li>
</ul>
<p>Each response contains at least the Bluetooth address, the class of device, the page scan repetition mode, and the clock offset of found device. The latter events add information about the received signal strength or provide the Extended Inquiry Result (EIR). A code snippet is shown in Listing <a href="../../#lst:DiscoverDevices">below</a>.</p>
<div class="fragment"><div class="line">void print_inquiry_results(uint8_t *packet){</div><div class="line">    int event = packet[0];</div><div class="line">    int numResponses = packet[2];</div><div class="line">    uint16_t classOfDevice, clockOffset;</div><div class="line">    uint8_t  rssi, pageScanRepetitionMode;</div><div class="line">    for (i=0; i&lt;numResponses; i++){</div><div class="line">        bt_flip_addr(addr, &amp;packet[3+i*6]);</div><div class="line">        pageScanRepetitionMode = packet [3 + numResponses*6 + i];</div><div class="line">        if (event == HCI_EVENT_INQUIRY_RESULT){</div><div class="line">            classOfDevice = READ_BT_24(packet, 3 + numResponses*(6+1+1+1) + i*3);</div><div class="line">            clockOffset =   READ_BT_16(packet, 3 + numResponses*(6+1+1+1+3) + i*2) &amp; 0x7fff;</div><div class="line">            rssi  = 0;</div><div class="line">        } else {</div><div class="line">            classOfDevice = READ_BT_24(packet, 3 + numResponses*(6+1+1)     + i*3);</div><div class="line">            clockOffset =   READ_BT_16(packet, 3 + numResponses*(6+1+1+3)   + i*2) &amp; 0x7fff;</div><div class="line">            rssi  = packet [3 + numResponses*(6+1+1+3+2) + i*1];</div><div class="line">        }</div><div class="line">        printf(&quot;Device found: %s with COD: 0x%06x, pageScan %u, clock offset 0x%04x, rssi 0x%02x\n&quot;, bd_addr_to_str(addr), classOfDevice, pageScanRepetitionMode, clockOffset, rssi);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line">void packet_handler (uint8_t packet_type, uint8_t *packet, uint16_t size){</div><div class="line">    ...</div><div class="line">    switch (event) {</div><div class="line">         case HCI_STATE_WORKING:</div><div class="line">            hci_send_cmd(&amp;hci_write_inquiry_mode, 0x01); // with RSSI</div><div class="line">            break;</div><div class="line">        case HCI_EVENT_COMMAND_COMPLETE:</div><div class="line">            if (COMMAND_COMPLETE_EVENT(packet, hci_write_inquiry_mode) ) {</div><div class="line">                start_scan();</div><div class="line">            }</div><div class="line">        case HCI_EVENT_COMMAND_STATUS:</div><div class="line">            if (COMMAND_STATUS_EVENT(packet, hci_write_inquiry_mode) ) {</div><div class="line">                printf(&quot;Ignoring error (0x%x) from hci_write_inquiry_mode.\n&quot;, packet[2]);</div><div class="line">                hci_send_cmd(&amp;hci_inquiry, HCI_INQUIRY_LAP, INQUIRY_INTERVAL, 0);</div><div class="line">            }</div><div class="line">            break;</div><div class="line">        case HCI_EVENT_INQUIRY_RESULT:</div><div class="line">        case HCI_EVENT_INQUIRY_RESULT_WITH_RSSI:</div><div class="line">            print_inquiry_results(packet);</div><div class="line">            break;</div><div class="line">       ...</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>By default, neither RSSI values nor EIR are reported. If the Bluetooth device implements Bluetooth Specification 2.1 or higher, the <em>hci_write_inquiry_mode</em> command enables reporting of this advanced features (0 for standard results, 1 for RSSI, 2 for RSSI and EIR).</p>
<p>A complete GAP inquiry example is provided <a href="../../examples/generated/#sec:gapinquiryExample">here</a>.</p>
<h3>Pairing of Devices</h3>
<p>By default, Bluetooth communication is not authenticated, and any device can talk to any other device. A Bluetooth device (for example, cellular phone) may choose to require authentication to provide a particular service (for example, a Dial-Up service). The process of establishing authentication is called pairing. Bluetooth provides two mechanism for this.</p>
<p>On Bluetooth devices that conform to the Bluetooth v2.0 or older specification, a PIN code (up to 16 bytes ASCII) has to be entered on both sides. This isn’t optimal for embedded systems that do not have full I/O capabilities. To support pairing with older devices using a PIN, see Listing <a href="../../#lst:PinCodeRequest">below</a>.</p>
<div class="fragment"><div class="line">void packet_handler (uint8_t packet_type, uint8_t *packet, uint16_t size){</div><div class="line">    ...</div><div class="line">    switch (event) {</div><div class="line">        case HCI_EVENT_PIN_CODE_REQUEST:</div><div class="line">            // inform about pin code request</div><div class="line">            printf(&quot;Pin code request - using &#39;0000&#39;\n\r&quot;);</div><div class="line">            bt_flip_addr(bd_addr, &amp;packet[2]);</div><div class="line"></div><div class="line">            // baseband address, pin length, PIN: c-string</div><div class="line">            hci_send_cmd(&amp;hci_pin_code_request_reply, &amp;bd_addr, 4, &quot;0000&quot;);</div><div class="line">            break;</div><div class="line">       ...</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>The Bluetooth v2.1 specification introduces Secure Simple Pairing (SSP), which is a better approach as it both improves security and is better adapted to embedded systems. With SSP, the devices first exchange their IO Capabilities and then settle on one of several ways to verify that the pairing is legitimate. If the Bluetooth device supports SSP, BTstack enables it by default and even automatically accepts SSP pairing requests. Depending on the product in which BTstack is used, this may not be desired and should be replaced with code to interact with the user.</p>
<p>Regardless of the authentication mechanism (PIN/SSP), on success, both devices will generate a link key. The link key can be stored either in the Bluetooth module itself or in a persistent storage, see <a href="../../porting/#sec:persistentStoragePorting">here</a>. The next time the device connects and requests an authenticated connection, both devices can use the previously generated link key. Please note that the pairing must be repeated if the link key is lost by one device.</p>
<h3>Dedicated Bonding</h3>
<p>Aside from the regular bonding, Bluetooth also provides the concept of “dedicated bonding”, where a connection is established for the sole purpose of bonding the device. After the bonding process is over, the connection will be automatically terminated. BTstack supports dedicated bonding via the <em>gap_dedicated_bonding</em> function.</p>
<h2>SPP - Serial Port Profile</h2>
<p>The SPP profile defines how to set up virtual serial ports and connect two Bluetooth enabled devices.</p>
<h3>Accessing an SPP Server on a remote device</h3>
<p>To access a remote SPP server, you first need to query the remote device for its SPP services. Section <a href="../../#sec:querySDPProtocols">on querying remote SDP service</a> shows how to query for all RFCOMM channels. For SPP, you can do the same but use the SPP UUID 0x1101 for the query. After you have identified the correct RFCOMM channel, you can create an RFCOMM connection as shown <a href="../../protocols/#sec:rfcommClientProtocols">here</a>.</p>
<h3>Providing an SPP Server</h3>
<p>To provide an SPP Server, you need to provide an RFCOMM service with a specific RFCOMM channel number as explained in section on <a href="../../protocols/#sec:rfcommServiceProtocols">RFCOMM service</a>. Then, you need to create an SDP record for it and publish it with the SDP server by calling <em>sdp_register_service_internal</em>. BTstack provides the <em>sdp_create_spp_service</em> function in that requires an empty buffer of approximately 200 bytes, the service channel number, and a service name. Have a look at the [SPP Counter example](examples/generated/#sec:sppcounterExample].</p>
<h2>PAN - Personal Area Networking Profile {#sec:panProfiles}</h2>
<p>The PAN profile uses BNEP to provide on-demand networking capabilities between Bluetooth devices. The PAN profile defines the following roles:</p>
<ul>
<li>PAN User (PANU)</li>
<li>Network Access Point (NAP)</li>
<li>Group Ad-hoc Network (GN)</li>
</ul>
<p>PANU is a Bluetooth device that communicates as a client with GN, or NAP, or with another PANU Bluetooth device, through a point-to-point connection. Either the PANU or the other Bluetooth device may terminate the connection at anytime.</p>
<p>NAP is a Bluetooth device that provides the service of routing network packets between PANU by using BNEP and the IP routing mechanism. A NAP can also act as a bridge between Bluetooth networks and other network technologies by using the Ethernet packets.</p>
<p>The GN role enables two or more PANUs to interact with each other through a wireless network without using additional networking hardware. The devices are connected in a piconet where the GN acts as a master and communicates either point-to-point or a point-to-multipoint with a maximum of seven PANU slaves by using BNEP.</p>
<p>Currently, BTstack supports only PANU.</p>
<h3>Accessing a remote PANU service</h3>
<p>To access a remote PANU service, you first need perform an SDP query to get the L2CAP PSM for the requested PANU UUID. With these two pieces of information, you can connect BNEP to the remote PANU service with the <em>bnep_connect</em> function. The Section on <a href="../../#exaples/#sec:panudemoExample">PANU Demo example</a> shows how this is accomplished.</p>
<h3>Providing a PANU service</h3>
<p>To provide a PANU service, you need to provide a BNEP service with the service UUID, e.g. the PANU UUID, and a a maximal ethernet frame size, as explained in Section <a href="../../protocols/#sec:bnepServiceProtocols">on BNEP service</a>. Then, you need to create an SDP record for it and publish it with the SDP server by calling <em>sdp_register_service_internal</em>. BTstack provides the <em>pan_create_panu_service</em> function in <em>src/pan.c</em> that requires an empty buffer of approximately 200 bytes, a description, and a security description.</p>
<h2>GAP LE - Generic Access Profile for Low Energy</h2>
<p>As with GAP for Classic, the GAP LE profile defines how to discover and how to connect to a Bluetooth Low Energy device. There are several GAP roles that a Bluetooth device can take, but the most important ones are the Central and the Peripheral role. Peripheral devices are those that provide information or can be controlled. Central devices are those that consume information or control the peripherals. Before the connection can be established, devices are first going through an advertising process.</p>
<h3>Private addresses.</h3>
<p>To better protect privacy, an LE device can choose to use a private i.e. random Bluetooth address. This address changes at a user-specified rate. To allow for later reconnection, the central and peripheral devices will exchange their Identity Resolving Keys (IRKs) during bonding. The IRK is used to verify if a new address belongs to a previously bonded device.</p>
<p>To toggle privacy mode using private addresses, call the <em>gap_random_address_set_mode</em> function. The update period can be set with <em>gap_random_address_set_update_period</em>.</p>
<p>After a connection is established, the Security Manager will try to resolve the peer Bluetooth address as explained in Section on <a href="../../protocols/#sec:smpProtocols">SMP</a>.</p>
<h3>Advertising and Discovery</h3>
<p>An LE device is discoverable and connectable, only if it periodically sends out Advertisements. An advertisement contains up to 31 bytes of data. To configure and enable advertisement broadcast, the following GAP functions can be used:</p>
<ul>
<li><em>gap_advertisements_set_data</em></li>
<li><em>gap_advertisements_set_params</em></li>
<li><em>gap_advertisements_enable</em></li>
</ul>
<p>Please have a look at the <a href="../../examples/generated/#sec:sppandlecounterExample">SPP and LE Counter example</a>.</p>
<p>In addition to the Advertisement data, a device in the peripheral role can also provide Scan Response data, which has to be explicitly queried by the central device. It can be provided with the <em>hci_le_set_scan_response_data</em>.</p>
<p>The scan parameters can be set with <em>le_central_set_scan_parameters</em>. The scan can be started/stopped with <em>le_central_start_scan</em>/*le_central_stop_scan*.</p>
<p>Finally, if a suitable device is found, a connection can be initiated by calling <em>le_central_connect</em>. In contrast to Bluetooth classic, there is no timeout for an LE connection establishment. To cancel such an attempt, <em>le_central_connect_cancel</em> has be be called.</p>
<p>By default, a Bluetooth device stops sending Advertisements when it gets into the Connected state. However, it does not start broadcasting advertisements on disconnect again. To re-enable it, please send the <em>hci_le_set_advertise_enable</em> again .</p>
<h2>GATT - Generic Attribute Profile</h2>
<p>The GATT profile uses ATT Attributes to represent a hierarchical structure of GATT Services and GATT Characteristics. Each Service has one or more Characteristics. Each Characteristic has meta data attached like its type or its properties. This hierarchy of Characteristics and Services are queried and modified via ATT operations.</p>
<p>GATT defines both a server and a client role. A device can implement one or both GATT roles.</p>
<h3>GATT Client {#sec:GATTClientProfiles}</h3>
<p>The GATT Client is used to discover services, and their characteristics and descriptors on a peer device. It can also subscribe for notifications or indications that the characteristic on the GATT server has changed its value.</p>
<p>To perform GATT queries, provides a rich interface. Before calling queries, the GATT client must be initialized with <em>gatt_client_init</em> once.</p>
<p>To allow for modular profile implementations, GATT client can be used independently by multiple entities.</p>
<p>To use it by a GATT client, you register a packet handler with <em>gatt_client_register_packet_ handler</em>. The return value of that is a GATT client ID which has to be provided in all queries.</p>
<p>After an LE connection was created using the GAP LE API, you can query for the connection MTU with <em>gatt_client_get_mtu</em>.</p>
<p>GATT queries cannot be interleaved. Therefore, you can check if you can perform a GATT query on a particular connection using <em>gatt_client_is_ready</em>. As a result to a GATT query, zero to many <em>le_event*s are returned before a *GATT_QUERY_COMPLETE</em> event completes the query.</p>
<p>For more details on the available GATT queries, please consult <a href="../../#sec:gattClientAPIAppendix">GATT Client API</a>.</p>
<h3>GATT Server {#sec:GATTServerProfiles}</h3>
<p>The GATT server stores data and accepts GATT client requests, commands and confirmations. The GATT server sends responses to requests and when configured, sends indication and notifications asynchronously to the GATT client.</p>
<p>To save on both code space and memory, BTstack does not provide a GATT Server implementation. Instead, a textual description of the GATT profile is directly converted into a compact internal ATT Attribute database by a GATT profile compiler. The ATT protocol server - implemented by and - answers incoming ATT requests based on information provided in the compiled database and provides read- and write-callbacks for dynamic attributes.</p>
<p>GATT profiles are defined by a simple textual comma separated value (.csv) representation. While the description is easy to read and edit, it is compact and can be placed in ROM.</p>
<p>The current format is shown in Listing <a href="../../#lst:GATTServerProfile">below</a>.</p>
<div class="fragment"><div class="line">PRIMARY_SERVICE, {SERVICE_UUID}</div><div class="line">CHARACTERISTIC, {ATTRIBUTE_TYPE_UUID}, {PROPERTIES}, {VALUE}</div><div class="line">CHARACTERISTIC, {ATTRIBUTE_TYPE_UUID}, {PROPERTIES}, {VALUE}</div><div class="line">...</div><div class="line">PRIMARY_SERVICE, {SERVICE_UUID}</div><div class="line">CHARACTERISTIC, {ATTRIBUTE_TYPE_UUID}, {PROPERTIES}, {VALUE}</div><div class="line">...</div></div><!-- fragment --><p>Properties can be a list of READ $|$ WRITE $|$ WRITE_WITHOUT_RESPONSE $|$ NOTIFY $|$ INDICATE $|$ DYNAMIC.</p>
<p>Value can either be a string (“this is a string”), or, a sequence of hex bytes (e.g. 01 02 03).</p>
<p>UUIDs are either 16 bit (1800) or 128 bit (00001234-0000-1000-8000-00805F9B34FB).</p>
<p>Reads/writes to a Characteristic that is defined with the DYNAMIC flag, are forwarded to the application via callback. Otherwise, the Characteristics cannot be written and it will return the specified constant value.</p>
<p>Adding NOTIFY and/or INDICATE automatically creates an addition Client Configuration Characteristic.</p>
<p>To require encryption or authentication before a Characteristic can be accessed, you can add ENCRYPTION_KEY_SIZE_X - with $X  [7..16]$ - or AUTHENTICATION_REQUIRED.</p>
<p>BTstack only provides an ATT Server, while the GATT Server logic is mainly provided by the GATT compiler. While GATT identifies Characteristics by UUIDs, ATT uses Handles (16 bit values). To allow to identify a Characteristic without hard-coding the attribute ID, the GATT compiler creates a list of defines in the generated *.h file. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
構築: &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
