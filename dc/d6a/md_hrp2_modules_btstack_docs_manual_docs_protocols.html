<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ETrobocon2017 - 片山研究所モデルベース開発推進事業部: protocols</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ETrobocon2017 - 片山研究所モデルベース開発推進事業部
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 構築: Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'検索');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','検索');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">protocols </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>BTstack is a modular dual-mode Bluetooth stack, supporting both Bluetooth Basic Rate/Enhanced Date Rate (BR/EDR) as well as Bluetooth Low Energy (LE). The BR/EDR technology, also known as Classic Bluetooth, provides a robust wireless connection between devices designed for high data rates. In contrast, the LE technology has a lower throughput but also lower energy consumption, faster connection setup, and the ability to connect to more devices in parallel.</p>
<p>Whether Classic or LE, a Bluetooth device implements one or more Bluetooth profiles. A Bluetooth profile specifies how one or more Bluetooth protocols are used to achieve its goals. For example, every Bluetooth device must implement the Generic Access Profile (GAP), which defines how devices find each other and how they establish a connection. This profile mainly make use of the Host Controller Interface (HCI) protocol, the lowest protocol in the stack hierarchy which implements a command interface to the Bluetooth chipset.</p>
<p>In addition to GAP, a popular Classic Bluetooth example would be a peripheral devices that can be connected via the Serial Port Profile (SPP). SPP basically specifies that a compatible device should provide a Service Discovery Protocol (SDP) record containing an RFCOMM channel number, which will be used for the actual communication.</p>
<p>Similarly, for every LE device, the Generic Attribute Profile (GATT) profile must be implemented in addition to GAP. GATT is built on top of the Attribute Protocol (ATT), and defines how one device can interact with GATT Services on a remote device.</p>
<p>So far, the most popular use of BTstack is in peripheral devices that can be connected via SPP (Android 2.0 or higher) and GATT (Android 4.3 or higher, and iOS 5 or higher). If higher data rates are required between a peripheral and iOS device, the iAP1 and iAP2 protocols of the Made for iPhone program can be used instead of GATT. Please contact us directly for information on BTstack and MFi.</p>
<p>Figure {:BTstackProtocolArchitecture} depicts Bluetooth protocols and profiles that are currently implemented by BTstack. In the following, we first explain how the various Bluetooth protocols are used in BTstack. In the next chapter, we go over the profiles.</p>
<div class="image">
<img src="../../picts/btstack-protocols.png" alt="Architecture of a BTstack-based application."/>
</div>
<p> {#fig:BTstackProtocolArchitecture}</p>
<h2>HCI - Host Controller Interface</h2>
<p>The HCI protocol provides a command interface to the Bluetooth chipset. In BTstack, the HCI implementation also keeps track of all active connections and handles the fragmentation and re-assembly of higher layer (L2CAP) packets.</p>
<p>Please note, that an application rarely has to send HCI commands on its own. Instead, BTstack provides convenience functions in GAP and higher level protocols use HCI automatically. E.g. to set the name, you can call <em>gap_set_local_name()</em> before powering up. The main use of HCI commands in application is during the startup phase to configure special features that are not available via the GAP API yet.</p>
<p>However, as many features of the GAP Classic can be achieved by sending a single HCI command, not all GAP convenience functions are listed in . If there’s no special GAP function, please consider sending the HCI command directly, as explained in the following.</p>
<h3>Defining custom HCI command templates</h3>
<p>Each HCI command is assigned a 2-byte OpCode used to uniquely identify different types of commands. The OpCode parameter is divided into two fields, called the OpCode Group Field (OGF) and OpCode Command Field (OCF), see <a href="https://www.bluetooth.org/Technical/Specifications/adopted.htm">Bluetooth Specification</a> - Core Version 4.0, Volume 2, Part E, Chapter 5.4.</p>
<p>Listing <a href="../../#lst:hciOGFs">below</a> shows the OGFs provided by BTstack in file [src/hci.h]():</p>
<div class="fragment"><div class="line">#define OGF_LINK_CONTROL  0x01</div><div class="line">#define OGF_LINK_POLICY  0x02</div><div class="line">#define OGF_CONTROLLER_BASEBAND  0x03</div><div class="line">#define OGF_INFORMATIONAL_PARAMETERS 0x04</div><div class="line">#define OGF_LE_CONTROLLER   0x08</div><div class="line">#define OGF_BTSTACK  0x3d</div><div class="line">#define OGF_VENDOR  0x3f</div></div><!-- fragment --><p>For all existing Bluetooth commands and their OCFs see <a href="https://www.bluetooth.org/Technical/Specifications/adopted.htm">Bluetooth Specification</a> - Core Version 4.0, Volume 2, Part E, Chapter 7.</p>
<p>In a HCI command packet, the OpCode is followed by parameter total length, and the actual parameters. The OpCode of a command can be calculated using the OPCODE macro. BTstack provides the <em>hci_cmd_t</em> struct as a compact format to define HCI command packets, see Listing <a href="../../#lst:HCIcmdTemplate">below</a>, and [include/btstack/hci_cmds.h]() file in the source code.</p>
<div class="fragment"><div class="line">// Calculate combined ogf/ocf value.</div><div class="line">#define OPCODE(ogf, ocf) (ocf | ogf &lt;&lt; 10)</div><div class="line"></div><div class="line">// Compact HCI Command packet description.</div><div class="line">typedef struct {</div><div class="line">    uint16_t    opcode;</div><div class="line">    const char *format;</div><div class="line">} hci_cmd_t;</div></div><!-- fragment --><p>Listing <a href="../../#lst:HCIcmdExample">below</a> illustrates the <em>hci_write_local_name</em> HCI command template from library:</p>
<div class="fragment"><div class="line">// Sets local Bluetooth name</div><div class="line">const hci_cmd_t hci_write_local_name = {</div><div class="line">    OPCODE(OGF_CONTROLLER_BASEBAND, 0x13), &quot;N&quot;</div><div class="line">    // Local name (UTF-8, Null Terminated, max 248 octets)</div><div class="line">};</div></div><!-- fragment --><p>It uses OGF_CONTROLLER_BASEBAND as OGF, 0x13 as OCF, and has one parameter with format “N” indicating a null terminated UTF-8 string. Table {:hciCmdParamSpecifier} lists the format specifiers supported by BTstack. Check for other predefined HCI commands and info on their parameters.</p>
<hr/>
<p> Format Specifier Description 1,2,3,4 one to four byte value A 31 bytes advertising data B Bluetooth Baseband Address D 8 byte data block E Extended Inquiry Information 240 octets H HCI connection handle N Name up to 248 chars, UTF8 string, null terminated P 16 byte Pairing code, e.g. PIN code or link key S Service Record (Data Element Sequence) </p><hr/>
<p>Table: Supported Format Specifiers of HCI Command Parameter. {#tbl:hciCmdParamSpecifier}</p>
<h3>Sending HCI command based on a template {#sec:sendingHCIProtocols}</h3>
<p>You can use the <em>hci_send_cmd</em> function to send HCI command based on a template and a list of parameters. However, it is necessary to check that the outgoing packet buffer is empty and that the Bluetooth module is ready to receive the next command - most modern Bluetooth modules only allow to send a single HCI command. This can be done by calling <em>hci_can_send_command_packet_now()</em> function, which returns true, if it is ok to send.</p>
<p>Listing <a href="../../#lst:HCIcmdExampleLocalName">below</a> illustrates how to manually set the device name with the HCI Write Local Name command.</p>
<div class="fragment"><div class="line">if (hci_can_send_packet_now(HCI_COMMAND_DATA_PACKET)){</div><div class="line">    hci_send_cmd(&amp;hci_write_local_name, &quot;BTstack Demo&quot;);</div><div class="line">}  </div></div><!-- fragment --><p>Please note, that an application rarely has to send HCI commands on its own. Instead, BTstack provides convenience functions in GAP and higher level protocols use HCI automatically.</p>
<h2>L2CAP - Logical Link Control and Adaptation Protocol</h2>
<p>The L2CAP protocol supports higher level protocol multiplexing and packet fragmentation. It provides the base for the RFCOMM and BNEP protocols. For all profiles that are officially supported by BTstack, L2CAP does not need to be used directly. For testing or the development of custom protocols, it’s helpful to be able to access and provide L2CAP services however.</p>
<h3>Access an L2CAP service on a remote device</h3>
<p>L2CAP is based around the concept of channels. A channel is a logical connection on top of a baseband connection. Each channel is bound to a single protocol in a many-to-one fashion. Multiple channels can be bound to the same protocol, but a channel cannot be bound to multiple protocols. Multiple channels can share the same baseband connection.</p>
<p>To communicate with an L2CAP service on a remote device, the application on a local Bluetooth device initiates the L2CAP layer using the <em>l2cap_init</em> function, and then creates an outgoing L2CAP channel to the PSM of a remote device using the <em>l2cap_create_channel_internal</em> function. The <em>l2cap_create_channel_internal</em> function will initiate a new baseband connection if it does not already exist. The packet handler that is given as an input parameter of the L2CAP create channel function will be assigned to the new outgoing L2CAP channel. This handler receives the L2CAP_EVENT_CHANNEL_OPENED and L2CAP_EVENT_CHANNEL_CLOSED events and L2CAP data packets, as shown in Listing <a href="../../#lst:L2CAPremoteService">below</a>.</p>
<div class="fragment"><div class="line">btstack_packet_handler_t l2cap_packet_handler;</div><div class="line"></div><div class="line">void btstack_setup(){</div><div class="line">    ...</div><div class="line">    l2cap_init();</div><div class="line">}</div><div class="line"></div><div class="line">void create_outgoing_l2cap_channel(bd_addr_t address, uint16_t psm, uint16_t mtu){</div><div class="line">     l2cap_create_channel_internal(NULL, l2cap_packet_handler, remote_bd_addr, psm, mtu);</div><div class="line">}</div><div class="line"></div><div class="line">void l2cap_packet_handler(uint8_t packet_type, uint16_t channel, uint8_t *packet, uint16_t size){</div><div class="line">    if (packet_type == HCI_EVENT_PACKET &amp;&amp;</div><div class="line">          packet[0] == L2CAP_EVENT_CHANNEL_OPENED){</div><div class="line">        if (packet[2]) {</div><div class="line">            printf(&quot;Connection failed\n\r&quot;);</div><div class="line">            return;</div><div class="line">        }</div><div class="line">        printf(&quot;Connected\n\r&quot;);</div><div class="line">    }</div><div class="line">    if (packet_type == L2CAP_DATA_PACKET){</div><div class="line">        // handle L2CAP data packet</div><div class="line">        return;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h3>Provide an L2CAP service</h3>
<p>To provide an L2CAP service, the application on a local Bluetooth device must init the L2CAP layer and register the service with <em>l2cap_register_service_internal</em>. From there on, it can wait for incoming L2CAP connections. The application can accept or deny an incoming connection by calling the <em>l2cap_accept_connection_internal</em> and <em>l2cap_deny_connection_internal</em> functions respectively. If a connection is accepted and the incoming L2CAP channel gets successfully opened, the L2CAP service can send L2CAP data packets to the connected device with <em>l2cap_send_internal</em>.</p>
<p>Sending of L2CAP data packets may fail due to a full internal BTstack outgoing packet buffer, or if the ACL buffers in the Bluetooth module become full, i.e., if the application is sending faster than the packets can be transferred over the air. In such case, the application can try sending again upon reception of DAEMON_EVENT_HCI_PACKET_SENT or L2CAP_EVENT_CREDITS event. The first event signals that the internal BTstack outgoing buffer became free again, the second one signals the same for ACL buffers in the Bluetooth chipset. Listing <a href="../../#lst:L2CAPService">below</a> provides L2CAP service example code.</p>
<div class="fragment"><div class="line">void btstack_setup(){</div><div class="line">    ...</div><div class="line">    l2cap_init();</div><div class="line">    l2cap_register_service_internal(NULL, packet_handler, 0x11,100);</div><div class="line">}</div><div class="line"></div><div class="line">void packet_handler (uint8_t packet_type, uint16_t channel, uint8_t *packet, uint16_t size){</div><div class="line">      ...</div><div class="line">      if (packet_type == L2CAP_DATA_PACKET){</div><div class="line">        // handle L2CAP data packet</div><div class="line">        return;</div><div class="line">    }</div><div class="line">    switch(event){</div><div class="line">        ...</div><div class="line">        case L2CAP_EVENT_INCOMING_CONNECTION:</div><div class="line">            bt_flip_addr(event_addr, &amp;packet[2]);</div><div class="line">            handle     = READ_BT_16(packet, 8); </div><div class="line">            psm        = READ_BT_16(packet, 10); </div><div class="line">            local_cid  = READ_BT_16(packet, 12); </div><div class="line">            printf(&quot;L2CAP incoming connection requested.&quot;);</div><div class="line">            l2cap_accept_connection_internal(local_cid);</div><div class="line">            break;</div><div class="line">        case L2CAP_EVENT_CHANNEL_OPENED:</div><div class="line">            bt_flip_addr(event_addr, &amp;packet[3]);</div><div class="line">            psm = READ_BT_16(packet, 11); </div><div class="line">            local_cid = READ_BT_16(packet, 13); </div><div class="line">            handle = READ_BT_16(packet, 9);</div><div class="line">            if (packet[2] == 0) {</div><div class="line">                printf(&quot;Channel successfully opened.&quot;);</div><div class="line">            } else {</div><div class="line">                printf(&quot;L2CAP connection failed. status code.&quot;);</div><div class="line">            }</div><div class="line">            break;        </div><div class="line">        case L2CAP_EVENT_CREDITS:</div><div class="line">        case DAEMON_EVENT_HCI_PACKET_SENT:</div><div class="line">            tryToSend();</div><div class="line">            break;</div><div class="line">        case L2CAP_EVENT_CHANNEL_CLOSED:</div><div class="line">            break;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h3>L2CAP LE - L2CAP Low Energy Protocol</h3>
<p>In addition to the full L2CAP implementation in the <em>src</em> folder, BTstack provides an optimized <em>l2cap_le</em> implementation in the <em>ble</em> folder. This L2CAP LE variant can be used for single-mode devices and provides the base for the ATT and SMP protocols.</p>
<h2>RFCOMM - Radio Frequency Communication Protocol</h2>
<p>The Radio frequency communication (RFCOMM) protocol provides emulation of serial ports over the L2CAP protocol. and reassembly. It is the base for the Serial Port Profile and other profiles used for telecommunication like Head-Set Profile, Hands-Free Profile, Object Exchange (OBEX) etc.</p>
<h3>RFCOMM flow control {#sec:flowControlProtocols}</h3>
<p>RFCOMM has a mandatory credit-based flow-control. This means that two devices that established RFCOMM connection, use credits to keep track of how many more RFCOMM data packets can be sent to each. If a device has no (outgoing) credits left, it cannot send another RFCOMM packet, the transmission must be paused. During the connection establishment, initial credits are provided. BTstack tracks the number of credits in both directions. If no outgoing credits are available, the RFCOMM send function will return an error, and you can try later. For incoming data, BTstack provides channels and services with and without automatic credit management via different functions to create/register them respectively. If the management of credits is automatic, the new credits are provided when needed relying on ACL flow control - this is only useful if there is not much data transmitted and/or only one physical connection is used. If the management of credits is manual, credits are provided by the application such that it can manage its receive buffers explicitly.</p>
<h3>Access an RFCOMM service on a remote device {#sec:rfcommClientProtocols}</h3>
<p>To communicate with an RFCOMM service on a remote device, the application on a local Bluetooth device initiates the RFCOMM layer using the <em>rfcomm_init</em> function, and then creates an outgoing RFCOMM channel to a given server channel on a remote device using the <em>rfcomm_create_channel_internal</em> function. The <em>rfcomm_create_channel_internal</em> function will initiate a new L2CAP connection for the RFCOMM multiplexer, if it does not already exist. The channel will automatically provide enough credits to the remote side. To provide credits manually, you have to create the RFCOMM connection by calling <em>rfcomm_create_channel_with_initial_credits_internal</em> - see Section <a href="../../#sec:manualCreditsProtocols">on manual credit assignement</a>.</p>
<p>The packet handler that is given as an input parameter of the RFCOMM create channel function will be assigned to the new outgoing channel. This handler receives the RFCOMM_EVENT_OPEN_CHANNEL_COMPLETE and RFCOMM_EVENT_CHANNEL_CLOSED events, and RFCOMM data packets, as shown in Listing <a href="../../#lst:RFCOMMremoteService">below</a>.</p>
<div class="fragment"><div class="line">void init_rfcomm(){</div><div class="line">    ...</div><div class="line">    rfcomm_init();</div><div class="line">    rfcomm_register_packet_handler(packet_handler);</div><div class="line">}</div><div class="line"></div><div class="line">void create_rfcomm_channel(uint8_t packet_type, uint8_t *packet, uint16_t size){</div><div class="line">    rfcomm_create_channel_internal(connection, addr, rfcomm_channel);</div><div class="line">}</div><div class="line"></div><div class="line">void rfcomm_packet_handler(uint8_t packet_type, uint16_t channel, uint8_t *packet, uint16_t size){</div><div class="line">    if (packet_type == HCI_EVENT_PACKET &amp;&amp; packet[0] == RFCOMM_EVENT_OPEN_CHANNEL_COMPLETE){</div><div class="line">        if (packet[2]) {</div><div class="line">            printf(&quot;Connection failed\n\r&quot;);</div><div class="line">            return;</div><div class="line">        }</div><div class="line">        printf(&quot;Connected\n\r&quot;);</div><div class="line">    }</div><div class="line"></div><div class="line">    if (packet_type == RFCOMM_DATA_PACKET){</div><div class="line">        // handle RFCOMM data packets</div><div class="line">        return;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h3>Provide an RFCOMM service {#sec:rfcommServiceProtocols}</h3>
<p>To provide an RFCOMM service, the application on a local Bluetooth device must first init the L2CAP and RFCOMM layers and then register the service with <em>rfcomm_register_service_internal</em>. From there on, it can wait for incoming RFCOMM connections. The application can accept or deny an incoming connection by calling the <em>rfcomm_accept_connection_internal</em> and <em>rfcomm_deny_connection_internal</em> functions respectively. If a connection is accepted and the incoming RFCOMM channel gets successfully opened, the RFCOMM service can send RFCOMM data packets to the connected device with <em>rfcomm_send_internal</em> and receive data packets by the packet handler provided by the <em>rfcomm_register_service_internal</em> call.</p>
<p>Sending of RFCOMM data packets may fail due to a full internal BTstack outgoing packet buffer, or if the ACL buffers in the Bluetooth module become full, i.e., if the application is sending faster than the packets can be transferred over the air. In such case, the application can try sending again upon reception of DAEMON_EVENT_HCI_PACKET_SENT or RFCOMM_EVENT_CREDITS event. The first event signals that the internal BTstack outgoing buffer became free again, the second one signals that the remote side allowed to send another packet. Listing <a href="../../#lst:RFCOMMService">below</a> provides the RFCOMM service example code.</p>
<div class="fragment"><div class="line">void btstack_setup(){</div><div class="line">    ...</div><div class="line">    rfcomm_init();</div><div class="line">    rfcomm_register_service_internal(NULL, rfcomm_channel_nr, mtu); </div><div class="line">}</div><div class="line"></div><div class="line">void packet_handler(uint8_t packet_type, uint8_t *packet, uint16_t size){</div><div class="line">    if (packet_type == RFCOMM_DATA_PACKET){</div><div class="line">        // handle RFCOMM data packets</div><div class="line">        return;</div><div class="line">    }</div><div class="line">    ...</div><div class="line">    switch (event) {</div><div class="line">        ...</div><div class="line">        case RFCOMM_EVENT_INCOMING_CONNECTION:</div><div class="line">            //data: event(8), len(8), address(48), channel(8), rfcomm_cid(16)</div><div class="line">            bt_flip_addr(event_addr, &amp;packet[2]); </div><div class="line">            rfcomm_channel_nr = packet[8];</div><div class="line">            rfcomm_channel_id = READ_BT_16(packet, 9);</div><div class="line">            rfcomm_accept_connection_internal(rfcomm_channel_id);</div><div class="line">            break;</div><div class="line">        case RFCOMM_EVENT_OPEN_CHANNEL_COMPLETE:</div><div class="line">           // data: event(8), len(8), status (8), address (48), handle(16), server channel(8), rfcomm_cid(16), max frame size(16)</div><div class="line">            if (packet[2]) {</div><div class="line">                printf(&quot;RFCOMM channel open failed.&quot;);</div><div class="line">                break;</div><div class="line">            } </div><div class="line">           // data: event(8), len(8), status (8), address (48), handle (16), server channel(8), rfcomm_cid(16), max frame size(16)</div><div class="line">           rfcomm_channel_id = READ_BT_16(packet, 12);</div><div class="line">           mtu = READ_BT_16(packet, 14);</div><div class="line">           printf(&quot;RFCOMM channel open succeeded.&quot;);</div><div class="line">           break;</div><div class="line">        case RFCOMM_EVENT_CREDITS:</div><div class="line">        case DAEMON_EVENT_HCI_PACKET_SENT:</div><div class="line">            tryToSend();</div><div class="line">            break;</div><div class="line"></div><div class="line">        case RFCOMM_EVENT_CHANNEL_CLOSED:</div><div class="line">            printf(&quot;Channel closed.&quot;);</div><div class="line">            rfcomm_channel_id = 0;</div><div class="line">        break;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h3>Living with a single output buffer {#sec:singleBufferProtocols}</h3>
<p>Outgoing packets, both commands and data, are not queued in BTstack. This section explains the consequences of this design decision for sending data and why it is not as bad as it sounds.</p>
<p>Independent from the number of output buffers, packet generation has to be adapted to the remote receiver and/or maximal link speed. Therefore, a packet can only be generated when it can get sent. With this assumption, the single output buffer design does not impose additional restrictions. In the following, we show how this is used for adapting the RFCOMM send rate.</p>
<p>Before sending data packets, check if RFCOMM can send them by calling rfcomm_can_send_packet_now, as shown in Listing <a href="../../#lst:SingleOutputBufferTryToSend">below</a>. L2CAP, BNEP, and ATT API offer similar functions.</p>
<div class="fragment"><div class="line">void prepareData(void){</div><div class="line">    ...</div><div class="line">}</div><div class="line"></div><div class="line">void tryToSend(void){</div><div class="line">    if (!dataLen) return;</div><div class="line">    if (!rfcomm_channel_id) return;</div><div class="line">    if (!rfcomm_can_send_packet_now(rfcomm_channel_id)) return;</div><div class="line"></div><div class="line">    int err = rfcomm_send_internal(rfcomm_channel_id,  dataBuffer, dataLen);</div><div class="line">    if (err) {</div><div class="line">        log_error(&quot;rfcomm_send_internal -&gt; error 0X%02x&quot;, err);</div><div class="line">        return;</div><div class="line">    }</div><div class="line">    // packet is sent prepare next one</div><div class="line">    prepareData();</div><div class="line">}</div></div><!-- fragment --><p>RFCOMM’s mandatory credit-based flow-control imposes an additional constraint on sending a data packet - at least one new RFCOMM credit must be available. BTstack signals the availability of a credit by sending an RFCOMM credit (RFCOMM_EVENT_CREDITS) event.</p>
<p>These two events represent two orthogonal mechanisms that deal with flow control. Taking these mechanisms in account, the application should try to send data packets when one of these two events is received. For an RFCOMM example see Listing <a href="../../#lst:SingleOutputBufferTryPH">below</a>.</p>
<div class="fragment"><div class="line">void packet_handler (uint8_t packet_type, uint16_t channel, uint8_t *packet, uint16_t size){</div><div class="line">    ...</div><div class="line">    switch(event){</div><div class="line">        case RFCOMM_EVENT_OPEN_CHANNEL_COMPLETE:</div><div class="line">            if (status) {</div><div class="line">                printf(&quot;RFCOMM channel open failed.&quot;);</div><div class="line">            } else {</div><div class="line">                rfcomm_channel_id = READ_BT_16(packet, 12);</div><div class="line">                rfcomm_mtu = READ_BT_16(packet, 14);</div><div class="line">                printf(&quot;RFCOMM channel opened, mtu = %u.&quot;, rfcomm_mtu);</div><div class="line">            }</div><div class="line">            break;</div><div class="line">        case RFCOMM_EVENT_CREDITS:</div><div class="line">        case DAEMON_EVENT_HCI_PACKET_SENT:</div><div class="line">            tryToSend();</div><div class="line">            break;</div><div class="line">        case RFCOMM_EVENT_CHANNEL_CLOSED:</div><div class="line">            rfcomm_channel_id = 0;</div><div class="line">            break;</div><div class="line">       ...</div><div class="line">       }</div><div class="line">}</div></div><!-- fragment --><p>If the management of credits is manual, credits are provided by the application such that it can manage its receive buffers explicitly, see Listing <a href="../../#lst:explicitFlowControl">below</a>.</p>
<div class="fragment"><div class="line">void btstack_setup(void){</div><div class="line">    ...</div><div class="line">    // init RFCOMM</div><div class="line">    rfcomm_init();</div><div class="line">    rfcomm_register_packet_handler(packet_handler);</div><div class="line">    // reserved channel, mtu=100, 1 credit</div><div class="line">    rfcomm_register_service_with_initial_credits_internal(NULL, rfcomm_channel_nr, 100, 1);  </div><div class="line">}</div></div><!-- fragment --><p>Manual credit management is recommended when received RFCOMM data cannot be processed immediately. In the <a href="../../examples/generated/#sec:sppflowcontrolExample">SPP flow control example</a>, delayed processing of received data is simulated with the help of a periodic timer. To provide new credits, you call the <em>rfcomm_grant_credits</em> function with the RFCOMM channel ID and the number of credits as shown in Listing <a href="../../#lst:NewCredits">below</a>.</p>
<div class="fragment"><div class="line">void processing(){</div><div class="line">    // process incoming data packet</div><div class="line">    ... </div><div class="line">    // provide new credit</div><div class="line">    rfcomm_grant_credits(rfcomm_channel_id, 1);</div><div class="line">}</div></div><!-- fragment --><p>Please note that providing single credits effectively reduces the credit-based (sliding window) flow control to a stop-and-wait flow-control that limits the data throughput substantially. On the plus side, it allows for a minimal memory footprint. If possible, multiple RFCOMM buffers should be used to avoid pauses while the sender has to wait for a new credit.</p>
<h3>Slowing down RFCOMM data reception {#sec:manualCreditsProtocols}</h3>
<p>RFCOMM’s credit-based flow-control can be used to adapt, i.e., slow down the RFCOMM data to your processing speed. For incoming data, BTstack provides channels and services with and without automatic credit management. If the management of credits is automatic, new credits are provided when needed relying on ACL flow control. This is only useful if there is not much data transmitted and/or only one physical connection is used. See Listing <a href="../../#lst:automaticFlowControl">below</a>.</p>
<div class="fragment"><div class="line">void btstack_setup(void){</div><div class="line">    ...</div><div class="line">    // init RFCOMM</div><div class="line">    rfcomm_init();</div><div class="line">    rfcomm_register_packet_handler(packet_handler);</div><div class="line">    rfcomm_register_service_internal(NULL, rfcomm_channel_nr, 100); </div><div class="line">}</div></div><!-- fragment --><h2>SDP - Service Discovery Protocol</h2>
<p>The SDP protocol allows to announce services and discover services provided by a remote Bluetooth device.</p>
<h3>Create and announce SDP records</h3>
<p>BTstack contains a complete SDP server and allows to register SDP records. An SDP record is a list of SDP Attribute *{ID, Value}* pairs that are stored in a Data Element Sequence (DES). The Attribute ID is a 16-bit number, the value can be of other simple types like integers or strings or can itselff contain other DES.</p>
<p>To create an SDP record for an SPP service, you can call <em>sdp_create_spp_service</em> from with a pointer to a buffer to store the record, the server channel number, and a record name.</p>
<p>For other types of records, you can use the other functions in , using the data element <em>de_</em> functions. Listing [sdpCreate] shows how an SDP record containing two SDP attributes can be created. First, a DES is created and then the Service Record Handle and Service Class ID List attributes are added to it. The Service Record Handle attribute is added by calling the <em>de_add_number</em> function twice: the first time to add 0x0000 as attribute ID, and the second time to add the actual record handle (here 0x1000) as attribute value. The Service Class ID List attribute has ID 0x0001, and it requires a list of UUIDs as attribute value. To create the list, <em>de_push_sequence</em> is called, which “opens” a sub-DES. The returned pointer is used to add elements to this sub-DES. After adding all UUIDs, the sub-DES is “closed” with <em>de_pop_sequence</em>.</p>
<h3>Query remote SDP service {#sec:querySDPProtocols}</h3>
<p>BTstack provides an SDP client to query SDP services of a remote device. The SDP Client API is shown in <a href="../../appendix/apis/#sec:sdpAPIAppendix">here</a>. The <em>sdp_client_query</em> function initiates an L2CAP connection to the remote SDP server. Upon connect, a <em>Service Search Attribute</em> request with a <em>Service Search Pattern</em> and a <em>Attribute ID List</em> is sent. The result of the <em>Service Search Attribute</em> query contains a list of <em>Service Records</em>, and each of them contains the requested attributes. These records are handled by the SDP parser. The parser delivers SDP_PARSER_ATTRIBUTE_VALUE and SDP_PARSER_COMPLETE events via a registered callback. The SDP_PARSER_ATTRIBUTE_VALUE event delivers the attribute value byte by byte.</p>
<p>On top of this, you can implement specific SDP queries. For example, BTstack provides a query for RFCOMM service name and channel number. This information is needed, e.g., if you want to connect to a remote SPP service. The query delivers all matching RFCOMM services, including its name and the channel number, as well as a query complete event via a registered callback, as shown in Listing <a href="../../#lst:SDPClientRFCOMM">below</a>.</p>
<div class="fragment"><div class="line">bd_addr_t remote = {0x04,0x0C,0xCE,0xE4,0x85,0xD3};</div><div class="line"></div><div class="line">void packet_handler (void * connection, uint8_t packet_type, uint16_t channel, uint8_t *packet, uint16_t size){</div><div class="line">    if (packet_type != HCI_EVENT_PACKET) return;</div><div class="line"></div><div class="line">    uint8_t event = packet[0];</div><div class="line">    switch (event) {</div><div class="line">        case BTSTACK_EVENT_STATE:</div><div class="line">            // bt stack activated, get started </div><div class="line">            if (packet[2] == HCI_STATE_WORKING){</div><div class="line">                  sdp_query_rfcomm_channel_and_name_for_uuid(remote, 0x0003);</div><div class="line">            }</div><div class="line">            break;</div><div class="line">        default:</div><div class="line">            break;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line">static void btstack_setup(){</div><div class="line">   ...</div><div class="line">    // init L2CAP</div><div class="line">    l2cap_init();</div><div class="line">    l2cap_register_packet_handler(packet_handler);</div><div class="line">}</div><div class="line"></div><div class="line">void handle_query_rfcomm_event(sdp_query_event_t * event, void * context){</div><div class="line">    sdp_query_rfcomm_service_event_t * ve;</div><div class="line"></div><div class="line">    switch (event-&gt;type){</div><div class="line">        case SDP_QUERY_RFCOMM_SERVICE:</div><div class="line">            ve = (sdp_query_rfcomm_service_event_t*) event;</div><div class="line">            printf(&quot;Service name: &#39;%s&#39;, RFCOMM port %u\n&quot;, ve-&gt;service_name, ve-&gt;channel_nr);</div><div class="line">            break;</div><div class="line">        case SDP_QUERY_COMPLETE:</div><div class="line">            report_found_services();</div><div class="line">            printf(&quot;Client query response done with status %d. \n&quot;, ce-&gt;status);</div><div class="line">            break;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line">int main(void){</div><div class="line">    hw_setup();</div><div class="line">    btstack_setup();</div><div class="line"></div><div class="line">    // register callback to receive matching RFCOMM Services and </div><div class="line">    // query complete event </div><div class="line">    sdp_query_rfcomm_register_callback(handle_query_rfcomm_event, NULL);</div><div class="line"></div><div class="line">    // turn on!</div><div class="line">    hci_power_control(HCI_POWER_ON);</div><div class="line">    // go!</div><div class="line">    run_loop_execute(); </div><div class="line">    return 0;</div><div class="line">}</div></div><!-- fragment --><h2>BNEP - Bluetooth Network Encapsulation Protocol</h2>
<p>The BNEP protocol is used to transport control and data packets over standard network protocols such as TCP, IPv4 or IPv6. It is built on top of L2CAP, and it specifies a minimum L2CAP MTU of 1691 bytes.</p>
<h3>Receive BNEP events</h3>
<p>To receive BNEP events, please register a packet handler with <em>bnep_register_packet_handler</em>.</p>
<h3>Access a BNEP service on a remote device {#sec:bnepClientProtocols}</h3>
<p>To connect to a remote BNEP service, you need to know its UUID. The set of available UUIDs can be queried by a SDP query for the PAN profile. Please see section on <a href="../../profiles/#sec:panProfiles">PAN profile</a> for details. With the remote UUID, you can create a connection using the <em>bnep_connect</em> function. You’ll receive a <em>BNEP_EVENT_OPEN_CHANNEL_COMPLETE</em> on success or failure.</p>
<p>After the connection was opened successfully, you can send and receive Ethernet packets. Before sending an Ethernet frame with <em>bnep_send</em>, <em>bnep_can_send_packet_now</em> needs to return true. Ethernet frames are received via the registered packet handler with packet type <em>BNEP_DATA_PACKET</em>.</p>
<p>BTstack BNEP implementation supports both network protocol filter and multicast filters with <em>bnep_set_net_type_filter</em> and <em>bnep_set_multicast_filter</em> respectively.</p>
<p>Finally, to close a BNEP connection, you can call <em>bnep_disconnect</em>.</p>
<h3>Provide BNEP service {#sec:bnepServiceProtocols}</h3>
<p>To provide a BNEP service, call <em>bnep_register_service</em> with the provided service UUID and a max frame size.</p>
<p>A <em>BNEP_EVENT_INCOMING_CONNECTION</em> event will mark that an incoming connection is established. At this point you can start sending and receiving Ethernet packets as described in the previous section.</p>
<h2>ATT - Attribute Protocol</h2>
<p>The ATT protocol is used by an ATT client to read and write attribute values stored on an ATT server. In addition, the ATT server can notify the client about attribute value changes. An attribute has a handle, a type, and a set of properties, see Section [section:GATTServer].</p>
<p>The Generic Attribute (GATT) profile is built upon ATT and provides higher level organization of the ATT attributes into GATT Services and GATT Characteristics. In BTstack, the complete ATT client functionality is included within the GATT Client. On the server side, one ore more GATT profiles are converted ahead of time into the corresponding ATT attribute database and provided by the <em>att_server</em> implementation. The constant data are automatically served by the ATT server upon client request. To receive the dynamic data, such is characteristic value, the application needs to register read and/or write callback. In addition, notifications and indications can be sent. Please see Section on <a href="../../profiles/#sec:GATTClientProfiles">GATT client</a> for more.</p>
<h2>SMP - Security Manager Protocol {#sec:smpProtocols}</h2>
<p>The SMP protocol allows to setup authenticated and encrypted LE connection. After initialization and configuration, SMP handles security related functions on it’s own but emits events when feedback from the main app or the user is required. The two main tasks of the SMP protocol are: bonding and identity resolving.</p>
<h3>Initialization</h3>
<p>To activate the security manager, call <em>sm_init()</em>.</p>
<p>If you’re creating a product, you should also call <em>sm_set_ir()</em> and <em>sm_set_er()</em> with a fixed random 16 byte number to create the IR and ER key seeds. If possible use a unique random number per device instead of deriving it from the product serial number or something similar. The encryption key generated by the BLE peripheral will be ultimately derived from the ER key seed. See <a href="https://www.bluetooth.org/Technical/Specifications/adopted.htm">Bluetooth Specification</a> - Bluetooth Core V4.0, Vol 3, Part G, 5.2.2 for more details on deriving the different keys. The IR key is used to identify a device if private, resolvable Bluetooth addresses are used.</p>
<h3>Configuration</h3>
<p>To receive events from the Security Manager, a callback is necessary. How to register this packet handler depends on your application configuration.</p>
<p>When <em>att_server</em> is used to provide a GATT/ATT service, <em>att_server</em> registers itself as the Security Manager packet handler. Security Manager events are then received by the application via the <em>att_server</em> packet handler.</p>
<p>If <em>att_server</em> is not used, you can directly register your packet handler with the security manager by calling <em>sm_register_packet_handler</em>.</p>
<p>The default SMP configuration in BTstack is to be as open as possible:</p>
<ul>
<li>accept all Short Term Key (STK) Generation methods,</li>
<li>accept encryption key size from 7..16 bytes,</li>
<li>expect no authentication requirements, and</li>
<li>IO Capabilities set to <em>IO_CAPABILITY_NO_INPUT_NO_OUTPUT</em>.</li>
</ul>
<p>You can configure these items by calling following functions respectively:</p>
<ul>
<li><em>sm_set_accepted_stk_generation_methods</em></li>
<li><em>sm_set_encryption_key_size_range</em></li>
<li><em>sm_set_authentication_requirements</em></li>
<li><em>sm_set_io_capabilities</em></li>
</ul>
<h3>Identity Resolving</h3>
<p>Identity resolving is the process of matching a private, resolvable Bluetooth address to a previously paired device using its Identity Resolving (IR) key. After an LE connection gets established, BTstack automatically tries to resolve the address of this device. During this lookup, BTstack will emit the following events:</p>
<ul>
<li><em>SM_IDENTITY_RESOLVING_STARTED</em> to mark the start of a lookup,</li>
</ul>
<p>and later:</p>
<ul>
<li><em>SM_IDENTITY_RESOLVING_SUCCEEDED</em> on lookup success, or</li>
<li><em>SM_IDENTITY_RESOLVING_FAILED</em> on lookup failure.</li>
</ul>
<h3>Bonding process</h3>
<p>In Bluetooth LE, there are three main methods of establishing an encrypted connection. From the most to the least secure, these are: Out-of-Band (OOB) Data , Passkey, and Just Works.</p>
<p>With OOB data, there needs to be a pre-shared secret 16 byte key. In most cases, this is not an option, especially since popular OS like iOS don’t provide a way to specify it. It some applications, where both sides of a Bluetooth link are developed together, this could provide a viable option.</p>
<p>To provide OOB data, you can register an OOB data callback with <em>sm_register_oob_data_callback</em>.</p>
<p>Depending on the authentication requirements, available OOB data, and the enabled STK generation methods, BTstack will request feedback from the app in the form of an event:</p>
<ul>
<li><em>SM_PASSKEY_INPUT_NUMBER</em>: request user to input a passkey</li>
<li><em>SM_PASSKEY_DISPLAY_NUMBER</em>: show a passkey to the user</li>
<li><em>SM_JUST_WORKS_REQUEST</em>: request a user to accept a Just Works pairing</li>
</ul>
<p>To stop the bonding process, <em>sm_bonding_decline</em> should be called. Otherwise, <em>sm_just_works_confirm</em> or <em>sm_passkey_input</em> can be called.</p>
<p>After the bonding process, <em>SM_PASSKEY_DISPLAY_CANCEL</em> is emitted to update the user interface. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
構築: &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
